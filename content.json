{"meta":{"title":"怒涛卷霜雪  天堑无涯","subtitle":"","description":"test description","author":"吴涛","url":"http://breadwinners.top","root":"/"},"pages":[{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-04-30T06:59:49.463Z","comments":true,"path":"page/index.html","permalink":"http://breadwinners.top/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2023-04-30T08:10:36.359Z","updated":"2023-04-30T08:10:36.359Z","comments":true,"path":"tags/index.html","permalink":"http://breadwinners.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-30T08:10:03.888Z","updated":"2023-04-30T08:10:03.888Z","comments":true,"path":"about/index.html","permalink":"http://breadwinners.top/about/index.html","excerpt":"","text":"一名小小大学生的小博客"},{"title":"我的朋友们","date":"2023-04-30T08:10:52.817Z","updated":"2023-04-30T08:10:52.817Z","comments":true,"path":"friends/index.html","permalink":"http://breadwinners.top/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2023-04-30T08:10:22.183Z","updated":"2023-04-30T08:10:22.183Z","comments":true,"path":"categories/index.html","permalink":"http://breadwinners.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"迁移学习 torchvision.models 加载模型参数时报错","slug":"pytorch/迁移学习torchvision.model加载模型参数时出错","date":"2023-08-19T16:00:00.000Z","updated":"2023-08-20T07:07:17.999Z","comments":true,"path":"2023/08/20/pytorch/迁移学习torchvision.model加载模型参数时出错/","link":"","permalink":"http://breadwinners.top/2023/08/20/pytorch/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0torchvision.model%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E6%97%B6%E5%87%BA%E9%94%99/","excerpt":"","text":"最近 (2022年7月) 安装或者更新了 PyTorch 和 torchvision 的同志们在跑代码时，可能会遇到如下三种报错： UserWarning: The parameter ‘pretrained’ is deprecated since 0.13 and will be removed in 0.15, please use ‘weights’ instead. UserWarning: Arguments other than a weight enum or None for ‘weights’ are deprecated since 0.13 and will be removed in 0.15. The current behavior is equivalent to passing weights&#x3D;ResNet50_Weights.IMAGENET1K_V1. You can also use weights&#x3D;ResNet50_Weights.DEFAULT to get the most up-to-date weights. 这是因为 torchvision 0.13对预训练模型加载方式作出了重大更新造成的。从 torchvision 0.13开始，torchvision提供一个全新的多权重支持API (Multi-weight support API) ，支持将不同版本的权重参数文件加载到模型中。 1、新老版本写法对比从 torchvision 0.13开始，加载预训练模型函数的参数从 pretrained = True 改为 weights=预训练模型参数版本 。且旧版本的写法将在未来的torchvision 0.15版本中被Deprecated 。 123456789101112from torchvision import models# 旧版本的写法，将在未来的torchvision 0.15版本中被Deprecatedmodel_old = models.resnet50(pretrained=True) # 或model_old = models.resnet50(True)# torchvision 0.13及以后的新版本写法model_new = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V1)# 没有预训练模型加载model = models.resnet50(weights=None)model = models.resnet50() 其中，第9行代码的 IMAGENET1K_V1 表示的是 ResNet-50 在 ImageNet 数据集上进行预训练的第一个版本的权重参数文件。是一个版本标识符。 2、新写法的好处在旧版本的写法 pretrained = True 中，对于预训练权重参数我们没有太多选择的余地，一执行起来就要使用默认的预训练权重文件版本。但问题是，现在深度学习的发展日新月异，很快就有性能更强的模型横空出世。 而使用新版本写法 weights=预训练模型参数版本 ，相当于我们掌握了预训练权重参数文件的选择权。我们就可以尽情地使用更准更快更强更新的预训练权重参数文件，帮助我们的研究更上一层楼。 举例 1234567891011from torchvision import models# 加载精度为76.130%的旧权重参数文件V1model_v1 = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V1)# 等价写法model_v1 = models.resnet50(weights=&quot;IMAGENET1K_V1&quot;)# 加载精度为80.858%的新权重参数文件V2model_v2 = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V2)# 等价写法model_v1 = models.resnet50(weights=&quot;IMAGENET1K_V2&quot;) 如果你不知道哪个权重文件的版本是最新的，没关系，直接选择默认DEFAULT即可。官方会随着 torchvision 的升级而让 DEFAULT 权重文件版本保持在最新。如下代码所示： 1234from torchvision import models# 如果你不知道哪个版本是最新, 直接选择默认DEFAULT即可model_new = models.resnet50(weights=models.ResNet50_Weights.DEFAULT) $(function() { setTimeout(function () { var mathcodeList &#x3D; document.querySelectorAll(‘.htmledit_views img.mathcode’); if (mathcodeList.length &gt; 0) { for (let i &#x3D; 0; i &lt; mathcodeList.length; i++) { if (mathcodeList[i].naturalWidth &#x3D;&#x3D;&#x3D; 0 || mathcodeList[i].naturalHeight &#x3D;&#x3D;&#x3D; 0) { var alt &#x3D; mathcodeList[i].alt; alt &#x3D; ‘\\\\(‘ + alt + ‘\\\\)’; var curSpan &#x3D; $(‘‘); curSpan.text(alt); $(mathcodeList[i]).before(curSpan); $(mathcodeList[i]).remove(); } } MathJax.Hub.Queue([“Typeset”,MathJax.Hub]); } }, 1000) }); 参考文章","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"Weights.IMAGENET1K_V1","slug":"Weights-IMAGENET1K-V1","permalink":"http://breadwinners.top/tags/Weights-IMAGENET1K-V1/"}]},{"title":"pycharm找不到conda可执行文件怎么办？","slug":"小技巧/pycharm找不到conda可执行文件怎么办？","date":"2023-08-07T16:00:00.000Z","updated":"2023-08-11T07:22:01.426Z","comments":true,"path":"2023/08/08/小技巧/pycharm找不到conda可执行文件怎么办？/","link":"","permalink":"http://breadwinners.top/2023/08/08/%E5%B0%8F%E6%8A%80%E5%B7%A7/pycharm%E6%89%BE%E4%B8%8D%E5%88%B0conda%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/","excerpt":"","text":"问题如图：在配置pycharm conda环境的过程中，pycharm找不到conda可执行文件 解决办法：实际上应该选择 然后就可以看到配置好的虚拟环境了","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"_conda","slug":"conda","permalink":"http://breadwinners.top/tags/conda/"}]},{"title":"模型训练套路","slug":"小土堆pytorch/模型训练套路","date":"2023-08-05T16:00:00.000Z","updated":"2023-08-16T08:51:40.267Z","comments":true,"path":"2023/08/06/小土堆pytorch/模型训练套路/","link":"","permalink":"http://breadwinners.top/2023/08/06/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF/","excerpt":"","text":"","categories":[{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"}],"tags":[]},{"title":"模型的存取","slug":"小土堆pytorch/模型的存取","date":"2023-08-04T16:00:00.000Z","updated":"2023-08-16T08:49:39.515Z","comments":true,"path":"2023/08/05/小土堆pytorch/模型的存取/","link":"","permalink":"http://breadwinners.top/2023/08/05/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AD%98%E5%8F%96/","excerpt":"","text":"存模型1234567891011121314151617181920212223import torchimport torchvisionfrom torch import nnvgg16 = torchvision.models.vgg16(pretrained=False)# 保存方式1,模型结构+模型参数torch.save(vgg16, &quot;vgg16_method1.pth&quot;)# 保存方式2，模型参数（官方推荐）torch.save(vgg16.state_dict(), &quot;vgg16_method2.pth&quot;)# 陷阱class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.conv1 = nn.Conv2d(3, 64, kernel_size=3) def forward(self, x): x = self.conv1(x) return xtudui = Tudui()torch.save(tudui, &quot;tudui_method1.pth&quot;) 取模型123456789101112131415161718192021222324252627import torchfrom model_save import * # 一般这样写# 方式1-&gt;保存方式1，加载模型import torchvisionfrom torch import nnmodel = torch.load(&quot;vgg16_method1.pth&quot;)# print(model)# 方式2，加载模型vgg16 = torchvision.models.vgg16(pretrained=False)vgg16.load_state_dict(torch.load(&quot;vgg16_method2.pth&quot;))# model = torch.load(&quot;vgg16_method2.pth&quot;)# print(vgg16)# 陷阱1# class Tudui(nn.Module):# def __init__(self):# super(Tudui, self).__init__()# self.conv1 = nn.Conv2d(3, 64, kernel_size=3)## def forward(self, x):# x = self.conv1(x)# return xmodel = torch.load(&#x27;tudui_method1.pth&#x27;)print(model)","categories":[{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"}],"tags":[]},{"title":"加载预训练模型及参数修改","slug":"小土堆pytorch/加载预训练模型及参数修改","date":"2023-08-04T16:00:00.000Z","updated":"2023-08-15T16:01:13.653Z","comments":true,"path":"2023/08/05/小土堆pytorch/加载预训练模型及参数修改/","link":"","permalink":"http://breadwinners.top/2023/08/05/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/%E5%8A%A0%E8%BD%BD%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BF%AE%E6%94%B9/","excerpt":"","text":"代码 添加一层 直接修改最后一层为新的层 123456789101112131415161718192021import torchvisionimport torch.nn as nn# 加载vgg16模型，并将其设置为预训练模型vgg16_false = torchvision.models.vgg16(pretrained=False)vgg16_true = torchvision.models.vgg16(pretrained=True)# 打印vgg16模型print(vgg16_false)# 将vgg16模型添加一个全连接层，输入维度为1000，输出维度为10train_data = torchvision.datasets.CIFAR10( root=&quot;./data&quot;, train=True, download=True, transform=torchvision.transforms.ToTensor())vgg16_false.add_module(&quot;add_linear&quot;, nn.Linear(1000, 10))print(vgg16_false)# 将vgg16模型的第六个全连接层改成一个全连接层，输入维度为4096，输出维度为10vgg16_true.classifier[6] = nn.Linear(4096, 10)print(vgg16_true)","categories":[{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"}],"tags":[]},{"title":"Dataset和DataLoader初步认识","slug":"小土堆pytorch/Dataset和DataLoader","date":"2023-08-03T16:00:00.000Z","updated":"2023-08-15T13:24:05.299Z","comments":true,"path":"2023/08/04/小土堆pytorch/Dataset和DataLoader/","link":"","permalink":"http://breadwinners.top/2023/08/04/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/Dataset%E5%92%8CDataLoader/","excerpt":"","text":"dataset使用12345678910111213141516171819202122232425262728293031from torch.utils.data import Datasetfrom PIL import Imageimport osclass MyData(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = os.path.join(self.root_dir, self.label_dir) self.img_path = os.listdir(self.path) def __getitem__(self, idx): img_name = self.img_path[idx] img_item_path = os.path.join(self.root_dir, self.label_dir, img_name) img = Image.open(img_item_path) label = self.label_dir return img, label def __len__(self): return len(self.img_path)root_dir = &quot;dataset/train&quot;ants_label_dir = &quot;ants&quot;bees_label_dir = &quot;bees&quot;ants_dataset = MyData(root_dir, ants_label_dir)bees_dataset = MyData(root_dir, bees_label_dir)train_dataset = ants_dataset + bees_dataset dataloader使用1234567891011121314151617181920212223242526272829import torchvision# 准备的测试数据集from torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWritertest_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor())test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True)# 测试数据集中第一张图片及targetimg, target = test_data[0]print(img.shape)print(target)writer = SummaryWriter(&quot;dataloader&quot;)for epoch in range(2): step = 0 for data in test_loader: imgs, targets = data # print(imgs.shape) # print(targets) writer.add_images(&quot;Epoch: &#123;&#125;&quot;.format(epoch), imgs, step) step = step + 1writer.close() torchvision数据集的使用官方文档： 12345678910111213141516171819202122232425262728293031323334353637383940import torchvisionfrom torch.utils.tensorboard import SummaryWriter# 定义数据集转换器dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor()])# 创建训练集和测试集train_set = torchvision.datasets.CIFAR10( root=&#x27;./datasets&#x27;, train=True, download=True, transform=dataset_transform)test_set = torchvision.datasets.CIFAR10( root=&#x27;./datasets&#x27;, train=False, download=True, transform=dataset_transform)# 打印训练集和测试集的类别# print(test_set[0])# print(test_set.classes)# img, tatget = test_set[0]# print(img.shape)# print(tatget)# print(test_set.classes[tatget])writer = SummaryWriter()# 创建SummaryWriter对象# writer = SummaryWriter()writer = SummaryWriter(&#x27;runs/test&#x27;)for i in range(10): img, target = test_set[i] writer.add_image(&#x27;test_set&#x27;, img, i)# 循环添加图片# for i in range(10):# img, target = test_set[i]# writer.add_image(&#x27;test_set&#x27;, img, i)# 关闭SummaryWriterwriter.close()","categories":[{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"}],"tags":[]},{"title":"TensorBoard使用","slug":"小土堆pytorch/TensorBoard使用","date":"2023-08-03T16:00:00.000Z","updated":"2023-08-14T13:35:10.335Z","comments":true,"path":"2023/08/04/小土堆pytorch/TensorBoard使用/","link":"","permalink":"http://breadwinners.top/2023/08/04/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/TensorBoard%E4%BD%BF%E7%94%A8/","excerpt":"","text":"运行TensorBoard123tensorboard --logdir=’logs’ --port=6007# vscode远程开发会自动进行端口转发，非常方便 代码1123456789from torch.utils.tensorboard import SummaryWriterwriter = SummaryWriter(&quot;logs&quot;)for i in range(100): writer.add_scalar(&quot;y=2x&quot;, 2 * i, i)writer.close()# 运行这个代码 代码2，显示图像12345678910111213141516from torch.utils.tensorboard import SummaryWriterimport numpy as npfrom PIL import Imagewriter = SummaryWriter(&quot;logs&quot;)img_path = &quot;dataset/train/bees/36900412_92b81831ad.jpg&quot;img_PIL = Image.open(img_path)img_array = np.array(img_PIL)# 注意接收的数据类型为ndarray，也可以是Tensorwriter.add_image(&quot;ants&quot;, img_array, 1, dataformats=&#x27;HWC&#x27;)for i in range(100): writer.add_scalar(&quot;y=x&quot;, i, i)writer.close()","categories":[{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"}],"tags":[]},{"title":"sequential","slug":"小土堆pytorch/sequential","date":"2023-08-03T16:00:00.000Z","updated":"2023-08-15T13:36:13.453Z","comments":true,"path":"2023/08/04/小土堆pytorch/sequential/","link":"","permalink":"http://breadwinners.top/2023/08/04/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/sequential/","excerpt":"","text":"原来的写法1234567891011121314151617181920212223242526272829303132333435363738from torch import nnfrom torch.nn import Conv2d, MaxPool2d, Flatten, Linearclass Tudui(nn. Module): def __init__(self): super(Tudui, self). __init__() self.conv1 = Conv2d(3, 32, 5, padding=2) self.maxpool1 = MaxPool2d(2) self.conv2 = Conv2d(32, 32, 5, padding=2) self.maxpool2 = MaxPool2d(2) self.conv3 = Conv2d(32, 64, 5, padding=2) self.maxpool3 = MaxPool2d(2) self.flatten = Flatten() self.linear1 = Linear(1024, 64) self.linear2 = Linear(64, 10) def forward(self, x): x = self.conv1(x) x = self.maxpool1(x) x = self.conv2(x) x = self.maxpool2(x) x = self.conv3(x) x = self.maxpool3(x) x = self.flatten(x) # 如果不确定Linear1输入的维度，可以把forward函数中的以下代码都注释了，然后测试输出，就可以得到正确的维度 x = self.linear1(x) x = self.linear2(x) return xtudui = Tudui()print(tudui)input = torch.ones((64, 3, 32, 32))output = tudui(input)print(output.shape)writer = SummaryWriter(&quot;../logs_seq&quot;)writer.add_graph(tudui, input)writer.close() 删除后运行输出的结果 sequential写法123456789101112131415161718192021222324252627282930313233343536import torchfrom torch import nnfrom torch.nn import Conv2d, MaxPool2d, Flatten, Linear, Sequentialfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xtudui = Tudui()print(tudui)input = torch.ones((64, 3, 32, 32))output = tudui(input)print(output.shape)writer = SummaryWriter(&quot;../logs_seq&quot;)# 将模型图写入tensorboard，放入模型和输入writer.add_graph(tudui, input)writer.close() tensorboard Graph","categories":[{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"}],"tags":[]},{"title":"Transforms的使用","slug":"小土堆pytorch/Transforms的使用","date":"2023-08-03T16:00:00.000Z","updated":"2023-08-15T02:31:29.709Z","comments":true,"path":"2023/08/04/小土堆pytorch/Transforms的使用/","link":"","permalink":"http://breadwinners.top/2023/08/04/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/Transforms%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"tramsforms的结构及用法我感觉transforms的功能就是把其他类型的数据转成Tensor类型的数据 1234567891011121314151617from torchvision import transformsfrom torch.utils.tensorboard import SummaryWriterfrom PIL import Image# 加载图像img_path = &quot;dataset/train/bees/36900412_92b81831ad.jpg&quot;img = Image.open(img_path)# 创建工具，这里是将图像转换为张量tensor_trans = transforms.ToTensor()tensor_img = tensor_trans(img)# 打印图像print(tensor_img)writter = SummaryWriter(&quot;logs&quot;)# 这回接受的数据类型是Tensorwritter.add_image(&quot;tensor_img&quot;, tensor_img)writter.close() 常用的transforms工具 transforms.ToTensor() transforms.Normalization() transforms.Resize() –&gt;输入为PIL image，图片大小转换 compose –&gt;把之前（如上1，2，3）的多种操作写在一起，更加的简洁，但是注意前面的输出是后面的输入 归一化是为了消除奇异值，及样本数据中与其他数据相比特别大或特别小的数据 这样可以加快训练速度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from torchvision import transformsfrom torch.utils.tensorboard import SummaryWriterfrom PIL import Image# 加载图像img_path = &quot;dataset/train/bees/36900412_92b81831ad.jpg&quot;img = Image.open(img_path)writter = SummaryWriter(&quot;logs&quot;)def toTensor(): # 创建工具，这里是将图像转换为张量 tensor_trans = transforms.ToTensor() img_tensor = tensor_trans(img) # 打印图像 print(img_tensor) writter.add_image(&quot;img_tensor&quot;, img_tensor, 1) writter.close()def normalize(): # 先把图片转换诚Tensor tensor_trans = transforms.ToTensor() img_tensor = tensor_trans(img) # 参数可以根据情况自己设定，一般的公开数据集是认为设定了的 normalize_trans = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) img_normalize = normalize_trans(img_tensor) writter.add_image(&quot;img_normalize&quot;, img_normalize, 2) writter.close()def resize(): print(img.size) # Resize()接收的参数类型是PIL Image的 resize_trans = transforms.Resize((224, 224)) img_resize = resize_trans(img) # 放入TensorBoard中，再次转换回Tensor tensor_trans = transforms.ToTensor() img_tensor = tensor_trans(img_resize) print(img_resize.size) writter.add_image(&quot;img_resize&quot;, img_tensor, 3) writter.close()def compose(): resize_trans_2 = transforms.Resize(512) tensor_trans = transforms.ToTensor() trans_compose = transforms.Compose([resize_trans_2, tensor_trans]) img_compose = trans_compose(img) writter.add_image(&quot;img_compose&quot;, img_compose, 4) writter.close()def randomCrop(): crop_trans = transforms.RandomCrop(99) trans_compose_2 = transforms.Compose([crop_trans, transforms.ToTensor()]) for i in range(10): img_crop = trans_compose_2(img) writter.add_image(&quot;img_crop&quot;, img_crop, i) writter.close()if __name__ == &quot;__main__&quot;: # toTensor() # normalize() # resize() # compose() randomCrop()","categories":[{"name":"小土堆pytorch## transform","slug":"小土堆pytorch-transform","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch-transform/"}],"tags":[]},{"title":"监督学习和非监督学习","slug":"吴恩达机器学习/监督学习和非监督学习","date":"2023-07-31T16:00:00.000Z","updated":"2023-08-11T12:48:38.396Z","comments":true,"path":"2023/08/01/吴恩达机器学习/监督学习和非监督学习/","link":"","permalink":"http://breadwinners.top/2023/08/01/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"监督学习Supervised Learning利用监督学习预测波士顿房价（回归问题） 利用监督学习来推测乳腺癌良性与否（分类问题） 分类问题指的是，我们试着推测出离散的输出值：0或1良性或恶性，而事实上在分类问题中，输出可能不止两个值。 分类问题有时不止两种类别，比如肿瘤可能都1类肿瘤，2类肿瘤，3类肿瘤，期待模型输出0，1，2，3等 无监督学习Unsupervised Learning 代价函数cost function 代价是每一个预测值和实际值的平方求和 这里的代价函数记为$J(w, b)$，前面的分母除以2是为了后续的求导方便 构建代价函数的目标：选择出可以使得建模误差的平方和能够最小的模型参数 直观解释不同取值的$w, b$的代价不同，代价最小的那个$w, b$就是我们选择的目标 如果用$θ0,θ1$表示权重和偏移量，代价函数可以通过如下等高线图描述： 梯度下降Gradient Descent梯度：梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。 本质上是一种贪心算法，不一定会得到全局最优解 梯度下降的实现： 学习率$α$也就是可视化图中的步长 同时要注意，同步更新$w, b$ 梯度下降原理直观解释： 拓展随机梯度下降（stochastic gradient descent，SGD）这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本，来调整超参数 $θ $，算法的公式如下所示： 因为这个样本是随机的，所以每次迭代没有办法得到一个准确的梯度，这样一来虽然每一次迭代得到的损失函数不一定是朝着全局最优方向，但是大体的方向还是朝着全局最优解的方向靠近，直到最后，得到的结果通常就会在全局最优解的附近。这种算法相比普通的梯度下降算法，收敛的速度更快，所以在一般神经网络模型训练中，随机梯度下降算法 SGD 是一种非常常见的优化算法。","categories":[{"name":"吴恩达机器学习","slug":"吴恩达机器学习","permalink":"http://breadwinners.top/categories/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"监督学习","slug":"监督学习","permalink":"http://breadwinners.top/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"非监督学习","slug":"非监督学习","permalink":"http://breadwinners.top/tags/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}]},{"title":"决策树的拆分","slug":"决策树","date":"2023-07-28T16:00:00.000Z","updated":"2023-07-29T07:09:38.789Z","comments":true,"path":"2023/07/29/决策树/","link":"","permalink":"http://breadwinners.top/2023/07/29/%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"","text":"决策树本质上是一种贪心算法，所以有时候它可能得不到全局最优解 决策树会选择信息增益大的方式判断拆分条件，信息熵计算公式： 举例： 第二种方式的信息增益大，选择第二种决策方式：","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"决策树","slug":"决策树","permalink":"http://breadwinners.top/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"}]},{"title":"卷积神经网络高级","slug":"pytorch/pytorch卷积神经网络高级","date":"2023-07-23T16:00:00.000Z","updated":"2023-08-01T01:31:10.025Z","comments":true,"path":"2023/07/24/pytorch/pytorch卷积神经网络高级/","link":"","permalink":"http://breadwinners.top/2023/07/24/pytorch/pytorch%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%AB%98%E7%BA%A7/","excerpt":"","text":"GoogleNetGoogleNet解释与实现 GoogleNet神经单元： 把整个单元封装成一个Inception Module，后续的代码直接使用该类 要注意的是，最后需要使用每一条路径torch.cat(outputs, dim=1)融合每一条路径，所以每一条路径输出的通道数必须一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import torchimport torch.nn as nnfrom torchvision import transformsfrom torchvision import datasetsfrom torch.utils.data import DataLoaderimport torch.nn.functional as Fimport torch.optim as optim # prepare dataset batch_size = 64transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))]) # 归一化,均值和方差 train_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=True, download=True, transform=transform)train_loader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size)test_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=False, download=True, transform=transform)test_loader = DataLoader(test_dataset, shuffle=False, batch_size=batch_size) # design model using classclass InceptionA(nn.Module): def __init__(self, in_channels): super(InceptionA, self).__init__() self.branch1x1 = nn.Conv2d(in_channels, 16, kernel_size=1) self.branch5x5_1 = nn.Conv2d(in_channels, 16, kernel_size=1) self.branch5x5_2 = nn.Conv2d(16, 24, kernel_size=5, padding=2) self.branch3x3_1 = nn.Conv2d(in_channels, 16, kernel_size=1) self.branch3x3_2 = nn.Conv2d(16, 24, kernel_size=3, padding=1) self.branch3x3_3 = nn.Conv2d(24, 24, kernel_size=3, padding=1) self.branch_pool = nn.Conv2d(in_channels, 24, kernel_size=1) def forward(self, x): branch1x1 = self.branch1x1(x) branch5x5 = self.branch5x5_1(x) branch5x5 = self.branch5x5_2(branch5x5) branch3x3 = self.branch3x3_1(x) branch3x3 = self.branch3x3_2(branch3x3) branch3x3 = self.branch3x3_3(branch3x3) branch_pool = F.avg_pool2d(x, kernel_size=3, stride=1, padding=1) branch_pool = self.branch_pool(branch_pool) outputs = [branch1x1, branch5x5, branch3x3, branch_pool] return torch.cat(outputs, dim=1) # b,c,w,h c对应的是dim=1 class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 10, kernel_size=5) self.conv2 = nn.Conv2d(88, 20, kernel_size=5) # 88 = 24x3 + 16 self.incep1 = InceptionA(in_channels=10) # 与conv1 中的10对应 self.incep2 = InceptionA(in_channels=20) # 与conv2 中的20对应 self.mp = nn.MaxPool2d(2) self.fc = nn.Linear(1408, 10) def forward(self, x): in_size = x.size(0) x = F.relu(self.mp(self.conv1(x))) x = self.incep1(x) x = F.relu(self.mp(self.conv2(x))) x = self.incep2(x) x = x.view(in_size, -1) x = self.fc(x) return x model = Net() # construct loss and optimizercriterion = torch.nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5) # training cycle forward, backward, update def train(epoch): running_loss = 0.0 for batch_idx, data in enumerate(train_loader, 0): inputs, target = data optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, target) loss.backward() optimizer.step() running_loss += loss.item() if batch_idx % 300 == 299: print(&#x27;[%d, %5d] loss: %.3f&#x27; % (epoch+1, batch_idx+1, running_loss/300)) running_loss = 0.0 def test(): correct = 0 total = 0 with torch.no_grad(): for data in test_loader: images, labels = data outputs = model(images) _, predicted = torch.max(outputs.data, dim=1) total += labels.size(0) correct += (predicted == labels).sum().item() print(&#x27;accuracy on test set: %d %% &#x27; % (100*correct/total)) if __name__ == &#x27;__main__&#x27;: for epoch in range(10): train(epoch) test() 梯度消失 &amp; Residual Net 一个数乘以多个一个很小的接近0的数，可能会引发梯度消失，这里解决的办法是使用跳连接，构造出H(x) = F(x) + x，这样对x求导时，导数就不出趋近于0 Residual Block的实现： Residual Network的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import torchimport torch.nn as nnfrom torchvision import transformsfrom torchvision import datasetsfrom torch.utils.data import DataLoaderimport torch.nn.functional as Fimport torch.optim as optim # prepare dataset batch_size = 64transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))]) # 归一化,均值和方差 train_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=True, download=True, transform=transform)train_loader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size)test_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=False, download=True, transform=transform)test_loader = DataLoader(test_dataset, shuffle=False, batch_size=batch_size) # design model using classclass ResidualBlock(nn.Module): def __init__(self, channels): super(ResidualBlock, self).__init__() self.channels = channels self.conv1 = nn.Conv2d(channels, channels, kernel_size=3, padding=1) self.conv2 = nn.Conv2d(channels, channels, kernel_size=3, padding=1) def forward(self, x): y = F.relu(self.conv1(x)) y = self.conv2(y) return F.relu(x + y) class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 16, kernel_size=5) self.conv2 = nn.Conv2d(16, 32, kernel_size=5) # 88 = 24x3 + 16 self.rblock1 = ResidualBlock(16) self.rblock2 = ResidualBlock(32) self.mp = nn.MaxPool2d(2) self.fc = nn.Linear(512, 10) # 暂时不知道1408咋能自动出来的 def forward(self, x): in_size = x.size(0) x = self.mp(F.relu(self.conv1(x))) x = self.rblock1(x) x = self.mp(F.relu(self.conv2(x))) x = self.rblock2(x) x = x.view(in_size, -1) x = self.fc(x) return x model = Net() # construct loss and optimizercriterion = torch.nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5) # training cycle forward, backward, update def train(epoch): running_loss = 0.0 for batch_idx, data in enumerate(train_loader, 0): inputs, target = data optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, target) loss.backward() optimizer.step() running_loss += loss.item() if batch_idx % 300 == 299: print(&#x27;[%d, %5d] loss: %.3f&#x27; % (epoch+1, batch_idx+1, running_loss/300)) running_loss = 0.0 def test(): correct = 0 total = 0 with torch.no_grad(): for data in test_loader: images, labels = data outputs = model(images) _, predicted = torch.max(outputs.data, dim=1) total += labels.size(0) correct += (predicted == labels).sum().item() print(&#x27;accuracy on test set: %d %% &#x27; % (100*correct/total)) if __name__ == &#x27;__main__&#x27;: for epoch in range(10): train(epoch) test()","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"cnn","slug":"cnn","permalink":"http://breadwinners.top/tags/cnn/"},{"name":"GoogleNet","slug":"GoogleNet","permalink":"http://breadwinners.top/tags/GoogleNet/"},{"name":"Inception Module","slug":"Inception-Module","permalink":"http://breadwinners.top/tags/Inception-Module/"},{"name":"梯度消失","slug":"梯度消失","permalink":"http://breadwinners.top/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"},{"name":"Residual Network","slug":"Residual-Network","permalink":"http://breadwinners.top/tags/Residual-Network/"}]},{"title":"RNN中的隐层","slug":"pytorch/RNN隐藏层","date":"2023-07-22T16:00:00.000Z","updated":"2023-07-25T11:55:53.965Z","comments":true,"path":"2023/07/23/pytorch/RNN隐藏层/","link":"","permalink":"http://breadwinners.top/2023/07/23/pytorch/RNN%E9%9A%90%E8%97%8F%E5%B1%82/","excerpt":"","text":"RNN(循环神经网络)中的隐层可以理解为RNN单元之间传递信息的通道。具体来说: RNN由多个相同的RNN单元堆叠组成,每个RNN单元都包含输入、隐层和输出。 隐层记录当前时刻RNN单元的状态信息,它将上一个时刻的状态和当前时刻的输入融合后输出到下一个时刻。 通过这种方式,隐层像是一个信息的通道,可以记住历史信息,并传递给当前和未来的时刻。 隐层存储的状态信息,容许RNN展开前后关联,捕捉时间序列数据中的长程依赖关系。 相比于前馈神经网络只能处理固定大小的输入,RNN通过隐层的状态传递,可以处理任意长度的序列,这是RNN独特的优势。 所以简单来说,RNN隐层是 RNN单元之间用于传递状态信息的通道,它存储历史,记忆长程依赖,使RNN成为处理时间序列数据的绝佳模型。理解隐层的这个作用,是掌握RNN的关键。","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"hidden","slug":"hidden","permalink":"http://breadwinners.top/tags/hidden/"}]},{"title":"RNN","slug":"pytorch/RNN","date":"2023-07-22T16:00:00.000Z","updated":"2023-08-01T01:46:54.757Z","comments":true,"path":"2023/07/23/pytorch/RNN/","link":"","permalink":"http://breadwinners.top/2023/07/23/pytorch/RNN/","excerpt":"","text":"1 什么是RNN？RNN是循环神经网络（Recurrent Neural Network）的缩写。它是一种神经网络结构，可以处理序列数据，例如时间序列数据或自然语言文本数据。相比于传统的前馈神经网络，RNN可以利用当前的输入和之前的状态来决定当前的输出，因此它可以捕捉到序列数据中的时间依赖关系。 在RNN中，每个时间步都有一个隐藏状态（hidden state），这个隐藏状态可以捕捉到之前时间步的信息，并且会在当前时间步中被用于计算输出。RNN的训练过程通常使用反向传播算法和梯度下降优化算法，目标是最小化模型预测值和真实值之间的误差。 RNN在自然语言处理、语音识别、时间序列预测等领域都有广泛的应用。 1.1 原理RNN的核心思想是利用当前的输入和之前的状态来决定当前的输出，这使得RNN可以处理序列数据中的时间依赖关系。RNN的结构可以看作是在时间轴上展开的多个神经网络层，每个时间步都有一个隐藏状态，这个隐藏状态可以传递到下一个时间步，并参与当前时间步的计算。 具体来说，RNN的计算可以分为三个步骤： 输入层和隐藏层之间的计算。假设当前时间步的输入是 x t x_t xt，上一个时间步的隐藏状态是 h t − 1 h_{t-1} ht−1，那么当前时间步的隐藏状态 h t h_t ht可以通过下面的公式计算得到： h t &#x3D; f ( W i h x t + b i h + W h h h t − 1 + b h h ) h_t &#x3D; f(W_{ih} x_t + b_{ih} + W_{hh} h_{t-1} + b_{hh}) ht=f(Wihxt+bih+Whhht−1+bhh) 其中 W i h W_{ih} Wih是输入层到隐藏层的权重矩阵， W h h W_{hh} Whh是隐藏层到隐藏层的权重矩阵， b i h b_{ih} bih和 b h h b_{hh} bhh是隐藏层的偏置向量， f f f是激活函数（通常是tanh或ReLU，上图中是tanh，即双曲正切函数）。 隐藏层和输出层之间的计算。假设当前时间步的隐藏状态是 h t h_t ht，那么当前时间步的输出 y t y_t yt可以通过下面的公式计算得到： y t &#x3D; g ( W h y h t + b y ) y_t&#x3D;g(W_{hy}h_t+b_y) yt=g(Whyht+by) 其中 W h y W_{hy} Why是隐藏层到输出层的权重矩阵， b y b_y by是输出层的偏置向量， g g g是输出层的激活函数（通常是softmax）。 损失函数计算和反向传播。根据任务类型，可以选择不同的损失函数，例如交叉熵损失函数用于分类任务，均方误差损失函数用于回归任务。然后使用反向传播算法和梯度下降优化算法来更新权重和偏置，目标是最小化模型预测值和真实值之间的误差。 RNN的主要优点是可以处理任意长度的序列数据，并且可以捕捉序列数据中的时间依赖关系。然而，RNN也存在一些缺点，例如难以处理长期依赖关系、训练速度慢、梯度消失和梯度爆炸等问题。因此，研究人员提出了许多改进的RNN模型，例如LSTM和GRU等。 1.2 维度说明在RNN中，输入、输出和隐藏层的维度可以根据具体的应用场景和数据集来确定。通常情况下，输入和输出的维度是固定的，而隐藏层的维度则是由用户自己指定的超参数。 以下是一些常见的维度配置： 序列分类任务中，输入通常是一个序列的特征向量，输出是一个类别标签。假设输入序列的长度为seq_len，每个时间步的特征向量维度为input_size，输出类别数为num_classes，那么输入和输出的维度分别为[batch_size, seq_len, input_size]和[batch_size, num_classes]，其中batch_size为批次大小。 序列生成任务中，输入和输出都是一个序列。假设输入序列的长度为seq_len，每个时间步的特征向量维度为input_size，输出序列的长度也为seq_len，每个时间步的特征向量维度为output_size，那么输入和输出的维度都为[batch_size, seq_len, input_size]或[batch_size, seq_len, output_size]，具体要看是什么任务。 序列标注任务中，输入通常是一个序列的特征向量，输出是每个时间步的标注信息。假设输入序列的长度为seq_len，每个时间步的特征向量维度为input_size，输出标注类别数为num_classes，那么输入和输出的维度分别为[batch_size, seq_len, input_size]和[batch_size, seq_len, num_classes]。 在隐藏层维度方面，可以根据任务和数据集的复杂程度来选择合适的值。一般来说，隐藏层的维度越大，模型的表达能力就越强，但也会增加模型的计算复杂度和训练难度。通常情况下，隐藏层的维度在几十到几百之间。 2 一些琐碎代码2.1 RNNCell 这段代码演示了如何使用PyTorch的RNNCell模块构建一个简单的RNN，并对一个简单的序列进行前向传递计算。 在代码中，我们首先构建了一个RNNCell对象，使用了输入维度为input_size、输出维度为hidden_size的隐藏层。接着，我们构造了一个大小为(seq_len, batch_size, input_size)的输入数据集dataset，并将隐藏状态hidden初始化为全零张量，大小为(batch_size, hidden_size)。 然后，我们将数据集按序列长度依次输入到RNNCell中，并在每一步更新隐藏状态hidden。在每一步中，我们打印出隐藏状态hidden的形状和值，以便了解RNN在每个时间步的输出情况。 具体来说，循环从seq_len的第0个时间步开始，依次将大小为(batch_size, input_size)的输入数据input输入到RNNCell中，并用当前的隐藏状态hidden计算下一个隐藏状态。由于这是一个简单的循环，每次更新隐藏状态时，输出的hidden大小保持不变，都是(batch_size, hidden_size)。 代码如下： 12345678910111213141516171819202122import torchbatch_size = 1seq_len = 3input_size = 4hidden_size = 2# Construction of RNNCellcell = torch.nn.RNNCell(input_size=input_size, hidden_size=hidden_size)# Wrapping the sequence into:(seqLen,batchSize,InputSize)dataset = torch.randn(seq_len, batch_size, input_size) # (3,1,4)# Initializing the hidden to zerohidden = torch.zeros(batch_size, hidden_size) # (1,2)for idx, input in enumerate(dataset): print(&#x27;=&#x27; * 20, idx, &#x27;=&#x27; * 20) #分割线，20个=号 print(&#x27;Input size:&#x27;, input.shape) # (batch_size, input_size) # 按序列依次输入到cell中，seq_len=3，故循环3次 hidden = cell(input, hidden) # 返回的hidden是下一次的输入之一，循环使用同一个cell print(&#x27;output size:&#x27;, hidden.shape) # (batch_size, hidden_size) print(hidden) 运行结果： 123456789101112==================== 0 ====================Input size: torch.Size([1, 4])output size: torch.Size([1, 2])tensor([[-0.4140, 0.1517]], grad_fn=&lt;TanhBackward0&gt;)==================== 1 ====================Input size: torch.Size([1, 4])output size: torch.Size([1, 2])tensor([[-0.4725, -0.7875]], grad_fn=&lt;TanhBackward0&gt;)==================== 2 ====================Input size: torch.Size([1, 4])output size: torch.Size([1, 2])tensor([[-0.8257, -0.2262]], grad_fn=&lt;TanhBackward0&gt;) 可以看到，每次计算后的隐藏状态hidden都是2维的张量，大小为(batch_size, hidden_size) &#x3D; (1, 2)。在每个时间步骤中，输出的hidden值都不同，因为输入数据集dataset不同，而隐藏状态hidden是随着时间步骤的推进而更新的。 2.2 RNN 这段代码演示了如何使用PyTorch的RNN模块构建一个简单的RNN，并对一个简单的序列进行前向传递计算。 在这个例子中，我们首先构建了一个RNN对象，使用了输入维度为input_size、输出维度为hidden_size的隐藏层，并设置了RNN的层数num_layers为1（上图是num_layers为3的原理图，我们这里只使用了1层RNN）。接着，我们构造了一个大小为(seq_len, batch_size, input_size)的输入数据inputs，并将隐藏状态hidden初始化为全零张量，大小为(num_layers, batch_size, hidden_size)。 然后，我们将整个输入序列inputs输入到RNN中并得到输出output和最后一个时间步的隐藏状态hidden。在这个例子中，由于我们只有一个RNN层，因此hidden的大小与初始大小相同，仅仅是在第一维上添加了一个额外的维度。 最后，我们打印输出output和隐藏状态hidden的形状和值，以便了解RNN在整个序列上的输出情况。 具体来说，我们可以看到，整个输入序列的输出output是一个大小为(seq_len, batch_size, hidden_size) &#x3D; (3, 1, 2)的张量。其中，第一维表示序列长度，第二维表示批次大小，第三维表示隐藏层输出的维度。而最后一个时间步的隐藏状态hidden是一个大小为(num_layers, batch_size, hidden_size) &#x3D; (1, 1, 2)的张量。其中，第一维表示RNN的层数，第二维表示批次大小，第三维表示隐藏层输出的维度。 代码如下： 123456789101112131415161718192021import torchbatch_size = 1seq_len = 3input_size = 4hidden_size = 2num_layers = 1 # RNN层数# Construction of RNNrnn = torch.nn.RNN(input_size=input_size, hidden_size=hidden_size, num_layers=num_layers)# Wrapping the sequence into:(seqLen,batchSize,InputSize)inputs = torch.randn(seq_len, batch_size, input_size) # (3,1,4)# Initializing the hidden to zerohidden = torch.zeros(num_layers, batch_size, hidden_size) # (1,1,2)output, hidden = rnn(inputs, hidden) # RNN内部包含了循环，故这里只需把整个序列输入即可print(&#x27;Output size:&#x27;, output.shape) # (seq_len, batch_size, hidden_size)print(&#x27;Output:&#x27;, output)print(&#x27;Hidden size:&#x27;, hidden.shape) # (num_layers, batch_size, hidden_size)print(&#x27;Hidden:&#x27;, hidden) 运行结果： 12345678Output size: torch.Size([3, 1, 2])Output: tensor([[[-0.9880, -0.8818]], [[ 0.6066, 0.9090]], [[-0.3108, 0.7957]]], grad_fn=&lt;StackBackward0&gt;)Hidden size: torch.Size([1, 1, 2])Hidden: tensor([[[-0.3108, 0.7957]]], grad_fn=&lt;StackBackward0&gt;) 可以看到，输出output是一个3维的张量，大小为(seq_len, batch_size, hidden_size) &#x3D; (3, 1, 2)，在每个时间步的输出值都不同。最后一个时间步的隐藏状态hidden是一个3维的张量，大小为(num_layers, batch_size, hidden_size) &#x3D; (1, 1, 2)，是整个序列的最后一个时间步的隐藏状态。 这个跟之前的RNNCell有什么不同呢？ 前面的例子中使用了RNNCell，它只是RNN的一个单元，用于处理一个时间步的输入数据，需要在循环中手动处理时间步。而在这个例子中，我们使用了完整的RNN模型，它内部包含了循环结构，可以一次性处理整个序列的输入，从而避免了手动处理时间步的繁琐过程。 在上面的代码中，我们使用torch.nn.RNN构造了一个RNN模型，并将整个序列inputs输入到模型中，模型内部完成了所有的循环计算，并返回了整个序列的输出output和最后一个时间步的隐状态hidden。值得注意的是，模型中的hidden状态是在不同的时间步共享的，即当前时间步的隐状态hidden是由上一个时间步的输出和隐状态计算得到的，这与前面的RNNCell是类似的。但是，完整的RNN模型会自动完成时间步之间的循环，因此更加方便。 2.3 RNN参数：batch_first在PyTorch中，RNN模型的输入通常是(seq_len, batch_size, input_size)这样的形式，即时间步序列排列在第一维，批量数据排列在第二维。但是，在某些情况下，我们可能更倾向于使用(batch_size, seq_len, input_size)的输入形式。为了满足这种需要，PyTorch提供了batch_first参数。 当batch_first&#x3D;True时，输入和输出的形状就变成了(batch_size, seq_len, input_size)，这样就更符合一般的数据格式。在构造RNN模型时，只需将batch_first参数设置为True即可。 例如，对于一个RNN模型，当batch_first&#x3D;False时，输入的形状为(seq_len, batch_size, input_size)，而**当batch_first&#x3D;True时，输入的形状为(batch_size, seq_len, input_size)**。下面是一个示例： 123456789101112131415161718192021import torchbatch_size = 1seq_len = 3input_size = 4hidden_size = 2num_layers = 1 # RNN层数# Construction of RNN, batch_first=Truernn = torch.nn.RNN(input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, batch_first=True)# 仅这里做了更改 Wrapping the sequence into:(batchSize,seqLen,InputSize)inputs = torch.randn(batch_size, seq_len, input_size) # (1,3,4)# Initializing the hidden to zerohidden = torch.zeros(num_layers, batch_size, hidden_size) # (1,1,2)output, hidden = rnn(inputs, hidden) # RNN内部包含了循环，故这里只需把整个序列输入即可print(&#x27;Output size:&#x27;, output.shape) # 输出维度发生变化(batch_size, seq_len, hidden_size)print(&#x27;Output:&#x27;, output)print(&#x27;Hidden size:&#x27;, hidden.shape) # (num_layers, batch_size, hidden_size)print(&#x27;Hidden:&#x27;, hidden) 123456Output size: torch.Size([1, 3, 2])Output: tensor([[[ 0.6276, -0.1454], [ 0.0294, 0.3148], [-0.3239, 0.4692]]], grad_fn=&lt;TransposeBackward1&gt;)Hidden size: torch.Size([1, 1, 2])Hidden: tensor([[[-0.3239, 0.4692]]], grad_fn=&lt;StackBackward0&gt;) 在上面的例子中，我们构建了一个RNN模型，将batch_first参数设置为True，并将输入数据inputs的形状设置为(batch_size, seq_len, input_size)。通过这种方式，我们可以更方便地处理输入数据，而不用担心时间步和批量之间的顺序问题。 3 例子：序列变换把 “hello” –&gt; “ohlol” 3.1 使用RNNCell输入的独热编码示意图： 输出示意图： 这段代码是一个基于RNNCell的简单的字符级别的语言模型的训练过程。具体的训练过程如下： 定义了一个大小为input_size的输入向量，大小为hidden_size的隐藏向量和批次大小为batch_size的Model类，并且在这个类的初始化函数中，构建了一个RNNCell。 使用给定的索引，将输入序列转换为 one-hot 向量，并将输入序列和标签序列都进行维度变换，使其变为 (sequence_length, batch_size, input_size) 和 (sequence_length, 1)。 定义损失函数为交叉熵损失函数，优化器为 Adam。 在循环训练的过程中，每次输入一个字符，即按序列次序进行循环。每次训练前先将优化器的梯度清零，然后使用 net.init_hidden() 初始化隐藏层，并在循环中使用 net(input, hidden) 得到下一个时间步的隐藏状态。接着计算损失，进行反向传播，更新参数。每次循环中还会打印出预测的字符和当前损失。 循环训练15次，直到训练完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import torch# 1、确定参数input_size = 4hidden_size = 4batch_size = 1# 2、准备数据index2char = [&#x27;e&#x27;, &#x27;h&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] #字典x_data = [1, 0, 2, 2, 3] #用字典中的索引（数字）表示来表示helloy_data = [3, 1, 2, 3, 2] #标签：ohlolone_hot_lookup = [[1, 0, 0, 0], # 用来将x_data转换为one-hot向量的参照表 [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]x_one_hot = [one_hot_lookup[x] for x in x_data] #将x_data转换为one-hot向量inputs = torch.Tensor(x_one_hot).view(-1, batch_size, input_size) #(𝒔𝒆𝒒𝑳𝒆𝒏,𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆,𝒊𝒏𝒑𝒖𝒕𝑺𝒊𝒛𝒆)labels = torch.LongTensor(y_data).view(-1, 1) # (seqLen*batchSize,𝟏).计算交叉熵损失时标签不需要我们进行one-hot编码，其内部会自动进行处理# 3、构建模型class Model(torch.nn.Module): def __init__(self, input_size, hidden_size, batch_size): super(Model, self).__init__() self.batch_size = batch_size self.input_size = input_size self.hidden_size = hidden_size self.rnncell = torch.nn.RNNCell(input_size=self.input_size, hidden_size=self.hidden_size) def forward(self, input, hidden): hidden = self.rnncell(input, hidden) return hidden def init_hidden(self): #初始化隐藏层，需要batch_size return torch.zeros(self.batch_size, self.hidden_size)net = Model(input_size, hidden_size, batch_size)# 4、损失和优化器criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.Adam(net.parameters(), lr=0.1) # Adam优化器# 5、训练for epoch in range(15): loss = 0 optimizer.zero_grad() #梯度清零 hidden = net.init_hidden() # 初始化隐藏层 print(&#x27;Predicted string:&#x27;, end=&#x27;&#x27;) for input, label in zip(inputs, labels): #每次输入一个字符，即按序列次序进行循环 hidden = net(input, hidden) loss += criterion(hidden, label) # 计算损失，不用item()，因为后面还要反向传播 _, idx = hidden.max(dim=1) # 选取最大值的索引 print(index2char[idx.item()], end=&#x27;&#x27;) # 打印预测的字符 loss.backward() # 反向传播 optimizer.step() # 更新参数 print(&#x27;, Epoch [%d/15] loss: %.4f&#x27; % (epoch + 1, loss.item())) 运行结果： 123456789101112131415Predicted string:hehee, Epoch [1/15] loss: 8.2711Predicted string:olhll, Epoch [2/15] loss: 6.2931Predicted string:ollll, Epoch [3/15] loss: 5.3395Predicted string:ollll, Epoch [4/15] loss: 4.7223Predicted string:ohlll, Epoch [5/15] loss: 4.2614Predicted string:ohlll, Epoch [6/15] loss: 3.9137Predicted string:ohlol, Epoch [7/15] loss: 3.6579Predicted string:ohlol, Epoch [8/15] loss: 3.4601Predicted string:ohlol, Epoch [9/15] loss: 3.2896Predicted string:ohlol, Epoch [10/15] loss: 3.1306Predicted string:ohlol, Epoch [11/15] loss: 2.9806Predicted string:ohlol, Epoch [12/15] loss: 2.8476Predicted string:ohlol, Epoch [13/15] loss: 2.7450Predicted string:ohlol, Epoch [14/15] loss: 2.6792Predicted string:ohlol, Epoch [15/15] loss: 2.6347 3.2 使用RNN在代码中，首先定义了一个RNN模型的类Model，继承自torch.nn.Module。这个模型接受一个input_size表示输入的向量维度，一个hidden_size表示隐藏层的向量维度，一个batch_size表示每批次输入数据的样本数量，以及一个可选的num_layers表示RNN的层数。 在这个类中，定义了一个RNN层self.rnn，输入为input_size和hidden_size，并指定层数为num_layers。在前向传播过程中，将输入数据input和一个全零张量hidden输入到RNN层中，然后将输出张量out从三维张量转换为二维张量，并返回输出张量。 在训练时，首先将优化器的梯度清零，然后将输入数据inputs送入模型中得到输出outputs。将输出outputs和标签labels输入到交叉熵损失函数中计算损失，然后通过反向传播计算梯度，并调用优化器的step方法更新模型参数。 最后，将输出outputs中每个时间步的预测结果取出来，转换为对应的字符，打印出来。同时，输出当前的损失和训练轮数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import torch# 1、确定参数seq_len = 5input_size = 4hidden_size = 4batch_size = 1# 2、准备数据index2char = [&#x27;e&#x27;, &#x27;h&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] #字典x_data = [1, 0, 2, 2, 3] #用字典中的索引（数字）表示来表示helloy_data = [3, 1, 2, 3, 2] #标签：ohlolone_hot_lookup = [[1, 0, 0, 0], # 用来将x_data转换为one-hot向量的参照表 [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]x_one_hot = [one_hot_lookup[x] for x in x_data] #将x_data转换为one-hot向量inputs = torch.Tensor(x_one_hot).view(seq_len, batch_size, input_size) #(𝒔𝒆𝒒𝑳𝒆𝒏,𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆,𝒊𝒏𝒑𝒖𝒕𝑺𝒊𝒛𝒆)labels = torch.LongTensor(y_data)# 3、构建模型class Model(torch.nn.Module): def __init__(self, input_size, hidden_size, batch_size, num_layers=1): super(Model, self).__init__() self.num_layers = num_layers self.batch_size = batch_size self.input_size = input_size self.hidden_size = hidden_size self.rnn = torch.nn.RNN(input_size=self.input_size, hidden_size=self.hidden_size, num_layers=num_layers) def forward(self, input): hidden = torch.zeros(self.num_layers, self.batch_size, self.hidden_size) out, _ = self.rnn(input, hidden) # out: tensor of shape (seq_len, batch, hidden_size) return out.view(-1, self.hidden_size) # 将输出的三维张量转换为二维张量,(𝒔𝒆𝒒𝑳𝒆𝒏×𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆,𝒉𝒊𝒅𝒅𝒆𝒏𝑺𝒊𝒛𝒆) def init_hidden(self): #初始化隐藏层，需要batch_size return torch.zeros(self.batch_size, self.hidden_size)net = Model(input_size, hidden_size, batch_size, num_layers)# 4、损失和优化器criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.Adam(net.parameters(), lr=0.05) # Adam优化器# 5、训练for epoch in range(15): optimizer.zero_grad() outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() _, idx = outputs.max(dim=1) idx = idx.data.numpy() print(&#x27;Predicted string: &#x27;, &#x27;&#x27;.join([index2char[x] for x in idx]), end=&#x27;&#x27;) print(&#x27;, Epoch [%d/15] loss: %.4f&#x27; % (epoch + 1, loss.item())) 运行结果： 123456789101112131415Predicted string: hhhhh, Epoch [1/15] loss: 1.4325Predicted string: hhhhh, Epoch [2/15] loss: 1.2532Predicted string: ohhoh, Epoch [3/15] loss: 1.1057Predicted string: ohlol, Epoch [4/15] loss: 0.9970Predicted string: ohlol, Epoch [5/15] loss: 0.9208Predicted string: oolol, Epoch [6/15] loss: 0.8669Predicted string: oolol, Epoch [7/15] loss: 0.8250Predicted string: oolol, Epoch [8/15] loss: 0.7863Predicted string: oolol, Epoch [9/15] loss: 0.7453Predicted string: oolol, Epoch [10/15] loss: 0.7024Predicted string: oolol, Epoch [11/15] loss: 0.6625Predicted string: oolol, Epoch [12/15] loss: 0.6291Predicted string: ohlol, Epoch [13/15] loss: 0.6026Predicted string: ohlol, Epoch [14/15] loss: 0.5812Predicted string: ohlol, Epoch [15/15] loss: 0.5630 在这段代码中，labels不需要进行.view(-1, 1)处理的原因是因为它是一个一维的LongTensor张量，形状为(seq_len,)。在 PyTorch 的交叉熵损失函数 torch.nn.CrossEntropyLoss() 中，标签需要被表示成一维的长整型张量。这是因为交叉熵损失函数在内部将标签进行了one-hot编码，并使用这些编码来计算预测值和标签之间的损失。 在这段代码中，由于 labels 是一个一维张量，因此无需进行形状变换。当然，如果你将 labels 转换为 (seq_len, 1) 的形状也可以，但是在这种情况下，torch.nn.CrossEntropyLoss() 会自动将其转换回一维张量，所以不必进行此操作。 3.3 使用embedding and linear layer在使用独热编码作为RNN输入时，有以下几个缺点： 维度灾难：对于大规模的数据集和多类分类问题，独热编码会导致输入数据维度极度膨胀，从而导致模型参数变得非常庞大，训练和推理时间变慢。 数据稀疏性：独热编码会使得大部分输入都是0，因为只有一个位置是1，这导致输入数据非常稀疏，浪费了大量的存储空间和计算资源。 无法表达序列信息：在RNN中，序列的顺序很重要，但是独热编码无法表达序列信息，只能表达每个输入在类别上的差异。因此，在处理序列数据时，独热编码可能无法捕捉到序列中的模式和规律。 无法处理未知类别：独热编码需要预先知道类别的数量，如果遇到新的类别，需要重新扩展编码向量，这会带来额外的开销和复杂度。 因此，在某些情况下，可以考虑使用其他的编码方式来解决这些问题，例如使用嵌入（embedding）向量来表示输入数据，或者使用特征哈希（feature hashing）等技术来降低维度。 嵌入（embedding）向量嵌入（embedding）向量是一种将离散型数据（如词语、用户ID等）映射到连续型向量空间中的技术，常用于自然语言处理、推荐系统等领域。 嵌入向量的原理是利用神经网络中的一层或多层进行映射。假设有n个离散化的元素，每个元素用一个唯一的整数进行编码。嵌入层的输入是这些编码，输出是每个编码对应的k维嵌入向量，通常k的值会远小于n，因此将数据从一个大的高维空间压缩到一个较小的低维空间。 在嵌入层中，每个元素的编码都被映射为一个固定长度的向量，且不同元素的向量之间可以计算相似度，这个相似度在一定程度上反映了它们在原始数据中的关系。例如，在自然语言处理中，相似的单词（如“cat”和“dog”）在嵌入空间中的向量会更加接近，因为它们在语义上有一定的相关性。 嵌入向量在许多应用中被广泛使用，例如语言模型、情感分析、推荐系统等。在自然语言处理中，通过使用嵌入向量可以将文本转换为数字，从而方便机器学习算法处理。同时，由于嵌入向量的低维度表示，计算速度较快，可以处理大规模数据集。 相关函数 代码这段代码是一个基于RNN的字符级别的语言模型，用于预测给定输入字符序列的下一个字符。下面是对代码的解释和说明： 在确定参数的部分，定义了RNN的输入和输出大小、隐藏状态的维度、Embedding向量的大小、RNN层数等参数，这些参数将会在模型的构建中使用。 在准备数据的部分，定义了一个字典index2char用于将数字索引映射到字符，输入数据x_data是一段英文字符串”hello”，并将其转换为数字索引的形式。 在构建模型的部分，使用了PyTorch中的Embedding层将输入字符的数字索引转换为固定长度的向量表示，该向量表示将在RNN中传递。使用RNN层将Embedding向量作为输入，计算RNN的输出。最后，通过一个全连接层fc将RNN的输出映射到每个字符的概率分布。在这个模型中，全连接层的作用是对RNN的输出做一个线性变换，从而将输出的维度从隐藏状态的维度变为每个字符的数量。 在定义损失函数和优化器的部分，使用了交叉熵损失函数作为模型的损失函数，Adam优化器来更新模型的参数。 在训练模型的部分，使用一个简单的循环进行模型的训练，每次训练输出当前训练次数和损失值，并打印出模型预测的字符串。在这个过程中，每个字符的Embedding向量会随着训练不断调整，最终使模型能够对字符序列做出准确的预测。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import torch# 1、确定参数num_class = 4input_size = 4hidden_size = 8embedding_size = 10num_layers = 2batch_size = 1seq_len = 5# 2、准备数据index2char = [&#x27;e&#x27;, &#x27;h&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] #字典x_data = [[1, 0, 2, 2, 3]] # (batch_size, seq_len) 用字典中的索引（数字）表示来表示helloy_data = [3, 1, 2, 3, 2] # (batch_size * seq_len) 标签：ohlolinputs = torch.LongTensor(x_data) # (batch_size, seq_len)labels = torch.LongTensor(y_data) # (batch_size * seq_len)# 3、构建模型class Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.emb = torch.nn.Embedding(num_class, embedding_size) self.rnn = torch.nn.RNN(input_size=embedding_size, hidden_size=hidden_size, num_layers=num_layers, batch_first=True) self.fc = torch.nn.Linear(hidden_size, num_class) def forward(self, x): hidden = torch.zeros(num_layers, x.size(0), hidden_size) # (num_layers, batch_size, hidden_size) x = self.emb(x) # 返回(batch_size, seq_len, embedding_size) x, _ = self.rnn(x, hidden) # 返回(batch_size, seq_len, hidden_size) x = self.fc(x) # 返回(batch_size, seq_len, num_class) return x.view(-1, num_class) # (batch_size * seq_len, num_class)net = Model()# 4、损失和优化器criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.Adam(net.parameters(), lr=0.05) # Adam优化器# 5、训练for epoch in range(15): optimizer.zero_grad() outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() _, idx = outputs.max(dim=1) idx = idx.data.numpy() print(&#x27;Predicted string: &#x27;, &#x27;&#x27;.join([index2char[x] for x in idx]), end=&#x27;&#x27;) print(&#x27;, Epoch [%d/15] loss: %.4f&#x27; % (epoch + 1, loss.item())) 运行结果： 123456789101112131415Predicted string: eeeee, Epoch [1/15] loss: 1.5407Predicted string: oolol, Epoch [2/15] loss: 1.1158Predicted string: oolol, Epoch [3/15] loss: 0.9047Predicted string: ohlol, Epoch [4/15] loss: 0.7391Predicted string: lhlol, Epoch [5/15] loss: 0.6006Predicted string: ohlol, Epoch [6/15] loss: 0.4833Predicted string: ohlol, Epoch [7/15] loss: 0.3581Predicted string: ohlol, Epoch [8/15] loss: 0.2540Predicted string: ohlol, Epoch [9/15] loss: 0.1921Predicted string: ohlol, Epoch [10/15] loss: 0.1351Predicted string: ohlol, Epoch [11/15] loss: 0.0972Predicted string: ohlol, Epoch [12/15] loss: 0.0752Predicted string: ohlol, Epoch [13/15] loss: 0.0594Predicted string: ohlol, Epoch [14/15] loss: 0.0465Predicted string: ohlol, Epoch [15/15] loss: 0.0363 4 LSTM和GRU上面 RNN 模型也存在一些局限性： 梯度消失和梯度爆炸问题：当序列非常长时，梯度可能会逐渐消失或爆炸，导致网络无法学习长序列的依赖关系。 只能学习固定长度的序列：由于 RNN 的输入和输出都是固定长度的，因此模型只能学习固定长度的序列。 处理不同时间步的输入时存在数据对齐问题：在训练 RNN 时，需要将不同长度的序列对齐到相同的长度，这通常需要一些预处理和后处理，而且可能会导致信息丢失或噪声引入。 无法很好地处理长期依赖关系：尽管 RNN 可以学习一定的序列依赖性，但是当序列的时间跨度很大时，RNN 可能会出现长期依赖问题。此外，由于 RNN 的循环结构，每个时间步的输出都依赖于前一时间步的状态，因此模型可能会受到某些时间步的信息干扰。 有几种方法可以尝试解决RNN模型的一些局限性： 使用更高级别的模型：可以使用一些更先进的模型，如LSTM（长短期记忆网络）和GRU（门控循环单元）等，这些模型在一定程度上解决了RNN模型存在的一些问题。 添加注意力机制：注意力机制可以帮助模型在输入序列中关注不同的部分，并对重要的部分进行加权，从而提高模型的准确性。 使用更多的数据：增加数据量可以帮助模型更好地学习输入序列的规律，从而提高模型的准确性。 对数据进行预处理：对输入数据进行预处理，如归一化、降噪、平滑等，可以提高模型的鲁棒性和准确性。 结合其他技术：可以结合其他技术来解决模型存在的问题，如集成学习、正则化、Dropout等。 LSTM（Long Short-Term Memory，长短期记忆网络）和GRU（Gated Recurrent Unit，门控循环单元）是常用的循环神经网络（RNN）的变种，相比于传统的RNN，它们能够更好地处理长序列数据，解决了传统RNN中的梯度消失和梯度爆炸问题。 LSTM的主要思想是引入一个称为“细胞状态”（cell state）的记忆单元，以及三个门（输入门、遗忘门和输出门）来控制对细胞状态的访问和更新。其中，输入门决定了新的输入如何影响细胞状态，遗忘门决定了何时忘记旧的细胞状态，输出门决定了输出什么样的信息。LSTM的结构相对复杂，需要较高的计算资源和训练时间。 GRU是由Cho等人于2014年提出的一种轻量级的门控循环单元，它只包含两个门（更新门和重置门），通过控制输入和历史状态的权重来控制信息流动。GRU的结构比LSTM简单，计算量也相对较小，同时在处理长序列数据时也具有不错的效果。 总的来说，LSTM和GRU是目前在循环神经网络领域中表现优异的模型，但具体选择哪种模型需要根据具体的任务和数据集来决定。 LSTM原理示意图 相关链接：如何从RNN起步，一步一步通俗理解LSTM GRU原理示意图 相关链接：人人都能看懂的GRU 原文地址","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"rnn","slug":"rnn","permalink":"http://breadwinners.top/tags/rnn/"}]},{"title":"pytorch卷积神经网络基础","slug":"pytorch/pytorch卷积神经网络基础","date":"2023-07-21T16:00:00.000Z","updated":"2023-07-23T08:01:34.011Z","comments":true,"path":"2023/07/22/pytorch/pytorch卷积神经网络基础/","link":"","permalink":"http://breadwinners.top/2023/07/22/pytorch/pytorch%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"","text":"说明 0、前一部分叫做Feature Extraction，后一部分叫做classification ​ 1、每一个卷积核它的通道数量要求和输入通道是一样的。这种卷积核的总数有多少个和你输出通道的数量是一样的。 ​ 2、卷积(convolution)后，C(Channels)变，W(width)和H(Height)可变可不变，取决于是否padding。subsampling(或pooling)后，C不变，W和H变。 ​ 3、卷积层：保留图像的空间信息。 ​ 4、卷积层要求输入输出是四维张量(B,C,W,H)，全连接层的输入与输出都是二维张量(B,Input_feature)。 ​ 传送门 PyTorch的nn.Linear（）详解 5、卷积(线性变换)，激活函数(非线性变换)，池化；这个过程若干次后，view打平，进入全连接层~ 卷积就是特征提取器 池化层是为了提取特征，是非线性的 代码说明： 1、torch.nn.Conv2d(1,10,kernel_size&#x3D;3,stride&#x3D;2,bias&#x3D;False) 1是指输入的Channel，灰色图像是1维的；10是指输出的Channel，也可以说第一个卷积层需要10个卷积核；kernel_size&#x3D;3,卷积核大小是3x3；stride&#x3D;2进行卷积运算时的步长，默认为1；bias&#x3D;False卷积运算是否需要偏置bias，默认为False。padding &#x3D; 0，卷积操作是否补0。 2、self.fc &#x3D; torch.nn.Linear(320, 10)，这个320获取的方式，可以通过x &#x3D; x.view(batch_size, -1) # print(x.shape)可得到(64,320),64指的是batch，320就是指要进行全连接操作时，输入的特征维度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import torchimport timefrom torchvision import transformsfrom torchvision import datasetsfrom torch.utils.data import DataLoaderimport torch.nn.functional as Fimport torch.optim as optim# prepare datasetbatch_size = 64transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))])train_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=True, download=True, transform=transform)train_loader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size)test_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=False, download=True, transform=transform)test_loader = DataLoader(test_dataset, shuffle=False, batch_size=batch_size)class Net(torch.nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = torch.nn.Conv2d(1, 10, kernel_size=5) self.conv2 = torch.nn.Conv2d(10, 20, kernel_size=5) self.pooling = torch.nn.MaxPool2d(2) self.fc = torch.nn.Linear(320, 10) def forward(self, x): # flatten data from (n,1,28,28) to (n, 784) &quot;&quot;&quot;举个例子,假设x的shape是(128, 20, 12, 12),取出x.size(0) = 128,用于reshape的batch size 如果不提前获取batch size,直接x.view(-1, 201212),reshape的效果将取决于每个batch的样本数,无法确定。 好像每个用到batch的地方都需要获取batch_size?????????&quot;&quot;&quot; batch_size = x.size(0) x = F.relu(self.pooling(self.conv1(x))) x = F.relu(self.pooling(self.conv2(x))) &quot;&quot;&quot; 这样做的目的是将卷积层得到的四维特征映射,reshape为全连接层更易处理的二维形式。-1会自动计算所需的那个维度的值。 也就是将四维张量reshape为二维张量,同时保持batch_size维度不变,这样就可以适配全连接层的输入。&quot;&quot;&quot; x = x.view(batch_size, -1) # 干啥用的，不太懂 ---&gt; -1 此处自动算出的是320 x = self.fc(x) return xmodel = Net()criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.5)def train(epoch): running_loss = 0.0 for batch_idx, data in enumerate(train_loader, 0): inputs, target = data optimizer.zero_grad() output = model(inputs) loss = criterion(output, target) loss.backward() optimizer.step() running_loss += loss.item() if batch_idx % 300 == 299: print(&quot;[%d %5d] loss : %.3f&quot; % (epoch + 1, batch_idx + 1, running_loss)) running_loss = 0.0def test(): correct = 0 total = 0 for batch_idx, data in enumerate(test_loader, 0): images, labels = data y_pred = model(images) _, predicted = torch.max(y_pred.data, dim=1) total += labels.size(0) correct += (y_pred == predicted).sum().item() print(&#x27;[准确率：%d %%&#x27; % (correct / total))if __name__ == &quot;__main__&quot;: for i in range(10): train(i) test() GPU版本代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import torchfrom torchvision import transformsfrom torchvision import datasetsfrom torch.utils.data import DataLoaderimport torch.nn.functional as Fimport torch.optim as optimimport matplotlib.pyplot as plt # prepare dataset batch_size = 64transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))]) train_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=True, download=True, transform=transform)train_loader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size)test_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=False, download=True, transform=transform)test_loader = DataLoader(test_dataset, shuffle=False, batch_size=batch_size) # design model using class class Net(torch.nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = torch.nn.Conv2d(1, 10, kernel_size=5) self.conv2 = torch.nn.Conv2d(10, 20, kernel_size=5) self.pooling = torch.nn.MaxPool2d(2) self.fc = torch.nn.Linear(320, 10) def forward(self, x): # flatten data from (n,1,28,28) to (n, 784) batch_size = x.size(0) x = F.relu(self.pooling(self.conv1(x))) x = F.relu(self.pooling(self.conv2(x))) x = x.view(batch_size, -1) # -1 此处自动算出的是320 # print(&quot;x.shape&quot;,x.shape) x = self.fc(x) return x model = Net()device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)model.to(device) # construct loss and optimizercriterion = torch.nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5) # training cycle forward, backward, update def train(epoch): running_loss = 0.0 for batch_idx, data in enumerate(train_loader, 0): inputs, target = data inputs, target = inputs.to(device), target.to(device) optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, target) loss.backward() optimizer.step() running_loss += loss.item() if batch_idx % 300 == 299: print(&#x27;[%d, %5d] loss: %.3f&#x27; % (epoch+1, batch_idx+1, running_loss/300)) running_loss = 0.0 def test(): correct = 0 total = 0 with torch.no_grad(): for data in test_loader: images, labels = data images, labels = images.to(device), labels.to(device) outputs = model(images) _, predicted = torch.max(outputs.data, dim=1) total += labels.size(0) correct += (predicted == labels).sum().item() print(&#x27;accuracy on test set: %d %% &#x27; % (100*correct/total)) return correct/total if __name__ == &#x27;__main__&#x27;: epoch_list = [] acc_list = [] for epoch in range(10): train(epoch) acc = test() epoch_list.append(epoch) acc_list.append(acc) plt.plot(epoch_list,acc_list) plt.ylabel(&#x27;accuracy&#x27;) plt.xlabel(&#x27;epoch&#x27;) plt.show()","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"cnn","slug":"cnn","permalink":"http://breadwinners.top/tags/cnn/"}]},{"title":"centos7安装显卡驱动配置环境等","slug":"pytorch/centos7安装显卡驱动配置环境等","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-22T07:49:51.751Z","comments":true,"path":"2023/07/20/pytorch/centos7安装显卡驱动配置环境等/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/centos7%E5%AE%89%E8%A3%85%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E7%AD%89/","excerpt":"","text":"驱动安装1. 查看显卡信息Linux查看显卡信息： 1lspci | grep -i vga 使用nvidia GPU可以： 1lspci | grep -i nvidia 2. 安装环境依赖1yum install kernel-devel gcc -y 3. 检查内核版本和源码版本，保证一致12ls /boot | grep vmlinurpm -aq | grep kernel-devel 4. 屏蔽系统自带的nouveau123456789101112查看命令： lsmod | grep nouveau修改dist-blacklist.conf文件：vim /lib/modprobe.d/dist-blacklist.conf将nvidiafb注释掉:blacklist nvidiafb然后添加以下语句：blacklist nouveauoptions nouveau modeset=0 屏蔽前： 屏蔽后： 5.重建initramfs image步骤123mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bakdracut /boot/initramfs-$(uname -r).img $(uname -r) 6. 修改运行级别为文本模式1systemctl set-default multi-user.target 7. 重新启动1reboot 8. 在NVIDIA官网下载驱动网址 9. 安装123chmod +x NVIDIA-Linux-x86_64-440.64.run./NVIDIA-Linux-x86_64-440.64.run 注意： 如果报错： unable to find the kernel source tree for the currently running kernel………，使用下面命令安装，3.10.0-1160.92.1.el7.x86_64需要改成自己的目录 1NVIDIA-Linux-x86_64-535.86.05.run --kernel-source-path=/usr/src/kernels/3.10.0-1160.92.1.el7.x86_64 -k $(uname -r) 10. 安装成功1nvidia-smi pytorch环境配置问题问题： 我之前安装的pytorch是1.2的，默认安装的cuda版本太高了，又不好降版本，小白无奈，几经折腾找到了解决办法 pytorch官网上也没有支持到cuda12.2，但是社区明确表明了兼容高版本Cuda。 解决问题： 可以用torch.cuda.is_available()的方法检验自己的torch是不是GPU版本 所以我决定直接全部卸载，重新安装GPU版本的torch全家桶 1pip uninstall torch torchvision torchaudio 然后执行安装这是本篇文章编写时最新版本的安装方法 1pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 检验是否安装成功 参考好文章 参考好文章 参考文章","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"Nvidia","slug":"Nvidia","permalink":"http://breadwinners.top/tags/Nvidia/"},{"name":"cuda","slug":"cuda","permalink":"http://breadwinners.top/tags/cuda/"},{"name":"cuda12.2","slug":"cuda12-2","permalink":"http://breadwinners.top/tags/cuda12-2/"}]},{"title":"centos7磁盘分区","slug":"Linux/centos7磁盘分区","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-22T07:53:23.584Z","comments":true,"path":"2023/07/20/Linux/centos7磁盘分区/","link":"","permalink":"http://breadwinners.top/2023/07/20/Linux/centos7%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/","excerpt":"","text":"参考文章","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"磁盘分区","slug":"磁盘分区","permalink":"http://breadwinners.top/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"lsbsk","slug":"lsbsk","permalink":"http://breadwinners.top/tags/lsbsk/"}]},{"title":"梯度下降","slug":"pytorch/deeplearing学习总结1","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T04:42:20.890Z","comments":true,"path":"2023/07/20/pytorch/deeplearing学习总结1/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/deeplearing%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931/","excerpt":"","text":"梯度下降： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import matplotlib.pyplot as plt# prepare the training setx_data = [1.0, 2.0, 3.0]y_data = [2.0, 4.0, 6.0]# initial guess of weightw = 1.0# define the model linear model y = w*xdef forward(x): return x * w# define the cost function MSEdef cost(xs, ys): cost = 0 for x, y in zip(xs, ys): y_pred = forward(x) cost += (y_pred - y) ** 2 return cost / len(xs)# define the gradient function gddef gradient(xs, ys): grad = 0 for x, y in zip(xs, ys): grad += 2 * x * (x * w - y) return grad / len(xs)epoch_list = []cost_list = []print(&#x27;predict (before training)&#x27;, 4, forward(4))for epoch in range(100): cost_val = cost(x_data, y_data) grad_val = gradient(x_data, y_data) w -= 0.01 * grad_val # 0.01 learning rate print(&#x27;epoch:&#x27;, epoch, &#x27;w=&#x27;, w, &#x27;loss=&#x27;, cost_val) epoch_list.append(epoch) cost_list.append(cost_val) # 记录均方根误差print(&#x27;predict (after training)&#x27;, 4, forward(4))plt.plot(epoch_list, cost_list)plt.ylabel(&#x27;cost&#x27;)plt.xlabel(&#x27;epoch&#x27;)plt.show() 随机梯度下降： 123456789101112131415161718192021222324252627282930313233343536373839404142import matplotlib.pyplot as pltx_data = [1.0, 2.0, 3.0]y_data = [2.0, 4.0, 6.0]w = 1.0def forward(x): return x * w# calculate loss functiondef loss(x, y): y_pred = forward(x) return (y_pred - y) ** 2# define the gradient function sgddef gradient(x, y): return 2 * x * (x * w - y)epoch_list = []loss_list = []print(&#x27;predict (before training)&#x27;, 4, forward(4))for epoch in range(100): for x, y in zip(x_data, y_data): grad = gradient(x, y) w = w - 0.01 * grad # update weight by every grad of sample of training set print(&quot;\\tgrad:&quot;, x, y, grad) l = loss(x, y) print(&quot;progress:&quot;, epoch, &quot;w=&quot;, w, &quot;loss=&quot;, l) epoch_list.append(epoch) loss_list.append(l)print(&#x27;predict (after training)&#x27;, 4, forward(4))plt.plot(epoch_list, loss_list)plt.ylabel(&#x27;loss&#x27;)plt.xlabel(&#x27;epoch&#x27;)plt.show() 区别：1、梯度下降算法种的cost是计算所有训练数据的损失，随机梯度下降种的loss是计算一个训练数据的损失。 2、梯度函数gradient()由计算所有训练数据的梯度更改为计算一个训练数据的梯度。 3、本算法中的随机梯度主要是指，每次拿一个训练数据来训练，然后更新梯度参数。本算法中梯度总共更新100(epoch)x3 &#x3D; 300次。梯度下降法中梯度总共更新100(epoch)次。","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"梯度下降","slug":"梯度下降","permalink":"http://breadwinners.top/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"},{"name":"随机梯度下降","slug":"随机梯度下降","permalink":"http://breadwinners.top/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"}]},{"title":"pytorchLogistic回归","slug":"pytorch/pytorchLogistic回归","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T05:24:45.271Z","comments":true,"path":"2023/07/20/pytorch/pytorchLogistic回归/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/pytorchLogistic%E5%9B%9E%E5%BD%92/","excerpt":"","text":"损失函数： 视频中代码F.sigmoid(self.linear(x))会引发warning，此处更改为torch.sigmoid(self.linear(x)) torch.sigmoid() 与 torch.nn.Sigmoid() 对比 BCELoss 是CrossEntropyLoss的一个特例，只用于二分类问题，而CrossEntropyLoss可以用于二分类，也可以用于多分类。 12345678910111213141516171819202122232425262728293031323334353637383940414243import torch# import torch.nn.functional as F# prepare datasetx_data = torch.Tensor([[1.0], [2.0], [3.0]])y_data = torch.Tensor([[0], [0], [1]])class LogisticRegressionModel(torch.nn.Module): def __init__(self): super(LogisticRegressionModel, self).__init__() self.linear = torch.nn.Linear(1, 1) def forward(self, x): # y_pred = F.sigmoid(self.linear(x)) y_pred = torch.sigmoid(self.linear(x)) return y_predmodel = LogisticRegressionModel()# 默认情况下，loss会基于element平均，如果size_average=False的话，loss会被累加。criterion = torch.nn.BCELoss(size_average=False)optimizer = torch.optim.SGD(model.parameters(), lr=0.01)# training cycle forward, backward, updatefor epoch in range(1000): y_pred = model(x_data) loss = criterion(y_pred, y_data) # print(epoch, loss.item()) optimizer.zero_grad() loss.backward() optimizer.step()print(&#x27;w = &#x27;, model.linear.weight.item())print(&#x27;b = &#x27;, model.linear.bias.item())x_test = torch.Tensor([[4.0]])y_test = model(x_test)print(&#x27;y_pred = &#x27;, y_test.data)","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[]},{"title":"pytorchTitanic存活率预测","slug":"pytorch/pytorchTitanic存活率预测","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T08:15:23.493Z","comments":true,"path":"2023/07/20/pytorch/pytorchTitanic存活率预测/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/pytorchTitanic%E5%AD%98%E6%B4%BB%E7%8E%87%E9%A2%84%E6%B5%8B/","excerpt":"","text":"使用pandas选取了数据集中的几个特征，来训练模型，test数据集中没有survived的预测值由于self.y_data = torch.from_numpy(np.array(self.dev_data[&quot;Survived&quot;]).astype(np.float32))这种方式读取出来的数据是一维的，所以在预测值y_pred的出来后，需要进行降维处理，才能计算损失 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import torchimport pandas as pdimport numpy as npfrom torch.utils.data import Datasetfrom torch.utils.data import DataLoaderbatch_size = 32class TitanicDatasets(Dataset): def __init__(self, filepath): data = pd.read_csv(filepath, encoding=&#x27;big5&#x27;) features = [&quot;Pclass&quot;, &quot;Sex&quot;, &quot;SibSp&quot;, &quot;Parch&quot;, &quot;Fare&quot;] self.data_len = data.shape[0] self.train_data = data[:int(self.data_len * 0.8)] &quot;&quot;&quot; 这里的features包括&quot;Pclass&quot;,&quot;Sex&quot;,&quot;SibSp&quot;,&quot;Parch&quot;,&quot;Fare&quot;。 其中&quot;Sex&quot;特征有两个类别“男”和“女”,如果直接输入分类模型,需要先转化为数值特征。 pd.get_dummies可以自动将&quot;Sex&quot;列转化为两列&quot;Sex_male&quot;和&quot;Sex_female&quot;,用于表示该样本的性别。 同时,该语句也会将其他数值特征直接转化为数值tensor。 所以,总体上pd.get_dummies的作用是: 将分类特征如“Sex”转化为onehot编码,便于模型处理 直接返回数值特征的数值tensor 将所有特征转化为符合模型输入要求的tensor格式 这样,就可以直接将处理的特征tensor输入到神经网络模型中进行训练。&quot;&quot;&quot; self.x_data = torch.from_numpy(np.array(pd.get_dummies(self.train_data[features]).astype(np.float32))) self.y_data = torch.from_numpy(np.array(self.train_data[&quot;Survived&quot;]).astype(np.float32)) self.train_len = self.train_data.shape[0] def __getitem__(self, item): return self.x_data[item], self.y_data[item] def __len__(self): return self.train_lenclass Dev_Titanic(Dataset): def __init__(self, filepath): data = pd.read_csv(filepath, encoding=&#x27;big5&#x27;) features = [&quot;Pclass&quot;, &quot;Sex&quot;, &quot;SibSp&quot;, &quot;Parch&quot;, &quot;Fare&quot;] self.data_len = data.shape[0] self.dev_data = data[int(self.data_len * 0.8):] # 验证集占20% self.x_data = torch.from_numpy(np.array(pd.get_dummies(self.dev_data[features])).astype(np.float32)) self.y_data = torch.from_numpy(np.array(self.dev_data[&quot;Survived&quot;]).astype(np.float32)) self.dev_len = self.dev_data.shape[0] def __getitem__(self, index): return self.x_data[index], self.y_data[index] def __len__(self): return self.dev_lentitanic = TitanicDatasets(&#x27;titanic/train.csv&#x27;)dev_dataset = Dev_Titanic(&quot;titanic/train.csv&quot;)titanicLoader = DataLoader(dataset=titanic, batch_size=batch_size, shuffle=True, num_workers=2)dev_loader = DataLoader(dataset=dev_dataset, batch_size=batch_size, shuffle=False, num_workers=2)class TitanicModel(torch.nn.Module): def __init__(self): super(TitanicModel, self).__init__() self.l1 = torch.nn.Linear(6, 16) self.l2 = torch.nn.Linear(16, 12) self.l3 = torch.nn.Linear(12, 8) self.l4 = torch.nn.Linear(8, 1) self.criterion = torch.nn.Sigmoid() def forward(self, x): x = self.criterion(self.l1(x)) x = self.criterion(self.l2(x)) x = self.criterion(self.l3(x)) x = self.criterion(self.l4(x)) return xmodel = TitanicModel()criterion = torch.nn.BCELoss(reduction=&#x27;mean&#x27;)optimizer = torch.optim.Adam(model.parameters(), lr=0.01)if __name__ == &quot;__main__&quot;: for epoch in range(40): running_loss = 0.0 for i, data in enumerate(titanicLoader, 1): inputs, target = data y_pred = model(inputs) y_pred = y_pred.squeeze(-1) loss = criterion(y_pred, target) running_loss += loss.item() optimizer.zero_grad() loss.backward() optimizer.step() with torch.no_grad(): correct = 0 total = 0 for batch_idx, data in enumerate(dev_loader, 1): inputs, target = data y_pred = model(inputs) y_pred = y_pred.squeeze(-1) # 降维 loss = criterion(y_pred, target) correct += (np.round(y_pred) == target).sum().item() total += target.size(0) print(&#x27;测试集准确率: %d %%&#x27; % (100 * correct / total)) test_data = pd.read_csv(&quot;titanic/test.csv&quot;) features = [&quot;Pclass&quot;, &quot;Sex&quot;, &quot;SibSp&quot;, &quot;Parch&quot;, &quot;Fare&quot;] test = torch.from_numpy(np.array(pd.get_dummies(test_data[features])).astype(np.float32)) with torch.no_grad(): y_pred = model(test) y_pred = y_pred.squeeze(-1) y = y_pred.round().int().tolist() # Tensor很多种四舍五入转int的方式，但是我只找到这种方式能够实现且在kaggle上能通过 # print(y) # y = [] # for i in y_pred: # # w = int(torch.round(i)) # # print(w) # y.append(np.round(i)) # y.append(int(torch.round(i))) output = pd.DataFrame(&#123;&quot;PassengerId&quot;: test_data.PassengerId, &quot;Survived&quot;: y&#125;) output.to_csv(&quot;predicted.csv&quot;, index=False)","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"titanic","slug":"titanic","permalink":"http://breadwinners.top/tags/titanic/"}]},{"title":"pytorch处理多维特征","slug":"pytorch/potorch处理多维特征输入","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T07:44:59.038Z","comments":true,"path":"2023/07/20/pytorch/potorch处理多维特征输入/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/potorch%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81%E8%BE%93%E5%85%A5/","excerpt":"","text":"说明：1、乘的权重(w)都一样，加的偏置(b)也一样。b变成矩阵时使用广播机制。神经网络的参数w和b是网络需要学习的，其他是已知的。 2、学习能力越强，有可能会把输入样本中噪声的规律也学到。我们要学习数据本身真实数据的规律，学习能力要有泛化能力。 3、该神经网络共3层；第一层是8维到6维的非线性空间变换，第二层是6维到4维的非线性空间变换，第三层是4维到1维的非线性空间变换。 4、本算法中torch.nn.Sigmoid() # 将其看作是网络的一层，而不是简单的函数使用 5、torch.sigmoid、torch.nn.Sigmoid和torch.nn.functional.sigmoid的区别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&quot;&quot;&quot;处理多维特征的输入 以糖尿病测试数据为例子&quot;&quot;&quot;import numpy as npimport torchimport matplotlib.pyplot as plt# prepare datasetxy = np.loadtxt(&#x27;diabetes.csv&#x27;, delimiter=&#x27;,&#x27;, dtype=np.float32)x_data = torch.from_numpy(xy[:, :-1]) # 第一个‘：’是指读取所有行，第二个‘：’是指从第一列开始，最后一列不要y_data = torch.from_numpy(xy[:, [-1]]) # [-1] 最后得到的是个矩阵# design model using classclass Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.linear1 = torch.nn.Linear(8, 32) # 输入数据x的特征是8维，x有8个特征 self.linear2 = torch.nn.Linear(32, 8) self.linear3 = torch.nn.Linear(8, 4) self.linear4 = torch.nn.Linear(4, 1) self.sigmoid = torch.nn.Sigmoid() # 将其看作是网络的一层，而不是简单的函数使用 &quot;&quot;&quot;&quot;建立三层网络而不是直接使用torc.nn.Lineral（8，1）的原因是引入非线性并增加模型学习数据中复 杂模式的能力。单个线性层将只能学习输入特征和输出之间的线性关系。通过添加具有非线性激活函数的多 层，该模型可以学习更复杂的关系，并捕捉数据中更高级别的特征。 给神经网络添加更多的层可以让它学习数据中更高层次的特征。神经网络中的每一层都学习不同级别的抽象。 通过堆叠多层，网络可以学习数据中越来越复杂的模式和关系。这是因为每一层都可以捕获和表示输入数 据的不同方面。因此，网络变得更有能力学习和表示更高层次的特征，这可以在分类或回归等任务中带来更 好的性能和准确性。&quot;&quot;&quot; # 但是为什么能呢，我只知道这样写了之后他确实能了，确实比8-&gt;1的学习效率要更好 def forward(self, x): x = self.sigmoid(self.linear1(x)) x = self.sigmoid(self.linear2(x)) x = self.sigmoid(self.linear3(x)) # y hat x = self.sigmoid(self.linear4(x)) return xmodel = Model()# construct loss and optimizer# criterion = torch.nn.BCELoss(size_average = True)criterion = torch.nn.BCELoss(reduction=&#x27;sum&#x27;)optimizer = torch.optim.Adam(model.parameters(), lr=0.1)epoch_list = []loss_list = []# training cycle forward, backward, update# t = Truefor epoch in range(100): y_pred = model(x_data) # if t: # 查看模型的输出值 # print(y_pred) # break loss = criterion(y_pred, y_data) # print(epoch, loss.item()) epoch_list.append(epoch) loss_list.append(loss.item()) optimizer.zero_grad() loss.backward() optimizer.step()plt.plot(epoch_list, loss_list)plt.ylabel(&#x27;loss&#x27;)plt.xlabel(&#x27;epoch&#x27;)plt.show()# x_test = torch.Tensor([-0.294118, 0.487437, 0.180328, -0.292929, 0, 0.00149028, -0.53117, -0.0333333])# x_test = torch.Tensor([-0.882353, -0.145729, 0.0819672, -0.414141, 0, -0.207153, -0.766866, -0.666667])x_test = torch.from_numpy(xy[0, :-1]) # 测试数据记得一定要用tensor，否则会报错x_test1 = torch.from_numpy(xy[1, :-1])y_test = model(x_test)y_test1 = model(x_test1)print(f&quot;x_test = &#123;x_test&#125;&quot;)print(f&quot;x_test1 = &#123;x_test1&#125;&quot;)print(f&quot;y = &#123;y_test.data&#125;&quot;)print(f&quot;y = &#123;y_test1.data&#125;&quot;)","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"多维度特征","slug":"多维度特征","permalink":"http://breadwinners.top/tags/%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%89%B9%E5%BE%81/"}]},{"title":"pytorch多分类问题","slug":"pytorch/pytorch多分类问题","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T07:48:26.297Z","comments":true,"path":"2023/07/20/pytorch/pytorch多分类问题/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/pytorch%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"说明： 1、softmax的输入不需要再做非线性变换，也就是说softmax之前不再需要激活函数(relu)。softmax两个作用，如果在进行softmax前的input有负数，通过指数变换，得到正数。所有类的概率求和为1。 ​ 2、y的标签编码方式是one-hot。我对one-hot的理解是只有一位是1，其他位为0。(但是标签的one-hot编码是算法完成的，算法的输入仍为原始标签) ​ 3、多分类问题，标签y的类型是LongTensor。比如说0-9分类问题，如果y &#x3D; torch.LongTensor([3])，对应的one-hot是[0,0,0,1,0,0,0,0,0,0].(这里要注意，如果使用了one-hot，标签y的类型是LongTensor，糖尿病数据集中的target的类型是FloatTensor) ​ 4、CrossEntropyLoss &lt;&#x3D;&#x3D;&gt; LogSoftmax + NLLLoss。也就是说使用CrossEntropyLoss最后一层(线性层)是不需要做其他变化的；使用NLLLoss之前，需要对最后一层(线性层)先进行SoftMax处理，再进行log操作。 代码说明：1、第8讲 from torch.utils.data import Dataset，第9讲 from torchvision import datasets。该datasets里面init，getitem,len魔法函数已实现。 ​ 2、torch.max的返回值有两个，第一个是每一行的最大值是多少，第二个是每一行最大值的下标(索引)是多少。 ​ 3、全连接神经网络 ​ 4、torch.no_grad() Python中with的用法 ​ 5、代码中”_”的说明 Python中各种下划线的操作 ​ 6、torch.max( )的用法 torch.max( )使用讲解 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import torchfrom torchvision import transformsfrom torchvision import datasetsfrom torch.utils.data import DataLoaderimport torch.nn.functional as Fimport torch.optim as optim# prepare datasetbatch_size = 64transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))]) # 归一化,均值和方差train_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=True, download=True, transform=transform)train_loader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size)test_dataset = datasets.MNIST(root=&#x27;../dataset/mnist/&#x27;, train=False, download=True, transform=transform)test_loader = DataLoader(test_dataset, shuffle=False, batch_size=batch_size)# design model using classclass Net(torch.nn.Module): def __init__(self): super(Net, self).__init__() self.l1 = torch.nn.Linear(784, 512) self.l2 = torch.nn.Linear(512, 256) self.l3 = torch.nn.Linear(256, 128) self.l4 = torch.nn.Linear(128, 64) self.l5 = torch.nn.Linear(64, 10) def forward(self, x): x = x.view(-1, 784) # -1其实就是自动获取mini_batch x = F.relu(self.l1(x)) x = F.relu(self.l2(x)) x = F.relu(self.l3(x)) x = F.relu(self.l4(x)) return self.l5(x) # 最后一层不做激活，不进行非线性变换model = Net()# construct loss and optimizercriterion = torch.nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)# training cycle forward, backward, updatedef train(epoch): running_loss = 0.0 for batch_idx, data in enumerate(train_loader, 0): # 获得一个批次的数据和标签 inputs, target = data optimizer.zero_grad() # 获得模型预测结果(64, 10) outputs = model(inputs) # 交叉熵代价函数outputs(64,10),target（64） loss = criterion(outputs, target) loss.backward() optimizer.step() running_loss += loss.item() if batch_idx % 300 == 299: print(&#x27;[%d, %5d] loss: %.3f&#x27; % (epoch + 1, batch_idx + 1, running_loss / 300)) running_loss = 0.0def te1st(): correct = 0 total = 0 flag = True with torch.no_grad(): for data in test_loader: images, labels = data outputs = model(images) if flag: print(type(outputs)) print(outputs) flag = False # dim = 1 列是第0个维度，行是第1个维度 返回的结果值，一个是下标，一个是值 同时他输出的是一个batch的预测值，每个单元的概率为一个一行，一行有10列，需要在这10列中找出最大可能的那个 _, predicted = torch.max(outputs.data, dim=1) total += labels.size(0) # 为什么不用size[0] correct += (predicted == labels).sum().item() # 张量之间的比较运算 print(&#x27;accuracy on test set: %d %% &#x27; % (100 * correct / total))if __name__ == &#x27;__main__&#x27;: for epoch in range(10): train(epoch) te1st() 参考文章","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"多分类","slug":"多分类","permalink":"http://breadwinners.top/tags/%E5%A4%9A%E5%88%86%E7%B1%BB/"},{"name":"softmax","slug":"softmax","permalink":"http://breadwinners.top/tags/softmax/"},{"name":"ontHot","slug":"ontHot","permalink":"http://breadwinners.top/tags/ontHot/"}]},{"title":"pytorch实现线性回归","slug":"pytorch/pytorch实现线性回归","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T05:16:11.052Z","comments":true,"path":"2023/07/20/pytorch/pytorch实现线性回归/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/pytorch%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","excerpt":"","text":"pytorch构建风格： 代码说明： 1、Module实现了魔法函数__call__()，call()里面有一条语句是要调用forward()。因此新写的类中需要重写forward()覆盖掉父类中的forward() 2、call函数的另一个作用是可以直接在对象后面加()，例如实例化的model对象，和实例化的linear对象 3、本算法的forward体现是通过以下语句实现的： 1y_pred = model(x_data) 由于魔法函数call的实现,model(x\\_data)将会调用model.forward(x\\_data)函数，model.forward(x\\_data)函数中的 1y_pred = self.linear(x) self.linear(x)也由于魔法函数call的实现将会调用torch.nn.Linear类中的forward，至此完成封装，也就是说forward最终是在torch.nn.Linear类中实现的，具体怎么实现，可以不用关心，大概就是y= wx + b。 pytorch 之 __call__, __init__,forward pytorch系列nn.Modlue中call的进一步解释 本实例是批量数据处理，小伙伴们不要被optimizer = torch.optim.SGD(model.parameters(), lr = 0.01)误导了，以为见了SGD就是随机梯度下降。要看传进来的数据是单个的还是批量的。这里的x_data是3个数据，是一个batch，调用的PyTorch API是 torch.optim.SGD，但这里的SGD不是随机梯度下降，而是批量梯度下降。也就是说，梯度下降算法使用的是随机梯度下降，还是批量梯度下降，还是mini-batch梯度下降，用的API都是 torch.optim.SGD。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import torch# prepare dataset# x,y是矩阵，3行1列 也就是说总共有3个数据，每个数据只有1个特征x_data = torch.tensor([[1.0], [2.0], [3.0]])y_data = torch.tensor([[2.0], [4.0], [6.0]])class LinearModel(torch.nn.Module): def __init__(self): super(LinearModel, self).__init__() # (1,1)是指输入x和输出y的特征维度，这里数据集中的x和y的特征都是1维的 # 该线性层需要学习的参数是w和b 获取w/b的方式分别是~linear.weight/linear.bias self.linear = torch.nn.Linear(1, 1) def forward(self, x): y_pred = self.linear(x) return y_predmodel = LinearModel()# construct loss and optimizercriterion = torch.nn.MSELoss(reduction=&#x27;sum&#x27;)optimizer = torch.optim.SGD(model.parameters(), lr=0.01) # model.parameters()更新需要更新的参数，这里的w和b都需要更新# training cycle forward, backward, updatefor epoch in range(100): y_pred = model(x_data) # forward:predict loss = criterion(y_pred, y_data) # forward: loss print(epoch, loss.item()) # Is it possible to set gradients to zero when calling loss.backward() in Pytorch? optimizer.zero_grad() # 反向传播之前，要进行梯度归零 loss.backward() # backward: autograd，自动计算梯度 optimizer.step() # update 参数，即更新w和b的值print(&#x27;w = &#x27;, model.linear.weight.item())print(&#x27;b = &#x27;, model.linear.bias.item())x_test = torch.tensor([[4.0]])y_test = model(x_test)print(&#x27;y_pred = &#x27;, y_test.data)","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"Linear","slug":"Linear","permalink":"http://breadwinners.top/tags/Linear/"}]},{"title":"pytorch反向传播","slug":"pytorch/pytorch反向传播","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T05:06:10.194Z","comments":true,"path":"2023/07/20/pytorch/pytorch反向传播/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/pytorch%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/","excerpt":"","text":"只更新值而不构建计算图，使用w.data，取值用w.item() 1、w是Tensor(张量类型)，Tensor中包含data和grad，data和grad也是Tensor。grad初始为None，调用l.backward()方法后w.grad为Tensor，故更新w.data时需使用w.grad.data。如果w需要计算梯度，那构建的计算图中，跟w相关的tensor都默认需要计算梯度。 2、w是Tensor， forward函数的返回值也是Tensor，loss函数的返回值也是Tensor 3、本算法中反向传播主要体现在，l.backward()。调用该方法后w.grad由None更新为Tensor类型，且w.grad.data的值用于后续w.data的更新。 l.backward()会把计算图中所有需要梯度(grad)的地方都会求出来，然后把梯度都存在对应的待求的参数中，最终计算图被释放。取tensor中的data是不会构建计算图的。 123456789101112131415161718192021222324252627282930313233import torchx_data = [1.0, 2.0, 3.0]y_data = [2.0, 4.0, 6.0]w = torch.tensor([1.0]) # w的初值为1.0w.requires_grad = True # 需要计算梯度def forward(x): return x * w # w是一个Tensordef loss(x, y): y_pred = forward(x) return (y_pred - y) ** 2print(&quot;predict (before training)&quot;, 4, forward(4).item())for epoch in range(100): for x, y in zip(x_data, y_data): l = loss(x, y) # l是一个张量，tensor主要是在建立计算图 forward, compute the loss l.backward() # backward,compute grad for Tensor whose requires_grad set to True print(&#x27;\\tgrad:&#x27;, x, y, w.grad.item()) w.data = w.data - 0.01 * w.grad.data # 权重更新时，注意grad也是一个tensor，只更新值而不构建计算图，使用w.data，取值用w.item() w.grad.data.zero_() # after update, remember set the grad to zero print(&#x27;progress:&#x27;, epoch, l.item()) # 取出loss使用l.item，不要直接使用l（l是tensor会构建计算图）print(&quot;predict (after training)&quot;, 4, forward(4).item())","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"反向传播","slug":"反向传播","permalink":"http://breadwinners.top/tags/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"}]},{"title":"加载数据集","slug":"pytorch/加载数据集","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-23T07:44:18.606Z","comments":true,"path":"2023/07/20/pytorch/加载数据集/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E9%9B%86/","excerpt":"","text":"说明：1、DataSet 是抽象类，不能实例化对象，主要是用于构造我们的数据集 ​ 2、DataLoader 需要获取DataSet提供的索引[i]和len;用来帮助我们加载数据，比如说做shuffle(提高数据集的随机性)，batch_size,能拿出Mini-Batch进行训练。它帮我们自动完成这些工作。DataLoader可实例化对象。DataLoader is a class to help us loading data in Pytorch. ​ 3、__getitem__目的是为支持下标(索引)操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import torchimport numpy as npfrom torch.utils.data import Datasetfrom torch.utils.data import DataLoader# 暂时先学会Datesets中mini-batch的用法# prepare datasetclass DiabetesDataset(Dataset): def __init__(self, filepath): xy = np.loadtxt(filepath, delimiter=&#x27;,&#x27;, dtype=np.float32) self.len = xy.shape[0] # shape(多少行，多少列) self.x_data = torch.from_numpy(xy[:, :-1]) self.y_data = torch.from_numpy(xy[:, [-1]]) &quot;&quot;&quot; pytorch例子，因为你定义的dataset对象要传给dataloader，dataloader在“load data”的时候，需要dataset对象有这个getitem方法取数据。 所以__getitem__(self, index): 和 __len__(self):必须要写，要实现 &quot;&quot;&quot; def __getitem__(self, index): return self.x_data[index], self.y_data[index] def __len__(self): return self.lendataset = DiabetesDataset(&#x27;diabetes.csv&#x27;)train_loader = DataLoader(dataset=dataset, batch_size=32, shuffle=True, num_workers=0) # num_workers 多线程# design model using classclass Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.linear1 = torch.nn.Linear(8, 6) self.linear2 = torch.nn.Linear(6, 4) self.linear3 = torch.nn.Linear(4, 1) self.sigmoid = torch.nn.Sigmoid() def forward(self, x): x = self.sigmoid(self.linear1(x)) x = self.sigmoid(self.linear2(x)) x = self.sigmoid(self.linear3(x)) return xmodel = Model()# construct loss and optimizercriterion = torch.nn.BCELoss(reduction=&#x27;mean&#x27;)optimizer = torch.optim.SGD(model.parameters(), lr=0.01)# training cycle forward, backward, updateif __name__ == &#x27;__main__&#x27;: for epoch in range(100): for i, data in enumerate(train_loader, 0): # train_loader 是先shuffle后mini_batch inputs, labels = data y_pred = model(inputs) loss = criterion(y_pred, labels) print(epoch, i, loss.item()) optimizer.zero_grad() loss.backward() optimizer.step()&quot;&quot;&quot;为什么train_loader里面的数据正好是DiabetesDataset中的self.x_data和self.y_data?train_loader里面的数据是从DiabetesDataset中采样而来的,这是由DataLoader的工作机制决定的。具体来说,在创建DataLoader时,传入了DiabetesDataset作为dataset参数。在每次迭代时,DataLoader会按batch_size=32从DiabetesDataset里采样数据,调用其__getitem__方法获取样本。而在DiabetesDataset的__getitem__方法中,正是返回了self.x_data和self.y_data中的数据:def __getitem__(self, index): return self.x_data[index], self.y_data[index] self.x_data和self.y_data又是在DiabetesDataset构造函数中从csv文件中读取并处理得到的:xy = np.loadtxt(filepath, delimiter=&#x27;,&#x27;, dtype=np.float32)self.x_data = torch.from_numpy(xy[:, :-1])self.y_data = torch.from_numpy(xy[:, [-1]])所以train_loader每次采样的样本就是来自DiabetesDataset中预处理后的self.x_data和self.y_data。这也就是为什么train_loader能够得到DiabetesDataset中的数据的原因。DataLoader通过数据集的__getitem__方法可以批量采样数据,这在Pytorch中是训练模型获取批量数据的常用方式。&quot;&quot;&quot;","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[{"name":"DataLoader","slug":"DataLoader","permalink":"http://breadwinners.top/tags/DataLoader/"},{"name":"datasets","slug":"datasets","permalink":"http://breadwinners.top/tags/datasets/"}]},{"title":"","slug":"pytorch/408/计网","date":"2023-07-19T16:00:00.000Z","updated":"2023-08-08T08:16:08.903Z","comments":true,"path":"2023/07/20/pytorch/408/计网/","link":"","permalink":"http://breadwinners.top/2023/07/20/pytorch/408/%E8%AE%A1%E7%BD%91/","excerpt":"","text":"计算机网络:是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来由功能完善的软件实现资源共享和信息传递的系统。 RTT 只管信道上的时间，不管发送端的发送时延之类的 交换方式：","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"}],"tags":[]},{"title":"中科大未来实验室win初步配置","slug":"小技巧/中科大未来实验室win初步配置","date":"2023-07-15T16:00:00.000Z","updated":"2023-08-11T07:17:36.861Z","comments":true,"path":"2023/07/16/小技巧/中科大未来实验室win初步配置/","link":"","permalink":"http://breadwinners.top/2023/07/16/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E4%B8%AD%E7%A7%91%E5%A4%A7%E6%9C%AA%E6%9D%A5%E5%AE%9E%E9%AA%8C%E5%AE%A4win%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE/","excerpt":"","text":"先下载todesk，方便操作，再安装goole浏览器方便下载要用的工具 然后开启远程桌面服务 如果是先关闭了防火墙和windows defender等服务，后续会无法开启远程服务 关闭防火墙 组策略关闭 开始&gt;运行&gt;gpedit.msc，或者直接输入“组策略” 计算机配置&gt;Windows设置&gt;安全设置&gt;高级安全Windows防火墙&gt;高级安全Windows防火墙本地策略对象&gt;Window防火墙属性 将域配置文件、专用配置文件、公用配置文件的防火墙状态都设置为【禁用】； 控制面板–&gt;系统和安全–&gt;找到防火墙关闭 设置里面也关闭Windows defender Windows搜索”服务”，找到Windows Firwall，关闭 按WIN + R ，输入 gpedit.msc 找到图示的位置 至此就可以安装frp且不会被Windows defender开机启动删除了 frp的开机启动配置可以见我的另外一篇博客 有关存镜像的问题由于用的是科大的实验室，不好一直占用别人的资源，做完实验最好要释放，所以我们可以存镜像来保存上一次实验的内容 但是用镜像重新创建的主机往往会有上不了网的问题，这里给出我的如下方法 选择了自动获取ip后再存镜像，一般来说就可以正常访问外网了 如果不行，那么进行配置IP： 在进入网站控制台的时候有个我的实验记住那个ip地址，等下要用 右击带感叹号的电脑图标，修改网络配置： 一直点确定退出即可 按理来说这时候图标已经变了 这时就可以正常访问外网了 &#x3D;&#x3D;建议首先到磁盘管理中把D盘格式化，再C盘的容量扩大一些（建议80G），如果后面数据太多C盘满了，系统会很卡，而且后续分区很麻烦&#x3D;&#x3D;","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"科大未来","slug":"科大未来","permalink":"http://breadwinners.top/tags/%E7%A7%91%E5%A4%A7%E6%9C%AA%E6%9D%A5/"}]},{"title":"numpy学习","slug":"pytorch/numpy学习","date":"2023-07-15T16:00:00.000Z","updated":"2023-07-21T14:55:08.865Z","comments":true,"path":"2023/07/16/pytorch/numpy学习/","link":"","permalink":"http://breadwinners.top/2023/07/16/pytorch/numpy%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1234a = np.array([[1,2,3,4,5], [5,6,7,8,9]])print(a.sum(axis=0))print(a.sum(axis=1))","categories":[{"name":"numpy","slug":"numpy","permalink":"http://breadwinners.top/categories/numpy/"}],"tags":[{"name":"axis","slug":"axis","permalink":"http://breadwinners.top/tags/axis/"}]},{"title":"中科大未来实验室网络镜像配置","slug":"小技巧/中科大未来实验室使用","date":"2023-07-14T16:00:00.000Z","updated":"2023-07-19T09:29:53.858Z","comments":true,"path":"2023/07/15/小技巧/中科大未来实验室使用/","link":"","permalink":"http://breadwinners.top/2023/07/15/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E4%B8%AD%E7%A7%91%E5%A4%A7%E6%9C%AA%E6%9D%A5%E5%AE%9E%E9%AA%8C%E5%AE%A4%E4%BD%BF%E7%94%A8/","excerpt":"","text":"进入中科大未来实验室，点击实验控制台科大未来 1. 创建新实验 2.选择配置公有镜像选择我这里选择之前使用win10制作完成的镜像 3. 创建实验： 4. 创建完成： 5. 启动成功后： 用户名：ustc 密码：ustc1958 1. 进入之后如果右下角是个带感叹号的电脑图标，说明网络不可用，需要配置：2. 在进入网站控制台的时候有个我的实验记住那个ip地址，等下要用 3. 右击带感叹号的电脑图标，修改网络配置： 一直点确定退出即可 按理来说这时候图标已经变了 代表可以上网了，这时候可以用RD客户端，或者桌面的todesk软件进行远程操作，也可直接在网站控制台输密码进入的页面里操作，但是感觉比较卡","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"科大未来","slug":"科大未来","permalink":"http://breadwinners.top/tags/%E7%A7%91%E5%A4%A7%E6%9C%AA%E6%9D%A5/"}]},{"title":"Pandas入门","slug":"pytorch/Pandas入门","date":"2023-07-14T16:00:00.000Z","updated":"2023-07-16T03:12:26.864Z","comments":true,"path":"2023/07/15/pytorch/Pandas入门/","link":"","permalink":"http://breadwinners.top/2023/07/15/pytorch/Pandas%E5%85%A5%E9%97%A8/","excerpt":"","text":"常用的函数123import pandas as pdtitanic = pd.read_excel(&#x27;titanic.xlsx&#x27;) # 文件在notebook文件同一目录下 读取数据123titanic.head() # 查看前5条，括号里可以写明你想看的条数titanic.tail() # 查看尾部5条titanic.sample(5) # 随机查看5条 验证数据123456titanic.shape # (100, 6) 查看行数和列数titanic.info() # 查看索引、数据类型和内存信息titanic.describe() # 查看数值型列的汇总统计titanic.dtypes # 查看各字段类型titanic.axes # 显示数据行和列名titanic.columns # 列名 读取出的整个titanic的数据类型是dataFrame，一个列的数据类型是pandas.core.series.Series 选择数据12345ages = titanic[&quot;age&quot;] # 选择一列ages.head(10)ages = titanic[[&quot;ages&quot;, &quot;sex&quot;]] # 选择两列数据，但是注意一定是要加两个中括号[[]]ages.head(20) 数据筛选 选出35岁以下的乘客的所有信息 1above_35 = titanic[titanic[&quot;age&quot;] &lt; 35] 选出级别为2nd和3nd的所有乘客信息 12class_23 = titanic[titanic[&quot;Pclass&quot;].isin([&quot;2nd&quot;, &quot;3nd&quot;])]class_23 = titanic[(titanic[&quot;Pclass&quot;] = &quot;2nd&quot;) | (titanic[&quot;Pclass&quot;&quot;] = &quot;3nd&quot;)] 选出已知年龄的乘客数据（选出年龄不为缺失值的乘客数据） 1age_no_nan = titanic[dateset[&quot;age&quot;].notna()] 选出35岁以上的乘客的姓名 1above_35 = titanic[titanic[&quot;age&quot;] &gt; 35][&quot;name&quot;] # 两次索引 只选出第10行到25行和第3到5列的数据（iloc函数） 12titanic.iloc[9:25, 2:5]titanic.iloc[0:3, 3] = &quot;anonymous&quot; # 1到3行的第4列数据赋值为&quot;anonymous&quot; 创建新列1titanic = [&#x27;新列&#x27;] = titanic[&#x27;age&#x27;] * 2 # 创建新的列，并且赋值 修改列名 12345678titanic_renamed = titanic.rename( columns=&#123; &quot;age&quot;: &quot;年龄&quot;， &quot;pclass&quot;: &quot;船舱等级&quot;， &quot;survived&quot;: &quot;生存&quot;， &#125;) titanic_renamed # 显示新的数据 统计 求平均值、中位数最大最小值等信息 123456titanic[&quot;age&quot;].mean() # 单列平均值titanic[&quot;age&quot;，&quot;survived&quot;].mean() # 求多列的平均值titanic[&quot;age&quot;].median() # 中位数titanic[&quot;age&quot;，&quot;survived&quot;].max() # 多列的最大值titanic[&quot;age&quot;].min() describe 是统计出数据的各种信息 1titanic[&quot;age&quot;].describe() 分组统计 groupby() 1titanic.groupby(&quot;sex&quot;)[&quot;age&quot;].mean() # 选出age这一列，按照sex分类，求平均值 1titanic.groupby(&quot;sex&quot;,&quot;pclass&quot;)[&quot;survived&quot;].mean() # 选出survived这一列按照sex和pclass进行分类，求 颠倒键值写法： 按照类别计数 12titanic[&quot;pclass&quot;].value_counts()titanic.groupby(&quot;pclass&quot;)[&quot;pclass&quot;].count() 建立索引1titanic.set_index(&#x27;name&#x27;, inplace=True) # 建立索引并生效 其中可选参数inplace&#x3D;True会将指定好索引的数据再赋值给titanic使索引生效，否则索引不会生效。注意，这里并没有修改原Excel，从我们读取数据后就已经和它没有关系了，我们处理的是内存中的titanic变量。 将name建立索引后，就没有从0开始的数字索引了，如图 12# 用指定索引选取titanic[titanic.index == &#x27;Liver&#x27;] # 指定姓名 排序Pandas的排序非常方便，示例如下： 1234titanic.sort_values(by=&#x27;Q1&#x27;) # 按Q1列数据升序排列titanic.sort_values(by=&#x27;Q1&#x27;, ascending=False) # 降序titanic.sort_values([&#x27;team&#x27;, &#x27;Q1&#x27;], ascending=[True, False]) # team升序，Q1降序 知乎参考链接","categories":[{"name":"pandas","slug":"pandas","permalink":"http://breadwinners.top/categories/pandas/"}],"tags":[{"name":"titanic","slug":"titanic","permalink":"http://breadwinners.top/tags/titanic/"}]},{"title":"Python之Shape()函数","slug":"pytorch/Python之Shape()函数","date":"2023-07-10T16:00:00.000Z","updated":"2023-07-15T12:47:07.008Z","comments":true,"path":"2023/07/11/pytorch/Python之Shape()函数/","link":"","permalink":"http://breadwinners.top/2023/07/11/pytorch/Python%E4%B9%8BShape()%E5%87%BD%E6%95%B0/","excerpt":"","text":"shape函数是numpy.core.fromnumeric中的函数，它的功能是读取矩阵的长度，比如shape[0]就是读取矩阵第一维度的长度。 shape的输入参数可以是一个整数（表示维度），也可以是一个矩阵。以下例子可能会好理解一些： （1）参数是一个数时，返回空： （2）参数是一维矩阵： （3）参数是二维矩阵： 以上分别为两行一列；三行两列 （4）直接用.shape可以快速读取矩阵的形状，使用shape[0]读取矩阵第一维度的长度 （5）但是当某一维度长度不一致时，读取所有维度时则不能读出长短不一致的维度 原文：https://blog.csdn.net/qq\\_28618765/article/details/78081959","categories":[{"name":"Python","slug":"Python","permalink":"http://breadwinners.top/categories/Python/"}],"tags":[{"name":"shape()","slug":"shape","permalink":"http://breadwinners.top/tags/shape/"}]},{"title":"frp开机自启动","slug":"小技巧/frp开机自启动","date":"2023-06-05T16:00:00.000Z","updated":"2023-07-18T07:10:39.286Z","comments":true,"path":"2023/06/06/小技巧/frp开机自启动/","link":"","permalink":"http://breadwinners.top/2023/06/06/%E5%B0%8F%E6%8A%80%E5%B7%A7/frp%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/","excerpt":"","text":"在Windows任务计划程序进行设置 打开任务计划程序 打开开始菜单，输入 “任务计划程序” 将会自动搜索，接着打开它。 创建计划任务 2.1 点击右侧的 “创建任务”，名称随意填写，安全选项选择 “不管用户是否登录都要运行”，当然你也可以选择 “只在用户登录时运行”。 2.2【常规】选项卡设置 选择 “不管用户是否登录都要运行” 可以让你的电脑在断电自动启动后自动运行 frp，你就可以远程桌面连接电脑了。 “使用最高权限运行” 也是可选的，根据个人需要可以选上。 最后勾选 “隐藏”，就不会在启动时弹出命令行窗口了。 2.3 【触发器】选项卡设置 页，点击新建，选择 “启动时” 2.4 接着转到 【操作】选项卡 点击新建，选择 “启动程序” 在程序或脚本一栏选择第一步创建的 start.bat，下面的 “起始于” 填写 start.bat 的路径（不要包含 start.bat） 例如你的 start.bat 在 E:frpstart.bat，那么你只需要在 “起始于” 填写 E:frp 接着返回 “常规” 页，点击确定，此时会要求输入密码，输入你的电脑密码，然后点击确定即可。 以后就会开机自动启动 frp 了，并且不会弹出命令提示符窗口~ 到此为止。 参考文章","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://breadwinners.top/tags/frp/"}]},{"title":"maven带依赖打包","slug":"maven带依赖打包","date":"2023-05-31T16:00:00.000Z","updated":"2023-06-12T01:59:20.628Z","comments":true,"path":"2023/06/01/maven带依赖打包/","link":"","permalink":"http://breadwinners.top/2023/06/01/maven%E5%B8%A6%E4%BE%9D%E8%B5%96%E6%89%93%E5%8C%85/","excerpt":"","text":"当你需要在某个环境下使用 java -jar xxx.jar的命令运行jar包程序，而且该jar包又需要引用其他程序依赖的时候，就可以采用以下的方法。 添加依赖 12345678910111213141516171819&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.xxx.xxx.xxx&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 运行生成的带依赖的jar就行了 java -jar ...","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://breadwinners.top/tags/maven/"},{"name":"打包依赖","slug":"打包依赖","permalink":"http://breadwinners.top/tags/%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/"}]},{"title":"windows安装WSL","slug":"WSL2","date":"2023-05-27T16:00:00.000Z","updated":"2023-07-11T02:19:39.651Z","comments":true,"path":"2023/05/28/WSL2/","link":"","permalink":"http://breadwinners.top/2023/05/28/WSL2/","excerpt":"","text":"Windows下安装wsl 开启系统的一下设置 虚拟化设置 系统设置 ​ 控制面板-&gt;程序-&gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)以及Hyper-V ​ 勾选完成后，Windows11 会自己下载些东西，并提示你重启。等电脑彻底重启完以后，进行后续操作 打开Power Shell 以管理员身份输入下方代码： bcdedit /set hypervisorlaunchtype auto 安装Ubuntu ​ 微软商店太慢了，这里推荐另一种好方法 ​ 1. 打开Microsoft Store的网页版https://apps.microsoft.com/store/apps ​ 搜索你想要的应用，比如ubuntu 选择一个 复制链接 打开网站https://store.rg-adguard.net，专门下载Microsoft Store上的应用 输入你刚才复制的要下载的应用链接，搜索 在结果里面找到想要的应用，有些文件的名称里面会有平台，比如x64，x86，arm64等等，根据自己电脑的平台下载，注意选择后缀为.appx或者.AppxBundle的下载，.EAppxBundle只适用于Windows Xbox平台。 等待下载完成后 下载完之后进入你的下载目录，运行命令： 1Add-AppxPackage .\\CanonicalGroupLimited.Ubuntu22.04LTS_2204.2.47.0_neutral_~_79rhkp1fndgsc.AppxBundle PS：Add-AppxPackage是power shell命令，在cmd中必须线输入powershell才能继续运行 启动Ubuntu ​ 直接点击ubuntu图标启动 ​ PS：Windows11 WSL 打开Ubuntu 报错 WslRegisterDistribution failed with error: 0x800701bc 这个是需要下载适用于 x64 计算机的 WSL2 Linux 内核更新包： https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 安装升级后，重新打开 Ubuntu，即可正常访问，效果如下： 修改root用户密码 WSL 默认是没有设置 root 密码的 设置 root 用户密码, 这样要输三次命令, 第一次当前用户密码, 后两次就是设置密码以及确认密码 1sudo passwd root 设置默认用户 查看命令 1ubuntu2204 /? 2. 设置默认登录用户 1ubuntu2204 config --default-user root 重新启动查看结果 ![image-20230602125308631](https://tt-1316429231.cos.ap-nanjing.myqcloud.com/imgs/linux/202306021253674.png)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://breadwinners.top/tags/wsl/"},{"name":"wsl2","slug":"wsl2","permalink":"http://breadwinners.top/tags/wsl2/"}]},{"title":"flume 运行时报NoSuchMethodError com.google.common.base.Preconditions.checkArgument","slug":"flume 运行时报NoSuchMethodError","date":"2023-05-25T16:00:00.000Z","updated":"2023-06-28T14:55:13.349Z","comments":true,"path":"2023/05/26/flume 运行时报NoSuchMethodError/","link":"","permalink":"http://breadwinners.top/2023/05/26/flume%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8A%A5NoSuchMethodError/","excerpt":"","text":"1、遇到问题今天在配置好flume，在运行flume时报了以下错误。 12023-05-26 16:39:56,359 (SinkRunner-PollingRunner-DefaultSinkProcessor) [ERROR - org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:459)] process failedjava.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.conf.Configuration.setBoolean(Configuration.java:1679) at org.apache.flume.sink.hdfs.BucketWriter.open(BucketWriter.java:221) at org.apache.flume.sink.hdfs.BucketWriter.append(BucketWriter.java:572) at org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:412) at org.apache.flume.sink.DefaultSinkProcessor.process(DefaultSinkProcessor.java:67) at org.apache.flume.SinkRunner$PollingRunner.run(SinkRunner.java:145) at java.lang.Thread.run(Thread.java:748)Exception in thread &quot;SinkRunner-PollingRunner-DefaultSinkProcessor&quot; java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.conf.Configuration.setBoolean(Configuration.java:1679) at org.apache.flume.sink.hdfs.BucketWriter.open(BucketWriter.java:221) at org.apache.flume.sink.hdfs.BucketWriter.append(BucketWriter.java:572) at org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:412) at org.apache.flume.sink.DefaultSinkProcessor.process(DefaultSinkProcessor.java:67) at org.apache.flume.SinkRunner$PollingRunner.run(SinkRunner.java:145) at java.lang.Thread.run(Thread.java:748) 2、解决问题 遇到这种问题，无非两种情况，一是 丢失jar包，二是 jar包冲突。 由于对hadoop以及flume版本选择比较随意。猜测是jar包存在冲突。找到报错的类 com.google.common.base.Preconditions ，通过查询 该类存在 guava jar包中。flume的lib中 &#x2F;opt&#x2F;flume&#x2F;apache-flume-1.9.0-bin&#x2F;lib （guava-11.0.2.jar）而 hadoop 的 lib 中 &#x2F;opt&#x2F;hadoop&#x2F;hadoop-3.2.1&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib&#x2F; （guava-27.0-jre.jar），删除版本低的，并拷贝高版本的。 问题解决。 Google Guava","categories":[{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"flume","slug":"flume","permalink":"http://breadwinners.top/tags/flume/"}]},{"title":"Spark安装部署","slug":"Spark安装部署","date":"2023-05-24T16:00:00.000Z","updated":"2023-06-01T07:08:13.866Z","comments":true,"path":"2023/05/25/Spark安装部署/","link":"","permalink":"http://breadwinners.top/2023/05/25/Spark%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"1.安装Spark将文件上传到&#x2F;opt&#x2F;module&#x2F;，解压并重命名 123wget https://archive.apache.org/dist/spark/spark-3.0.0/spark-3.0.0-bin-hadoop3.2.tgztar -zxvf spark-3.0.0-bin-hadoop3.2.tgzmv spark-3.0.0-bin-hadoop3.2 spark-3.0.0 2.编辑slaves和spark-env.sh文件123cd /opt/module/spark-3.0.0/conf/mv slaves.template slavesmv spark-env.sh.template spark-env.sh 1vi slaves 在文件中添加集群的主机名称 123hadoop102hadoop103hadoop104 1vi spark-env.sh 12导入java地址export JAVA_HOME=/home/jdk1.8.0_77 添加环境变量 1vi /etc/profile 12export SPARK_HOME=/opt/module/spark-3.0.0export PATH=$PATH:$SPARK_HOME/sbin:$SPARK_HOME/bin 每台虚拟机都需要配置 3.分发Spark1xsync /opt/module/spark-3.0.0 4.启动Spark启动spark前需先启动hadoop集群 123cd /opt/module/spark-3.0.0/sbin/start-all.sh jpsall 查看各节点进程：主节点:从节点：浏览器访问web页面：主机名:8080 ok!!","categories":[{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://breadwinners.top/tags/spark/"}]},{"title":"Spark安装sbt","slug":"spark安装sbt","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-31T11:32:43.087Z","comments":true,"path":"2023/05/25/spark安装sbt/","link":"","permalink":"http://breadwinners.top/2023/05/25/spark%E5%AE%89%E8%A3%85sbt/","excerpt":"","text":"Spark中没有自带sbt，需要[手动安装sbt，我的方法是下载sbt-launch.jar，然后将源改为国内源（aliyun），我选择将sbt安装在&#x2F;usr&#x2F;local&#x2F;sbt中。1234sudo mkdir /usr/local/sbtsudo chown -R hadoop /usr/local/sbt #username is hadoop.cd /usr/local/sbtmkdir sbtlaunch #store sbt-launch.jar 1.下载sbt-launch.jar,并存放至&#x2F;usr&#x2F;local&#x2F;sbt&#x2F;sbtlaunch123cd /usr/local/sbt/sbtlaunchwget https://repo.typesafe.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.13.9/sbt-launch.jar -O ./sbt-launch.jar #download sbt-launch.jarunzip -q ./sbt-launch.jar #解压 2.需要修改其中的.&#x2F;sbt&#x2F;sbt.boot.properties文件,将[repositories]处修改为如下内容：即增加一条aliyun-nexus的镜像。12cd /usr/local/sbt/sbtlaunchvim ./sbt/sbt.boot.properties 修改为如下123456[repositories] local aliyun-nexus: http://maven.aliyun.com/nexus/content/groups/public/ jcenter: https://jcenter.bintray.com/ typesafe-ivy-releases: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly maven-central 3.删除原来的sbt-launch.文件，然后重新打包12rm ./sbt-launch.jar #delete the old jarjar -cfM ./sbt-launch.jar . #create new jar 4.在&#x2F;usr&#x2F;local&#x2F;sbt目录下创建sbt脚本文件并赋予可执行权限，来执行sbt-launch.jar12cd /usr/lcoal/sbtvim ./sbt #create sbt script 添加如下内容:12SBT_OPTS=&quot;-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M&quot;java $SBT_OPTS -jar `dirname`/sbt-launch.jar &quot;$@&quot; #dirname为路径名 my dirname ： &#x2F;usr&#x2F;local&#x2F;sbt&#x2F;sbtlaunch5.保存后，为.&#x2F;sbt增加可执行权限:1chmod u+x ./sbt 6.最后检验sbt是否可用1./sbt sbt-version 这一步请耐心等待 参考链接：https://blog.csdn.net/microsoft2014/article/details/54572502","categories":[{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://breadwinners.top/tags/spark/"},{"name":"sbt","slug":"sbt","permalink":"http://breadwinners.top/tags/sbt/"}]},{"title":"Linux中的各种bin目录","slug":"Linux/Linux中的各种bin目录","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-31T11:16:43.747Z","comments":true,"path":"2023/05/25/Linux/Linux中的各种bin目录/","link":"","permalink":"http://breadwinners.top/2023/05/25/Linux/Linux%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Dbin%E7%9B%AE%E5%BD%95/","excerpt":"","text":"usr实际上是Unix System Resource /usr/bin系统预装的一些可执行程序，随系统升级会改变 /usr/local/bin用户安装的可执行程序，不受系统升级影响，用户编译安装软件时，一般放到&#x2F;usr&#x2F;local目录下 如果两个目录下有相同的可执行程序，谁优先执行会受到PATH环境变量的影响，举个栗子：echo $PATH查看当前 PATH 环境变量/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/.local/bin:/root/bin:/usr/local/src/nodejs/bin:/usr/local/git/bin:/usr/bin/git/bin这里/usr/local/git/bin优先于 /usr/bin/git/bin /bin 存放所有用户皆可用的系统程序，系统启动或者系统修复时可用（在没有挂载 &#x2F;usr 目录时就可以使用） /sbin 存放超级用户才能使用的系统程序 /usr/bin 存放所有用户都可用的应用程序 /usr/sbin 存放超级用户才能使用的应用程序 /usr/local/bin 存放所有用户都可用的与本地机器无关的程序 /usr/local/sbin 存放超级用户才能使用的与本地机器无关的程序 Linux中的某些重要的目录： •主目录：/root、/home/username •用户可执行文件：/bin、/usr/bin、/usr/local/bin •系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin •其他挂载点：/media、/mnt •配置：/etc •临时文件：/tmp •内核和Bootloader：/boot •服务器数据：/var、/srv •系统信息：/proc、/sys •共享库：/lib、/usr/lib、/usr/local/lib","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"bin目录","slug":"bin目录","permalink":"http://breadwinners.top/tags/bin%E7%9B%AE%E5%BD%95/"}]},{"title":".bashrc和profile和profile.d与配置环境变量","slug":"Linux/profile和.bashrc和profile.d","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-31T10:56:30.566Z","comments":true,"path":"2023/05/25/Linux/profile和.bashrc和profile.d/","link":"","permalink":"http://breadwinners.top/2023/05/25/Linux/profile%E5%92%8C.bashrc%E5%92%8Cprofile.d/","excerpt":"","text":".bashrc 文件详解位置： 系统级的位于/etc/bashrc，对所有用户生效。 用户级的位于~/.bashrc或者/home/用户名/.bashrc，仅对当前用户生效。 作用： bash 提示符允许你自定义你的终端，并让它在你运行命令时显示提示。自定义的 bash 提示符着实能提高你在终端的工作效率。 给命令起别名： 1alias catt=&quot;cat -n&quot; 使多个命令可以组合使用 1234md () &#123;mkdir -p $1cd $1&#125; 变动 bashrc 是非常直接且低风险的。即使你一不小心全搞砸了，你也可以随时删掉 bashrc 文件然后重新来一遍。 profile位置： 系统级的位于/etc/profile，用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。 用户级的位于~/.bash_profile，用于设置用户级的环境变量和启动程序，在这个文件下配置会对单个用户生效。 当用户登录（login）时，文件会被执行，并从/etc/profile.d目录的配置文件中查找shell设置。 在profile中设置环境变量一般不建议在**/etc/profile**文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。 一般在/etc/profile.d中添加环境变量 /etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用像/etc/profile需要改动此文件 当添加环境变量时，我们可以按以下方式添加： 1234567891011下面以jdk的安装为例vim /etc/profile.d/java.sh在新的java.sh中输入以下内容：#set java environmentJAVA_HOME=/opt/module/jdk1.8.0_212PATH=＄JAVA_HOME/bin:＄PATHexport JAVA_HOME PATH 12345#JAVA_HOME是一个环境变量，用于指定Java的安装目录export JAVA_HOME=/opt/module/jdk1.8.0_212是一个命令，用于设置JAVA_HOME的值为/opt/module/jdk1.8.0_212，也就是Java的安装目录export PATH=$PATH:$JAVA_HOME/bin是一个命令，用于将$JAVA_HOME/bin添加到PATH环境变量中，这样就可以在任何目录下执行Java的可执行程序，如java和javac 添加时，可以在行尾使用;号，也可以不使用。 一个变量名可以对应多个变量值，多个变量值需要使用:进行分隔。 添加环境变量后，需要重新登录才能生效，也可以使用 source 命令刷新立即生效： 1source /etc/profile 查看是否生效可以使用 echo 命令： 12echo $JAVA_HOME/opt/module/jdk1.8.0_212 差异/etc/profile，/etc/bashrc 是系统全局环境变量设定； ~/.profile，~/.bashrc用户家目录下的私有环境变量设定。 当登入系统时候获得一个 shell 进程时，其读取环境设定档如下： 首先读入全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如/etc/profile.d和/etc/inputrc； 根据不同使用者帐号，于其家目录内读取~/.bash_profile； 读取失败则会读取~/.bash_login； 再次失败则读取~/.profile（这三个文档设定基本上无差别，仅读取上有优先关系）； 最后，根据用户帐号读取~/.bashrc。 至于~/.profile与~/.bashrc都具有个性化定制功能，但~/.profile可以设定本用户专有的路径、环境变量等，它只能登入的时候执行一次。 ~/.bashrc也是某用户专有设定文档，可以设定路径、命令别名，每次 shell script 的执行都会使用它一次。 设置程序为任意目录可以执行 可以像上文配置java环境变量一样配置 在/usr/bin或者~/bin目录下写shell脚本，指向需要执行的文件 记得source","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":".bashrc","slug":"bashrc","permalink":"http://breadwinners.top/tags/bashrc/"}]},{"title":"CentOs7安装Redis","slug":"Linux/linux安装redis","date":"2023-05-22T16:00:00.000Z","updated":"2023-05-23T14:30:39.812Z","comments":true,"path":"2023/05/23/Linux/linux安装redis/","link":"","permalink":"http://breadwinners.top/2023/05/23/Linux/linux%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"前提条件：Linux装有gcc编译器 ###1. 官网下载redis 1wget http://download.redis.io/releases/redis-5.0.14.tar.gz 2. 安装解压： 123tar -xzvf redis-5.0.14.tar.gzcd redis-5.0.14make PREFIX=/usr/local/redis install //安装 3.使用12redis-server // 启动redis-cli // 连接 输入ping 输出为： 代表安装成功 4.Java远程连接使用需要关闭redis的防远程连接，否则会报错redis运行在protected模式下 找到redis.conf文件 ​ 找到bind 127.0.0.1，注释掉 连接上redis后，输入config get daemonize和config get protected-mode 都修改为no 12config set daemonize noconfig set protected-mode no 在pom文件中添加redis的相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 实验操作部分： 123456789101112131415161718package redis;import java.util.Map;import redis.clients.jedis.Jedis;public class Redis1 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;hadoop102&quot;, 6379); jedis.hset(&quot;student.scofield&quot;, &quot;English&quot;, &quot;45&quot;); jedis.hset(&quot;student.scofield&quot;, &quot;Math&quot;, &quot;89&quot;); jedis.hset(&quot;student.scofield&quot;, &quot;Computer&quot;, &quot;100&quot;); Map&lt;String, String&gt; value = jedis.hgetAll(&quot;student.scofield&quot;); for (Map.Entry&lt;String, String&gt; entry : value.entrySet()) &#123; System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); &#125; &#125;&#125; 12345678910111213package redis;import redis.clients.jedis.Jedis;public class Redis2 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;hadoop102&quot;, 6379); String value = jedis.hget(&quot;student.scofield&quot;, &quot;English&quot;); System.out.println(&quot;scofield&#x27;s English score is: &quot; + value); &#125;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://breadwinners.top/tags/redis/"}]},{"title":"centos设置静态IP","slug":"Linux/centos设定静态IP","date":"2023-05-15T16:00:00.000Z","updated":"2023-06-23T08:24:07.367Z","comments":true,"path":"2023/05/16/Linux/centos设定静态IP/","link":"","permalink":"http://breadwinners.top/2023/05/16/Linux/centos%E8%AE%BE%E5%AE%9A%E9%9D%99%E6%80%81IP/","excerpt":"","text":"配置网卡 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 根据情况输入以下内容 123456789101112131415161718192021TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;46cddd88-b100-416c-ab9c-5c19f1e3a7ef&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=192.168.153.102GATEWAY=192.168.153.2DNS1=114.114.114.114NETMASK=255.255.255.0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"静态ip","slug":"静态ip","permalink":"http://breadwinners.top/tags/%E9%9D%99%E6%80%81ip/"}]},{"title":"typora+picgo上传图片报错","slug":"typora+picgo图床","date":"2023-05-09T16:00:00.000Z","updated":"2023-05-22T11:42:43.017Z","comments":true,"path":"2023/05/10/typora+picgo图床/","link":"","permalink":"http://breadwinners.top/2023/05/10/typora+picgo%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"error1&quot;success&quot;.false, &quot;message&quot;.&quot;upload error. see C.Users\\lAdministratorlAppDatallRoamingllpicgollpicgo.log for more picgo日志： 1234567891011------Error Stack Begin------Error: read file E:\\Boke\\source\\_posts\\C:\\Users\\wutao\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230521041042868.png error at D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:38189 at async Promise.all (index 0) at async Object.handle (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:37138) at async $e.doTransform (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:16679) at async $e.start (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:15916) at async Tt.upload (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:71270) at async Object.upload (D:\\application\\tools\\PicGo\\resources\\app.asar\\background.js:2:653584) at async jn (D:\\application\\tools\\PicGo\\resources\\app.asar\\background.js:2:656251) at async D:\\application\\tools\\PicGo\\resources\\app.asar\\background.js:2:657340 解决办法： 直接在hexo的_post文件夹中写markdown会传不上去图片，但是在外面写可以正常上传图片，所以可以在外面写好了在放信hexo中","categories":[{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/categories/bugs/"}],"tags":[{"name":"picgo","slug":"picgo","permalink":"http://breadwinners.top/tags/picgo/"}]},{"title":"nginx绑定子域名","slug":"Linux/nginx绑定子域名","date":"2023-05-04T16:00:00.000Z","updated":"2023-05-22T13:01:22.125Z","comments":true,"path":"2023/05/05/Linux/nginx绑定子域名/","link":"","permalink":"http://breadwinners.top/2023/05/05/Linux/nginx%E7%BB%91%E5%AE%9A%E5%AD%90%E5%9F%9F%E5%90%8D/","excerpt":"","text":"检查 nginx 配置文件路径（重要）注意：这一步非常关键，如果修改了错误的 nginx 配置文件，将导致所有修改均无效，甚至会让您在探索了数个小时后仍无法得知修改无效的原因是什么。 使用命令 1$ nginx -V 来查看 nginx 的一些配置信息，如下（您的和博主的显示内容可能不同，不影响）： 12345nginx version: nginx/1.12.2built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_auth_request_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27; 其中只需要关注到 --conf-path=/etc/nginx/nginx.conf 这个条目，这个条目指明了当前 nginx 的程序使用的默认配置文件。 新建一个站点配置文件根据上面的配置文件路径，首先切换目录到 nginx 的配置路径下： 1$ cd /etc/nginx 然后新建一个站点配置文件，建议放置在 nginx 配置目录下的 vhost 目录内，如果您当前没有此目录，可新建一个： 12345678$ pwd/etc/nginx$ sudo mkdir vhost$ lsconf.d fastcgi_params mime.types scgi_params vhostdefault.d fastcgi_params.default mime.types.default scgi_params.default win-utffastcgi.conf koi-utf nginx.conf uwsgi_paramsfastcgi.conf.default koi-win nginx.conf.default uwsgi_params.default 注意：/etc 是系统目录，一般用户不具有修改权限，需要使用 sudo 以管理员权限在该目录中进行修改，如创建、修改文件，创建文件夹等操作。 进入刚刚创建的 vhost 目录，新建一个配置文件，例如 mysite.conf，该配置文件文件名无限制，最好是你的网站名称之类的，便于辨认，但一定是以 .conf 为后缀。 12345678$ pwd/etc/nginx$ cd vhost/$ pwd/etc/nginx/vhost$ sudo touch mysite.conf$ lsmysite.conf trans.conf 其中，touch 命令创建了一个名为 mysite.conf 的配置文件（空文件），是本文中要介绍的配置文件，另一个是博主正在运行的网站，无需在意。 修改网站配置文件信息本文中将建立一个名为 mysite 的网站，网站根目录为 /home/www/mysite，网站绑定域名 mysite.jinhangdev.cn。 使用任意文字编辑器打开 mysite.conf，输入如下内容并保存（注意需管理员权限）： 1234567server &#123; listen 80; # 网站的端口一般为 80，可以与其他网站一起使用该端口 server_name mysite.jinhangdev.cn; # 要绑定的域名（或子域名） root /home/www/mysite; # 该网站的根目录 location / &#123; # 不用管 &#125;&#125; 以上内容为一个 server 的内容，下面讲 nginx.conf 配置的时候会再区分把一行配置写在 server 或写在 server 外的区别。 12345678910111213$ pwd/etc/nginx/vhost$ lsmysite.conf trans.conf$ sudo vim mysite.conf$ cat mysite.confserver &#123; listen 80; server_name mysite.jinhangdev.cn; root /home/www/mysite; location /&#123; &#125;&#125; 上面我们已经新建好了一个网站，该网站使用服务器的 80 端口，绑定的域名为 mysite.jinhangdev.cn，网站根目录使用 /home/www/mysite。 修改 nginx 配置文件下面对关键文件 nginx.conf 进行配置，建议在修改前先备份，养成好的习惯： 123$ pwd/etc/nginx$ sudo cp nginx.conf nginx.conf.bak 将原有配置存储到 nginx.conf.bak 后，继续下面操作，若后面发现修改出错，可将 nginx.conf.bak 改名回 nginx.conf 使用。 以超级用户权限使用文本编辑器打开 nginx.conf： 1$ sudo vim nginx.conf 并进行编辑。 Nginx 配置文件的结构我们这里只介绍和配置域名绑定相关的部分结构，即 http 小节： 123http &#123; （各种配置）&#125; 设置在此处的配置都是 http 的全局配置，如果要对某个网站单独配置，则需要对每个 server 分别设置： 12345678910http &#123; (此处的配置是全局的配置参数) server &#123; (此处的配置是本 server 的配置参数) &#125; server &#123; (此处的配置是本 server 的配置参数) &#125; (此处的配置是全局的配置参数)&#125; 但是我们并不提倡把所有 server 都展开写在 nginx.conf 中，因此我们使用一句 include 语句，把 vhost 下所有网站的配置都引用进来。注意：include 命令只是简单地进行文本替换。 于是我们在 nginx.conf 的 http 节内部的末尾写上一句： 1234http &#123; （前面的若干配置） include /etc/nginx/vhost/*.conf;&#125; 这样一来，vhost 下的所有 .conf 文件均被文本替换式地引入到 nginx.conf 里面了。 重启 nginx 服务","categories":[{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://breadwinners.top/tags/nginx/"}]},{"title":"李沐说读论文","slug":"李沐读论文","date":"2023-05-02T16:00:00.000Z","updated":"2023-05-02T16:18:51.776Z","comments":true,"path":"2023/05/03/李沐读论文/","link":"","permalink":"http://breadwinners.top/2023/05/03/%E6%9D%8E%E6%B2%90%E8%AF%BB%E8%AE%BA%E6%96%87/","excerpt":"","text":"title abstract introduction method experiments conclusion 第一遍：标题、摘要、结论。可以看一看方法和实验部分重要的图和表。这样可以花费十几分钟时间了解到论文是否适合你的研究方向。第二遍：确定论文值得读之后，可以快速的把整个论文过一遍，不需要知道所有的细节，需要了解重要的图和表，知道每一个部分在干什么，圈出相关文献。觉得文章太难，可以读引用的文献。第三遍：提出什么问题，用什么方法来解决这个问题。实验是怎么做的。合上文章，回忆每一个部分在讲什么。","categories":[{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/"},{"name":"算法","slug":"论文/算法","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"部署hexo到CentOs7","slug":"部署hexo到centos","date":"2023-05-02T16:00:00.000Z","updated":"2023-05-22T12:00:55.155Z","comments":true,"path":"2023/05/03/部署hexo到centos/","link":"","permalink":"http://breadwinners.top/2023/05/03/%E9%83%A8%E7%BD%B2hexo%E5%88%B0centos/","excerpt":"","text":"git 安装 1yum install git 测试 1git --version 输出类似下面的结果则表示安装成功 1git version 1.8.3.1 创建 git 用户 1adduser git 建立裸仓 12345su gitcd /home/git # 进入 git 用户目录mkdir blog &amp;&amp; chown -R git:git &amp;&amp; cd git# 创建博客文件夹，，设置权限,作为 nginx web 目录mkdir projects &amp;&amp; chown -R git:git &amp;&amp; cd project # 创建项目目录，设置权限并进入git init --bare hexo.git &amp;&amp; chown -R git:git # 创建博客裸仓，设置权限 添加 SSH Key，通过 ssh 链接仓库 12cd /home/git # 回到 git 用户目录mkdir .ssh # 存放 ssh key 在本地机器（写博客的电脑）上创建的 ssh 公钥（已有请忽略） 1ssh-keygen -o -t rsa -b 4096 -C &quot;email@example.com&quot; # 替换邮箱 复制公钥 1pbcopy &lt; ~/.ssh/id_rsa.pub 在远程服务器，使用 vim 编辑文件，vim 用法请参考： 1vi /home/git/.ssh/authorized_keys 按 i 进入编辑模式，粘贴公钥，按 esc，输入 :wq 保存并退出。 hexo 配置发布选项 修改 _config.yml （本级 hexo 配置文件） 1234deploy: type: git repo: git@ip:/home/git/projects/hexo.git # ip 为服务器ip branch: master 自动部署（服务器） 123cd /home/git/projects/hexo.git/hooks # 进入 hook 目录mv post-update.sample post-update # 重命名 post-updatevi post-update # vim 进行编辑 按 i 进入编辑模式，在最后一行上面粘贴下面文字，按 esc，输入 :wq 保存并退出。 1git --work-tree=/home/git/blog --git-dir=/home/git/projects/hexo.git checkout -f 在本地 hexo 目录执行发布命令 1hexo g -d 查看服务器 blog 目录中是否有文件，如果没有请检查步骤是否错误。 源代码存放 在我们服务器上存放的是编译后的文件，源文件我建议存放在 github 私有仓库。 nginx以 centos 为例： 安装 1yum install -y nginx 启动 1service nginx start 测试 1wget http://127.0.0.1 可以正常下载 index.html 文件则说明启动成功。 配置 1vi /etc/nginx/nginx.conf 把 user nginx 修改为user root， server 按照修改两处配置： 1234root /home/git/blog;location / &#123; index index.html;&#125; 重启 nginx 1service nginx restart 在浏览器键入你的服务器 ip 地址或域名，即可正常访问。 https使用 certbot 自动获取证书，参考 https://certbot.eff.org/ 安装 Certbot 1sudo yum install certbot python2-certbot-nginx 获取证书并自动配置 1sudo certbot --nginx 按照提示输入即可 自动续签 1echo &quot;0 0,12 * * * root python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; certbot renew -q&quot; | sudo tee -a /etc/crontab &gt; /dev/null 结束","categories":[],"tags":[]},{"title":"centos7安装Mysql初始密码问题","slug":"Linux/centos7安装Mysql初始密码问题","date":"2023-05-02T16:00:00.000Z","updated":"2023-05-20T21:13:30.249Z","comments":true,"path":"2023/05/03/Linux/centos7安装Mysql初始密码问题/","link":"","permalink":"http://breadwinners.top/2023/05/03/Linux/centos7%E5%AE%89%E8%A3%85Mysql%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"一般来说，centos7暗转MySQL，可以直接使用yum -y install mysql来实现，但是突然碰到了不知道初始root密码的问题，记录一下解决过程 网上都会说grep ‘temporary password’ /var/log/mysqld.log就可以查看临时密码，但是系统却说 No such file of directory 解决方法 查看是否安装了mysql服务（有则自行卸载删除）。 12yum list installed mysql* rpm –qa|grep mysql* 查看服务器上是否有现成的安装包。 1yum list mysql* 去mysql官网的yum资源库找到对应的rpm文件的下载链接 在linux中下载、安装yum资源。 1rpm -ivh 资源下载链接(https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm) 查看当前mysql的当前版本 1yum info mysql-community-server 安装mysql 1yum -y install mysql-community-server 注：如果出现 原因是Mysql的GPG升级了，需要重新获取 1rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 MySQL安装完成如下： 安装完成后，启动MySQL 12systemctl start mysqldsystemctl status mysqld // 检查MySQL状态 查询mysql初始密码 1grep ‘temporary password’ /var/log/mysqld.log 修改密码 1mysqladmin -u root -p password Access denied for user ‘root‘@’localhost’ (using password: YES)报错 1、关闭mysql服务 service mysqld stop 2、找到&#x2F;etc&#x2F;my.cnf ,在最后一行添加skip-grant-tables（用于免密码登录） vim &#x2F;etc&#x2F;my.cnf 3、重启mysql服务 service mysqld start 4、正常登录mysql（不使用密码） mysql -u root 123456789mysql&gt; show databases;mysql&gt; use mysql;mysql&gt; ALTER USER &#x27;用户名&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;mysql&gt; flush privileges; --刷新MySQL的系统权限相关表mysql&gt; exit; 5、找到&#x2F;etc&#x2F;my.cnf ,删除skip-grant-table6、重启mysql服务service mysqld restart7、正常登录测试mysql -u root -p 就可以了 备注：root账号一般只添加了localhost访问(这是推荐的)，如若调试阶段不想通过ssh跳板连接，建议开个新账号。 步骤1：查看root账号的ip访问权限（执行结果：localhost和127.0.0.1，是无法从外部连接的） 1select user,host,plugin from user; 1SELECT host FROM mysql.user WHERE User = &#x27;root&#x27;; 步骤2：新建账号并指定密码和ip（使用 % 通配符表示允许任何ip访问） 1CREATE USER &#x27;my_name&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;my_password&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;my_name&#x27;@&#x27;%&#x27;; 步骤3：刷新配置 1FLUSH PRIVILEGES; 这样my_name就可以不通过ssh跳板直接连接了。","categories":[{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/categories/bugs/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://breadwinners.top/tags/mysql/"}]},{"title":"解决切换用户出现bash-4.2$问题","slug":"Linux/解决Linux用户出现bash-4.2$问题","date":"2023-05-02T16:00:00.000Z","updated":"2023-06-13T15:32:49.979Z","comments":true,"path":"2023/05/03/Linux/解决Linux用户出现bash-4.2$问题/","link":"","permalink":"http://breadwinners.top/2023/05/03/Linux/%E8%A7%A3%E5%86%B3Linux%E7%94%A8%E6%88%B7%E5%87%BA%E7%8E%B0bash-4.2$%E9%97%AE%E9%A2%98/","excerpt":"","text":"##【问题描述】 linux中创建了一个xhh用户，然后使用su命令切换用户后，终端提示符显示成“bash-4.2$”而不是[root@localhost xhh]#，导致ll等命令无法执行。 123[root@localhost hadoop] # su hadoopbash-4.2$ llbash: ll: 未找到命令 【原因】没有在home目录下创建对应的目录导致。 【解决方法】使用root用户登录，再home目录中创建用户对应的文件夹，mkdir &#x2F;home&#x2F;user，这里的user是用户的名字，然后执行如下两个命令： 12cp /etc/skel/.bashrc /home/hadoopcp /etc/skel/.bash_profile /home/hadoop 执行成功后，再次使用su命令切换用户，发现一切正常。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"bash-4.2$","slug":"bash-4-2","permalink":"http://breadwinners.top/tags/bash-4-2/"}]},{"title":"标题模板","slug":"test","date":"2023-05-01T02:08:40.150Z","updated":"2023-05-02T16:18:26.746Z","comments":true,"path":"2023/05/01/test/","link":"","permalink":"http://breadwinners.top/2023/05/01/test/","excerpt":"","text":"1hexo g -d This is a video test post. Youtube Vimeo Headers1234567891011121314# H1## H2### H3#### H4##### H5###### H6Alternatively, for H1 and H2, an underline-ish style:Alt-H1======Alt-H2------ H1H2H3H4H5H6Alternatively, for H1 and H2, an underline-ish style: Alt-H1Alt-H2Emphasis","categories":[{"name":"分类","slug":"分类","permalink":"http://breadwinners.top/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签名","slug":"标签名","permalink":"http://breadwinners.top/tags/%E6%A0%87%E7%AD%BE%E5%90%8D/"}]},{"title":"数论","slug":"数论","date":"2023-04-25T16:00:00.000Z","updated":"2023-07-11T01:45:53.092Z","comments":true,"path":"2023/04/26/数论/","link":"","permalink":"http://breadwinners.top/2023/04/26/%E6%95%B0%E8%AE%BA/","excerpt":"","text":"p,q是正整数且互质，那么不能凑出的最大整数为(p - 1)(q - 1) - 1","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://breadwinners.top/tags/%E6%95%B0%E8%AE%BA/"},{"name":"不能凑出的最大整数","slug":"不能凑出的最大整数","permalink":"http://breadwinners.top/tags/%E4%B8%8D%E8%83%BD%E5%87%91%E5%87%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"}]},{"title":"DP动态规划问题","slug":"DP","date":"2023-04-24T16:00:00.000Z","updated":"2023-07-11T01:37:44.960Z","comments":true,"path":"2023/04/25/DP/","link":"","permalink":"http://breadwinners.top/2023/04/25/DP/","excerpt":"","text":"全新分析DP问题方式从集合角度来考虑DP问题：闫式思考法 依据最后一步来划分 从定义出发 ，分别求出集合左右两边的最大值 摘花生 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 105;int a[N][N], f[N][N];int T, R, C;int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; R &gt;&gt; C; for (int i = 1; i &lt;= R; i++) &#123; for (int j = 1; j &lt;= C; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; // f[i][j]指的是到(i, j)的最大花生数 for (int i = 1; i &lt;= R; i++) &#123; for (int j = 1; j &lt;= C; j++) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]) + a[i][j]; &#125; &#125; cout &lt;&lt; f[R][C] &lt;&lt; endl; &#125; return 0;&#125; 数塔问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 20;int n;int a[N][N], dp[N][N], step[N][N];void findRounte() &#123; for (int i = 1;i &lt;= n;i++) &#123; dp[n][i] = a[n][i]; &#125; for (int i = n - 1; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (dp[i + 1][j] &lt; dp[i + 1][j + 1]) &#123; step[i][j] = 0; dp[i][j] = a[i][j] + dp[i + 1][j]; &#125; else &#123; step[i][j] = 1; dp[i][j] = a[i][j] + dp[i + 1][j + 1]; &#125; &#125; &#125;&#125;void printRounte() &#123; cout &lt;&lt; &quot;最小数值为：&quot; &lt;&lt; dp[1][1] &lt;&lt; endl; int i, j = 1; for (i = 1; i &lt; n; i++) &#123; if (step[i][j] == 1) &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; -R-&gt; &quot;; j++; &#125; else &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; -L-&gt; &quot;; &#125; &#125; cout &lt;&lt; a[i][j];&#125;int main() &#123; // DP 数塔问题 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; findRounte(); printRounte(); return 0;&#125; ​ 从上往下DP1 背包问题物品条件： 1dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); 解释：在装入w[i]重量的物品后剩下的[j - w[i]]的空间能装的物品价值（可以查表得到）加上w[i]物品的价值v[i] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#include &lt;algorithm&gt;const int N = 100;int main() &#123; // dp背包 int n, bagV; // n = 4, bagV = 8; int w[N] = &#123;0&#125;; int v[N] = &#123;0&#125;; int dp[N][N] = &#123;&#123;0&#125;&#125;; cin &gt;&gt; n &gt;&gt; bagV; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= bagV; j++) &#123; if (j &lt; w[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; // 核心代码可以写成： /* dp[i][j] = dp[i - 1][j]; if (j &gt;= w[i]) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); */ // 动态规划表的输出 for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= bagV; j++) &#123; cout &lt;&lt; dp[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; puts(&quot;***************************&quot;); cout &lt;&lt; dp[n][bagV]; return 0;&#125; 完全背包问题&#x3D;&#x3D;每种物品可以选无限多件&#x3D;&#x3D; 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 1010;int f[N][N];int v[N],w[N];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1 ; i &lt;= n ;i ++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]; &#125; for(int i = 1 ; i&lt;=n ;i++) for(int j = 0 ; j&lt;=m ;j++) &#123; for(int k = 0 ; k*v[i]&lt;=j ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl;&#125; 多重背包问题有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 iii 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi,si≤100 输入样例 123454 51 2 32 4 13 4 34 5 2 输出样例： 110 &#x3D;&#x3D;可以取多件下&#x3D;&#x3D; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n,m;int v[N],w[N],s[N];int f[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i ++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; for(int i = 1;i &lt;= n;i ++)&#123; for(int j = 0;j &lt;= m;j ++)&#123; for(int k = 0;k &lt;= s[i];k ++)&#123; if(j &gt;= v[i] * k) f[i][j] = max(f[i][j],f[i - 1][j - k * v[i]] + w[i] * k); &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0;&#125; 分组背包问题1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int f[N][N]; // 只从前i组物品中选，当前体积小于等于j的最大值int v[N][N], w[N][N], s[N]; // v为体积，w为价值，s代表第i组物品的个数int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; for (int j = 0; j &lt; s[i]; j++) &#123; cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; // 读入 &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; // 枚举物品的种类 for (int j = 0; j &lt;= m; j++) &#123; // 枚举背包的容量 f[i][j] = f[i - 1][j]; // 不选 for (int k = 0; k &lt; s[i]; k++) &#123; if (j &gt;= v[i][k]) f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]); &#125; &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl;&#125; 矩阵连乘参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;/*自底向上的推出矩阵连乘的最优解先从两个矩阵相乘开始，而后三个矩阵相乘，四个......直到推出目标长度的最优解 ，即假设一个矩阵链，初始长度为2，算出所有相邻矩阵相乘的计算次数，而后使其长度为3...4...直到目标长度状态转移方程： m[i][j] = min&#123;m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]&#125; i&lt;=k&lt;j i&lt;j m[i][j] = 0 i == j;*/#define LEN 5 // 矩阵个数// 矩阵连乘函数，找到最优解void MatrixChain(int *p, int m[][LEN + 1], int s[][LEN + 1]) &#123; for (int i = 0; i &lt; LEN + 1; i++) m[i][i] = 0; // 初始化，对角线元素置零，即当矩阵链长度为1时（只有一个矩阵）不用乘，为零 for (int r = 2; r &lt;= LEN; r++) &#123; // r表示矩阵链的长度，从2开始,两个矩阵相乘，而后3...4...5... for (int i = 1; i &lt;= LEN - r + 1; i++) &#123; // i是矩阵链的首个矩阵，小于矩阵个数减矩阵链长度加一 int j = i + r - 1; // j是矩阵链的最后一个元素 m[i][j] = m[i][i] + m[i + 1][j] + p[i - 1] * p[i] * p[j]; // m[i][j]是子结构，从最左边开始推 s[i][j] = i; // 标记断开的位置 for (int k = i + 1; k &lt; j; k++) &#123; // k是i和j直接的断开点，是在i和j之间的子结构 ，通过k的循环找到最优的解 int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // 状态转移方程 if (t &lt; m[i][j]) &#123; m[i][j] = t; // 更新最优解 s[i][j] = k; // 更新断开点 &#125; &#125; &#125; &#125;&#125;// 回溯函数，根据s[i][j]数组标记的位置，回溯找到断开的位置void Traceback(int i, int j, int s[][LEN + 1]) &#123; if (i == j) &#123; // 当i与j相等 说明回溯到该矩阵的位置了 cout &lt;&lt; &quot;A&quot; &lt;&lt; i; &#125; else &#123; cout &lt;&lt; &quot;(&quot;; Traceback(i, s[i][j], s); // 从尾往头回溯 Traceback(s[i][j] + 1, j, s); // 从断点往后回溯 cout &lt;&lt; &quot;)&quot;; &#125;&#125;// 输出函数void output(int t[][LEN + 1]) &#123; for (int i = 1; i &lt;= LEN; i++) &#123; for (int j = 1; j &lt;= LEN; j++) &#123; // cout &lt;&lt; &quot; &quot; &lt;&lt; t[i][j] &lt;&lt; &quot; &quot;; printf(&quot;%6d&quot;, t[i][j]); &#125; cout &lt;&lt; endl; &#125;&#125;int main(void) &#123; int p[LEN + 1] = &#123;8, 6, 22, 3, 4, 10&#125;; // 矩阵的维度分别是2*3,3*4,4*5,5*6,6*7，LEN+1个数表示LEN个矩阵 int m[LEN + 1][LEN + 1] = &#123;0&#125;; // 记录最优子结构的二维数组 int s[LEN + 1][LEN + 1] = &#123;0&#125;; // 记录最优解对应的括号的位置 MatrixChain(p, m, s); cout &lt;&lt; endl; output(m); cout &lt;&lt; endl; output(s); cout &lt;&lt; endl; cout &lt;&lt; &quot;outcome:&quot; &lt;&lt; endl; Traceback(1, LEN, s); cout &lt;&lt; endl; return 0;&#125; 拔河问题题目：n 个人参加拔河比赛，每个人有自己的重量，现在需要把他们分成两组进行比赛，每个人属于其中的一个组。为使比赛公平，求使得两组重量差最小的分配。 这一题是一道二维费用的动态规划问题，我们可以这样转化这个问题：将n个物品放到一个容量为n&#x2F;2的背包，每个物品占一个空间，这个背包所能承受的重量是（所有物品总和）&#x2F;2 ，然后求这个背包最多能放多重的物品，这样就成功转化成一个背包问题了，状态转移方程为 1dp[i][j]=max(dp[i-1][j],dp[i-1][j-array[i]]+array[i]) 1234567891011121314151617181920212223// 看不懂的代码，一维dp数据解决了别人用二维dp数组的问题#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int w[10050], dp[10050];int main() &#123; int n, t; cin &gt;&gt; n; int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; sum += w[i]; &#125; t = sum / 2; for (int i = 1; i &lt;= n; i++) for (int j = t; j &gt;= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i]] + w[i]); cout &lt;&lt; dp[t] &lt;&lt; &quot; &quot; &lt;&lt; sum - dp[t] &lt;&lt; &quot;\\n&quot;; return 0;&#125; 最长上升子序列给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数 N。 第二行包含 N 个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 1≤N≤100−10^9^≤数列中的数≤10^9^ 输入样例： 1273 1 2 1 8 5 6 输出样例 14 1234567891011121314151617181920212223242526272829303132#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N], f[N];int main() &#123; // https://www.acwing.com/problem/content/897/ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; f[i] = 1; // 初始化，只有一个元素的时候，长度为1 for (int j = 0; j &lt; i; j++) &#123; if (a[i] &gt; a[j]) // 只有当后一个元素大于其前一个元素时，才需要求最长上升的子序列，否则不是上升子序列 f[i] = max(f[j] + 1, f[i]); &#125; &#125; int res = 0; for (int i = 1; i &lt;= n; i++) &#123; res = max(res, f[i]); &#125; cout &lt;&lt; res; return 0;&#125; 地宫取宝X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。 地宫的入口在左上角，出口在右下角。 小明被带到地宫的入口，国王要求他只能向右或向下行走。 走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。 当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。 请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。 输入格式 第一行 3 个整数，n,m,k含义见题目描述。 接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。 **** 输出格式 输出一个整数，表示正好取 k 个宝贝的行动方案数。 该数字可能很大，输出它对 1000000007取模的结果。 数据范围 1≤n,m≤501≤k≤120≤Ci≤12 输入样例1： 1232 2 21 22 1 输出样例1： 12 输入样例2： 1232 3 21 2 32 1 5 输出样例2： 114 记忆化搜索 四维DP： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 55, MOD = 1000000007;int n, m, k;int w[N][N];int f[N][N][13][14]; // f[i][j][k][c]表示在(i, j)这个点，拿了k个物品，这些物品中最大值为c的方案数int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; w[i][j]; w[i][j]++; // 由于需要表示比物品价值（可能为0）更小的价值，可以设置初始为-1，但是数组下标不能为-1，于是把物品价值往右偏移一位，现在是[1,13] &#125; // 两个边界初始化 // 在起点 (1, 1) 处 // 如果拿也只能拿 a[i][j] 这个物品，只有一种方案 // 如果不拿，那就是 0 个物品，也是一个方案数 // 由于物品价值已经增加了一个偏移量，现在价值的范围是 [1, 13] // 所以价值为 0 并不代表物品的价值，而是一个边界点 f[1][1][1][w[1][1]] = 1; f[1][1][0][0] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (i == 1 &amp;&amp; j == 1) continue; for (int u = 0; u &lt;= k; u++) // 拿了u件物品 for (int v = 0; v &lt;= 13; v++) &#123; // 拿的物品的最大价值为v int &amp;val = f[i][j][u][v]; // 不拿物品 val = (val + f[i - 1][j][u][v]) % MOD; // 为什么时val += 前面可能的方案数而不是等于 val = (val + f[i][j - 1][u][v]) % MOD; // 因为这个题球的时方案数，所以必须得是方案数的和，否则覆盖的话，会损失方案数 // 可以拿 if (u &gt; 0 &amp;&amp; v == w[i][j]) &#123; for (int c = 0; c &lt; v; c++) &#123; // c &lt; v;因为现在取的宝贝要比之前的价值都大 val = (val + f[i - 1][j][u - 1][c]) % MOD; val = (val + f[i][j - 1][u - 1][c]) % MOD; &#125; &#125; &#125; &#125; // 最后把在终点 (n, m) 处拿 c 个物品的方案数累加 int res = 0; for (int i = 0; i &lt;= 13; i++) res = (res + f[n][m][k][i]) % MOD; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 李白打酒一天，他提着酒壶，从家里出来，酒壶中有酒 2 斗。 他边走边唱： 无事街上走，提壶去打酒。 逢店加一倍，遇花喝一斗。 这一路上，他一共遇到店 N 次，遇到花 M 次。 已知最后一次遇到的是花，他正好把酒喝光了。 请你计算李白这一路遇到店和花的顺序，有多少种不同的可能？ 注意：壶里没酒 (000 斗) 时遇店是合法的，加倍后还是没酒；但是没酒时遇花是不合法的。 输入格式 第一行包含两个整数 N 和 M。 输出格式 输出一个整数表示答案。由于答案可能很大，输出模 1000000007的结果。 数据范围 对于 40% 的评测用例：1≤N,M≤10 对于 100% 的评测用例：1≤N,M≤100 输入样例： 15 10 输出样例： 114 样例解释 如果我们用 000 代表遇到花，111 代表遇到店，141414 种顺序如下： 1234567891011121314010101101000000010110010010000011000110010000100010110010000011001000110000100011000110000100100010110000010110100000100011001001000100100011001000100100100011000100011010000010100100100100010100101000001010100 1234567891011121314151617181920212223242526272829#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 110, MOD = 1e9 + 7;int n, m;int f[N][N][N];int main() &#123; // https://www.acwing.com/problem/content/4411/ cin &gt;&gt; n &gt;&gt; m; f[0][0][2] = 1; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt;= m; k++) &#123; int&amp; v = f[i][j][k]; if (i &amp;&amp; k % 2 == 0) v = (v + f[i - 1][j][k / 2]) % MOD; if (j) v = (v + f[i][j - 1][k + 1]) % MOD; &#125; cout &lt;&lt; f[n][m - 1][1] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://breadwinners.top/tags/DP/"}]},{"title":"求区间和","slug":"区间和","date":"2023-04-19T16:00:00.000Z","updated":"2023-07-11T01:44:28.893Z","comments":true,"path":"2023/04/20/区间和/","link":"","permalink":"http://breadwinners.top/2023/04/20/%E5%8C%BA%E9%97%B4%E5%92%8C/","excerpt":"","text":"区间和的本质是离散化 离散化：值域跨度大，用到的非常的稀疏 整数有序的离散化 题目描述： 假定有一个无限长的数轴，数轴上每个坐标上的数都是0。 现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。 近下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。 输入格式 第一行包含两个整数n和m。 接下来 n 行，每行包含两个整数x和c。 再接下里 m 行，每行包含两个整数l和r。 输出格式 共m行，每行输出一个询问中所求的区间内数字和。 数据范围 −10^9^≤ x ≤10^9^,1≤n,m≤10^5^,−10^9^≤ l ≤ r ≤10^9^,−10000≤c≤10000 输入样例：12345673 31 23 67 51 34 67 8 输出样例：123805 首先读入 数轴上可能用到的数值，这包括增加过程中用到的和后面查询过程中可能用到的，全部存入alls中(还需要进行排序去重处理)，同时增加过程中和查询过程需要使用的键值对也需要用vector&lt;pair&lt;&lt;int,int&gt;&gt;存储，便于后面的取值查询。连接alls和a数组的桥梁是她们相同的下标 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define N 300010using namespace std;typedef vector&lt;int, int&gt; PII;vector&lt;int&gt; alls; // 存储（所有与插入和查询有关的）坐标int a[N], s[N]; // 分别存储坐标插入的值和a的前缀和int find(int x) &#123; // find函数的作用是输入坐标，输出离散化后的坐标 int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (alls[mid] &lt;= x) &#123; l = mid; &#125; else r = mid - 1; &#125; return l + 1; // 二分出了问题 目前只能用另一种二分方法得出正确的结果,原来是二分的数组写错了&#125;int main() &#123; int n, m, x, c, l, r; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int, int&gt;&gt; add, query; // 存储插入和询问操作的数据 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; // 排序，去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 执行前n次插入操作 for (auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; // 前缀和 for (int i = 1; i &lt;= alls.size(); i++) // 为什么是alls.size(),因为alls是存着所有的可能用到的下标,allls数组中有多少个数，a数组中就有多少个数 s[i] = s[i - 1] + a[i]; // 处理后m次询问操作 for (auto item : query) &#123; int l = find(item.first); int r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://breadwinners.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"堆Heap","slug":"堆","date":"2023-04-19T16:00:00.000Z","updated":"2023-07-11T01:34:51.939Z","comments":true,"path":"2023/04/20/堆/","link":"","permalink":"http://breadwinners.top/2023/04/20/%E5%A0%86/","excerpt":"","text":"堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 如何手写一个堆？完全二叉树 5个操作// 1. 插入一个数 heap[ ++ size] = x; up(size);// 2. 求集合中的最小值 heap[1]// 3. 删除最小值 heap[1] = heap[size]; size -- ;down(1);// 4. 删除任意一个元素 heap[k] = heap[size]; size -- ;up(k); down(k);// 5. 修改任意一个元素 heap[k] = x; up(k); down(k);#include &lt;iostream&gt;using namespace std;int const N = 100010;// h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点// size 既表示堆里存储的元素个数，又表示最后一个结点的下标int h[N], siz; // 堆有两个变量h[N]，size; 怎么这里的size和文件里有冲突，只能改成siz了// 下滤void down(int u) &#123; int t = u; // t存储三个结点中存在的最小的结点的下标，初始化为当前结点u if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // 左子节点存在并且小于当前结点，更新t的下标 if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; // 右子节点存在并且小于当前结点，更新t的下标 if (t != u) // 如果t==u意味着不用变动，u就是三个结点中拥有最小值的结点下标，否则交换数值 &#123; swap(h[t], h[u]); down(t); // 交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小 &#125; // 如果还是不明白可以手模拟一边down的过程&#125;// 上滤void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; swap(h[u / 2], h[u]); u /= 2; &#125;&#125;// 插入新元素void push(int x) &#123; h[++siz] = x, up(x);&#125;// 删除指点元素void pop(int k) &#123; h[k] = h[siz], siz--, down(k), up(k);&#125;// 修改指定元素void modify(int k, int x) &#123; h[k] = x, down(k), up(k);&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; // 初始化size,表示堆里有n 个元素 for (int i = n / 2; i; i--) down(i); // 把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉 while (m--) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[siz]; siz--; down(1); &#125; return 0;&#125; 参考链接 ph[k]存的是第k个插入的点是哪个点(存的是点的下标)，hp[k]存是堆里的点是第几个插入的点， 复杂版heap（代码未通过）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;// int const N = 30;int const N = 100010;// h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点// size 既表示堆里存储的元素个数，又表示最后一个结点的下标int h[N], ph[N], hp[N], siz, k = 1; // ph[k]存的是第k个插入的点是哪个点，hp[k]存是堆里的点是第几个插入的点void heap_swap(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u) &#123; int t = u; // t存储三个结点中存在的最小的结点的下标，初始化为当前结点u if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // 左子节点存在并且小于当前结点，更新t的下标 if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; // 右子节点存在并且小于当前结点，更新t的下标 if (t != u) // 如果t==u意味着不用变动，u就是三个结点中拥有最小值的结点下标，否则交换数值 &#123; heap_swap(t, u); down(t); // 交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小 &#125; // 如果还是不明白可以手模拟一边down的过程&#125;// 上滤void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; heap_swap(u / 2, u); u /= 2; &#125;&#125;// 插入新元素void push(int x) &#123; h[++siz] = x; up(siz); ph[k] = siz, hp[siz] = k; k++;&#125;// 删除指点元素void pop(int k) &#123; heap_swap(k, siz); siz--, down(k), up(k);&#125;// 修改指定元素void modify(int k, int x) &#123; h[k] = x, down(k), up(k);&#125;int main() &#123; int n; string op; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; op; if (!op.compare(&quot;I&quot;)) &#123; int x; cin &gt;&gt; x; push(x); &#125; else if (!op.compare(&quot;PM&quot;)) &#123; cout &lt;&lt; h[1] &lt;&lt; &#x27;\\n&#x27;; &#125; else if (!op.compare(&quot;DM&quot;)) &#123; pop(1); down(1); &#125; else if (op[0] == &#x27;D&#x27;) &#123; int t; cin &gt;&gt; t; pop(ph[t]); &#125; else if (op[0] == &#x27;C&#x27;) &#123; int t, x; cin &gt;&gt; t &gt;&gt; x; modify(ph[t], x); &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"手写堆","slug":"手写堆","permalink":"http://breadwinners.top/tags/%E6%89%8B%E5%86%99%E5%A0%86/"}]},{"title":"DFS","slug":"dfs","date":"2023-04-18T16:00:00.000Z","updated":"2023-07-11T01:37:39.057Z","comments":true,"path":"2023/04/19/dfs/","link":"","permalink":"http://breadwinners.top/2023/04/19/dfs/","excerpt":"","text":"求全排列 （46，47） 求组合 （77） 求二叉树和为定值的某一路径 求数组中和为定值的子数组（39，40，216） 子数组问题（78，90） 八皇后问题 数独问题 回溯01背包输入：物品数量n，背包容量，各物品的重量和价值 输出：背包的最大价值、装入最大容量及装入情况 123456789101112134 52 1 3 212 10 20 15最大价值：37，背包装入最大容量：5装入情况：1 1 0 13 30 16 15 159 6 5最大价值：11，背包装入最大容量：30装入情况：0 1 1 Error example： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;int *w, *v, *x, *bestx, bestv, bestw, c, cw, cv;int n;void input() &#123; cin &gt;&gt; n &gt;&gt; c; w = new int[n + 1]; v = new int[n + 1]; x = new int[n + 1]; bestx = new int[n + 1]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i];&#125;bool constraint(int k) &#123; if (cw + w[k] &gt; c) return false; else &#123; cw += w[k]; cv += v[k]; return true; &#125;&#125;void bag(int k) &#123; if (k &gt; n) &#123; if (bestv &lt; cv) &#123; bestv = cv; bestw = cw; for (int i = 1; i &lt;= n; i++) &#123; bestx[i] = x[i]; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt;= 1; i++) &#123; x[k] = i; if (i == 0) &#123; bag(k + 1); &#125; else &#123; if (constraint(k)) &#123; // 在constraint函数中进行条件之类的操作，比如此题种的cw += w[k]; // cv += v[k]; 在非最优解的情况后不会还原状态，从而出错 bag(k + 1); &#125; &#125; &#125; &#125;&#125;int main() &#123; input(); bag(1); cout &lt;&lt; &quot;背包的最大价值为 &quot; &lt;&lt; bestv &lt;&lt; &quot; 装入最大容量为 &quot; &lt;&lt; bestw &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; bestx[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; &#x3D;&#x3D;在constraint函数中进行条件之类的操作，比如此题种的cw +&#x3D; w[k];&#x3D;&#x3D;&#x3D;&#x3D;cv +&#x3D; v[k]; 在非最优解的情况后不会还原状态，从而出错&#x3D;&#x3D; corret： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;int *w, *v, *x, *bestx, bestv = 0, bestw = 0, c, cw = 0, cv = 0;int n;void input() &#123; cin &gt;&gt; n &gt;&gt; c; w = new int[n + 1]; v = new int[n + 1]; x = new int[n + 1]; bestx = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125;&#125;void bag(int k) &#123; if (k &gt; n) &#123; if (bestv &lt; cv) &#123; bestv = cv; bestw = cw; for (int i = 1; i &lt;= n; i++) &#123; bestx[i] = x[i]; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt;= 1; i++) &#123; x[k] = i; if (i == 0) &#123; bag(k + 1); &#125; else if (cw + w[k] &lt;= c) &#123; cw += w[k]; cv += v[k]; bag(k + 1); cw -= w[k]; cv -= v[k]; &#125; &#125; &#125;&#125;int main() &#123; input(); bag(1); cout &lt;&lt; &quot;背包的最大价值为 &quot; &lt;&lt; bestv &lt;&lt; &quot; 装入最大容量为 &quot; &lt;&lt; bestw &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; bestx[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; n个数排列枚举题目： 解空间树： 123456789101112131415161718192021222324252627282930313233343536#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 10;int n;int a[N], path[N];bool st[N];void dfs(int u) &#123; if (u &gt; n) &#123; // u代表层数，n代表分支数。搜索完一个分支， 再搜索另一个分支。 for (int i = 1; i &lt;= n; i++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; // i 是枚举所有的分支 if (!st[i]) &#123; path[u] = a[i]; st[i] = true; dfs(u + 1); st[i] = false; path[u] = 0; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; dfs(1); return 0;&#125; 1-n选任意个数解空间树多叉树的遍历要用数组来记录哪个数已经被选择了，二叉树的话，直接还原现场走另一个分支，继续寻找 递归的时候怎么把每个状态记录下来path[]，记录搜索的层数时第几层u，记录一下当前分支从第几个书开始搜start，还原状态 排列数字各种类型的解空间树： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 200;// const int N = 1e5 + 10;int n;int a[N];bool vis[N];void dfs(int u) &#123; if (u &gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (vis[i]) cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; puts(&quot;&quot;); &#125; else &#123; vis[u] = true; dfs(u + 1); vis[u] = false; dfs(u + 1); &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; dfs(1); return 0;&#125;/*31 2 3 1 21 312 323 */ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 16;int n;int st[N]; // 状态，记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它void dfs(int u)&#123; if (u &gt; n) &#123; for (int i = 1; i &lt;= n; i ++ ) if (st[i] == 1) printf(&quot;%d &quot;, i); printf(&quot;\\n&quot;); return; &#125; st[u] = 2; dfs(u + 1); // 第一个分支：不选 st[u] = 0; // 恢复现场 st[u] = 1; dfs(u + 1); // 第二个分支：选 st[u] = 0;&#125;int main()&#123; // https://www.acwing.com/activity/content/code/content/156210/ cin &gt;&gt; n; dfs(1); return 0;&#125; n个数选m个数和排列行枚举相比，少了一个判重数组，因为dfs多了一个参数，保证了后面枚举的过程中，枚举的数一定比前一个数大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 200;// const int N = 1e5 + 10;int a[N], path[N];int n, m, cnt;bool vis[N]; // 不需要标记是否访问的数组void dfs(int u, int start) &#123; if (u + n - start &lt; m) return; // 剪枝 if (u == m + 1) &#123; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; path[i] &lt;&lt; &#x27; &#x27;; puts(&quot;&quot;); &#125; else &#123; for (int i = start; i &lt;= n; i++) &#123; path[u] = i; dfs(u + 1, i + 1); // 认为规定顺序，保持升序选择 path[u] = 0; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; dfs(1, 1); return 0;&#125;/* 5 31 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5 */ 剪枝：在第u层，选第u个数，已经选了u - 1个数，还剩下能选的数从start开始到n共n - start + 1个 数，如果加起来都小于m，则可以判定为此分支的结果都不成立，则剪枝。条件u + n - start &lt; m","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://breadwinners.top/tags/dfs/"}]},{"title":"图论","slug":"GraphTheory","date":"2023-04-16T16:00:00.000Z","updated":"2023-07-11T01:27:13.520Z","comments":true,"path":"2023/04/17/GraphTheory/","link":"","permalink":"http://breadwinners.top/2023/04/17/GraphTheory/","excerpt":"","text":"最短路劲问题所有基础最短路径在未标记的节点中寻找距离出发点最小的节点，标记，收录进最优路径节点中 1234564 4 0 1 31 2 11 3 43 2 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define maxn 6// #define maxn 110#define INF 0x3f3f3f3f// 根据边权图建边（邻接矩阵）int edges[maxn][maxn]; // 邻接矩阵int dist[maxn]; // 距离源点距离的数组bool visited[maxn]; // 是否已经找到最短路void init(int n) &#123; int i, j; memset(edges, INF, sizeof(edges)); // 初始化邻接矩阵 memset(visited, false, sizeof(visited)); for (i = 0; i &lt; n; ++i) &#123; for (j = 0; j &lt; n; ++j) &#123; if (i == j) &#123; edges[i][j] = 0; &#125; &#125; &#125;&#125;void dijkstra(int src, int n) &#123; int i, p; // 初始化 dist[] for (i = 0; i &lt; n; ++i) &#123; dist[i] = edges[src][i]; &#125; visited[src] = true; while (true) &#123; p = -1; // 记录当前集合中到源点最小路径的点的下标 int mn = INF; // 看起来 mn 是一个临时存储值的作用 for (i = 0; i &lt; n; ++i) &#123; // 在dist[]找一个最小的路径，并将这条路到达的顶点记录 // 通过遍历 S 集合的方法，寻找最小路径的顶点，此处可以通过优先队列的方法优化 if (!visited[i] &amp;&amp; dist[i] &lt; mn) &#123; // dist[i] &lt; mn 成立是可达，dist[i] &lt; mn,会挑选出到源点最小距离的点 mn = dist[i]; p = i; &#125; &#125; visited[p] = true; if (p == -1) &#123; break; &#125; for (i = 0; i &lt; n; ++i) &#123; // 更新未访问过的节点到新访问节点p 的距离 if (!visited[i] &amp;&amp; mn + edges[p][i] &lt; dist[i]) &#123; dist[i] = mn + edges[p][i]; &#125; &#125; &#125;&#125;int main() &#123; cout &lt;&lt; &quot;现在开始建立邻接矩阵：&quot; &lt;&lt; endl; int n, m; int i, j; cout &lt;&lt; &quot;请输入顶点数量和边的数量：&quot; &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; init(n); cout &lt;&lt; &quot;请输入边的起点、终点以及距离：&quot; &lt;&lt; endl; for (i = 0; i &lt; m; ++i) &#123; int u, v, wt; cin &gt;&gt; u &gt;&gt; v &gt;&gt; wt; edges[u][v] = edges[v][u] = wt; &#125; cout &lt;&lt; &quot;请输入起点城市：&quot; &lt;&lt; endl; int start; cin &gt;&gt; start; dijkstra(start, n); cout &lt;&lt; &quot;起点城市到所有城市的最小距离为：&quot; &lt;&lt; endl; for (j = 0; j &lt; n; ++j) &#123; cout &lt;&lt; start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot;最小路径为&quot; &lt;&lt; dist[j] &lt;&lt; endl; &#125; return 0;&#125; 分支限界法 acwing Dijkstra给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。 请你求出 111 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。 输入格式 第一行包含整数 n和 m。 接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y的有向边，边长为 z。 输出格式 输出一个整数，表示 1 号点到 n 号点的最短距离。 如果路径不存在，则输出 −1。 数据范围 1≤n≤500 1≤m≤10^5^ 图中涉及边长均不超过10000。 输入样例： 12343 31 2 22 3 11 3 4 输出样例： 13 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 510;int n, m;int g[N][N];int dist[N];bool visited[N];int dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int t = -1; // t = -1 ,在下面内层循环的判断中一定会成立，因为一定要找到一个能够与当前源点距离最近的点，t == -1只会成立一次，知识为了找到第一个距离起始点最近的点，且在下面dist[j] = min(dist[j], dist[t] + g[t][j]);中用于初始化第一次的距离出发点的距离 for (int j = 1; j &lt;= n; j++) if (!visited[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); visited[t] = true; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m--) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = min(g[a][b], c); // 有向无环图只能赋一边的值********* &#125; printf(&quot;%d\\n&quot;, dijkstra()); return 0;&#125; 邻接表存的话，无所谓重边 Kruskal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 200010, INF = 0x3f3f3f3f;int n, m;int p[N];struct Edge &#123; int a, b, w;&#125; edges[M];bool cmp(Edge a, Edge b) &#123; // 通过边长进行排序 return a.w &lt; b.w;&#125;// 并查集int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int kruskal() &#123; sort(edges, edges + m, cmp); for (int i = 1; i &lt;= n; i++) // 初始化并查集 p[i] = i; int res = 0, cnt = 0; for (int i = 0; i &lt; m; i++) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) &#123; p[a] = b; // 合并a b res += w; cnt++; // 当前加了多少条边 &#125; &#125; if (cnt &lt; n - 1) return INF; // 如果保留的边小于点数-1，则不能连通 else return res;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); edges[i] = &#123;a, b, w&#125;; &#125; int t = kruskal(); if (t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://breadwinners.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"graph","slug":"graph","permalink":"http://breadwinners.top/tags/graph/"}]},{"title":"BFS","slug":"bfs","date":"2023-04-16T16:00:00.000Z","updated":"2023-07-11T01:37:33.107Z","comments":true,"path":"2023/04/17/bfs/","link":"","permalink":"http://breadwinners.top/2023/04/17/bfs/","excerpt":"","text":"不是所有的最短路径问题都可以用bfs来做，只有当边权相同的时候才能用bfs pair是一对值 BFS一般框架 走迷宫思路参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;int bfs(string start) &#123; // 定义目标状态 string end = &quot;12345678x&quot;; // 定义队列和dist数组 queue&lt;string&gt; q; unordered_map&lt;string, int&gt; d; // 初始化队列和dist数组 q.push(start); d[start] = 0; // 转移方式 int dx[4] = &#123;1, -1, 0, 0&#125;, dy[4] = &#123;0, 0, 1, -1&#125;; while (q.size()) &#123; auto t = q.front(); q.pop(); // 记录当前状态的距离，如果是最终状态则返回距离 int distance = d[t]; if (t == end) return distance; // 查询x在字符串中的下标，然后转换为在矩阵中的坐标 int k = t.find(&#x27;x&#x27;); int x = k / 3, y = k % 3; for (int i = 0; i &lt; 4; i++) &#123; // 求转移后x的坐标 int a = x + dx[i], b = y + dy[i]; // 当前坐标没有越界 if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123; // 转移x swap(t[k], t[a * 3 + b]); // 如果t 没有在map中，则当前状态是第一次遍历，记录距离进map 中，入队 if (d.count(t) == 0) &#123; d[t] = distance + 1; q.push(t); &#125; // 还原状态，为下一种转换情况做准备 swap(t[k], t[a * 3 + b]); &#125; &#125; &#125; // 无法转换到目标状态，返回-1 return -1;&#125;int main() &#123; string c, start; // 输入起始状态 for (int i = 0; i &lt; 9; i++) &#123; cin &gt;&gt; c; start += c; &#125; cout &lt;&lt; bfs(start) &lt;&lt; endl; return 0;&#125; 删除C++字符串中的所有空格 八数码在一个 $3 × 3$的网格中，1 ~ 8 这 8 个数字和一个 x 恰好不重不漏地分布在这 $3 × 3$ 的网格中。 例如： 1231 2 3x 4 67 5 8 在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1231 2 34 5 67 8 x 例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1231 2 3 1 2 3 1 2 3 1 2 3x 4 6 4 x 6 4 5 6 4 5 67 5 8 7 5 8 7 x 8 7 8 x 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。 输入格式输入占一行，将 $3 × 3$ 的初始网格描绘出来。 例如，如果初始网格如下所示： 1231 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式输出占一行，包含一个整数，表示最少交换次数。 如果不存在解决方案，则输出 −1−1-1。 输入样例：12 3 4 1 5 x 7 6 8 输出样例119 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;int bfs(string start) &#123; // 定义目标状态 string end = &quot;12345678x&quot;; // 定义队列和dist数组 queue&lt;string&gt; q; unordered_map&lt;string, int&gt; d; // 初始化队列和dist数组 q.push(start); d[start] = 0; // 转移方式 int dx[4] = &#123;1, -1, 0, 0&#125;, dy[4] = &#123;0, 0, 1, -1&#125;; while (q.size()) &#123; auto t = q.front(); q.pop(); // 记录当前状态的距离，如果是最终状态则返回距离 int distance = d[t]; if (t == end) return distance; // 查询x在字符串中的下标，然后转换为在矩阵中的坐标 int k = t.find(&#x27;x&#x27;); int x = k / 3, y = k % 3; for (int i = 0; i &lt; 4; i++) &#123; // 求转移后x的坐标 int a = x + dx[i], b = y + dy[i]; // 当前坐标没有越界 if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123; // 如何寻找限制条件？？？a:这里不需要限制条件 // 转移x swap(t[k], t[a * 3 + b]); // 下面if 记录下宽搜的一种可能情况 // 如果t 没有在map中，则当前状态是第一次遍历，记录距离进map 中，入队 if (d.count(t) == 0) &#123; d[t] = distance + 1; q.push(t); &#125; // 还原状态，为下一种转换情况做准备 swap(t[k], t[a * 3 + b]); // 因为这个是宽搜，所以它必须交换回原来的值继续进行更新后续可能的情况 &#125; &#125; &#125; // 无法转换到目标状态，返回-1 return -1;&#125;int main() &#123; string c, start; // 输入起始状态 for (int i = 0; i &lt; 9; i++) &#123; cin &gt;&gt; c; start += c; &#125; cout &lt;&lt; bfs(start) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://breadwinners.top/tags/bfs/"}]},{"title":"前缀和和差分","slug":"前缀和和差分","date":"2023-04-16T16:00:00.000Z","updated":"2023-07-11T01:43:41.873Z","comments":true,"path":"2023/04/17/前缀和和差分/","link":"","permalink":"http://breadwinners.top/2023/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/","excerpt":"","text":"一维前缀和12345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; // 一维前缀和 int n, m; cin &gt;&gt; n &gt;&gt; m; int a[n + 1] = &#123;0&#125;, s[n] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; s[i] = s[i - 1] + a[i]; &#125; while (m--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 二维前缀和s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] (x2, y2) - (x1, y1) = s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1] &#x3D;&#x3D;注意&#x3D;&#x3D; 定义两个1w * 1w的数组，电脑爆了，100 * 100的过不了，1k * 1k比较理想 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#define N 1010using namespace std;int main() &#123; // 二维前缀和 int n, m, q; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;q); int a[N][N] = &#123;0&#125;, s[N][N] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;a[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; // 计算s[i][j] &#125; &#125; while (q--) &#123; int x1, x2, y1, y2; scanf(&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]);// 计算s[x1][y1] - s[x2][y2] &#125; return 0;&#125; 一维差分 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;iostream&gt;#define N 100010using namespace std;int a[N] = &#123;0&#125;, b[N] = &#123;0&#125;; // 只用了一个b数组void insert(int l, int r, int n) &#123; // 插入函数是精髓 b[l] += n; b[r + 1] -= n;&#125;int main() &#123; // 一维差分 int n, m; cin &gt;&gt; n &gt;&gt; m; int t; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t; insert(i, i, t); &#125; while (m--) &#123; int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; insert(l, r, k); &#125; for (int i = 1; i &lt;= n; i++) &#123; b[i] += b[i - 1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 差分矩阵 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;algorithm&gt;#include &lt;iostream&gt;#define N 1010using namespace std;int a[N][N] = &#123;0&#125;, b[N][N] = &#123;0&#125;;void insert(int x1, int y1, int x2, int y2, int k) &#123; b[x1][y1] += k; b[x2 + 1][y1] -= k; b[x1][y2 + 1] -= k; b[x2 + 1][y2 + 1] += k;&#125;int main() &#123; // 差分矩阵 ios::sync_with_stdio(false); int n, m, q, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; t; insert(i, j, i, j, t); &#125; &#125; while (q--) &#123; int x1, y1, x2, y2, k; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; k; insert(x1, y1, x2, y2, k); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + b[i][j]; cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 激光炸弹地图上有 N个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。 注意：不同目标可能在同一位置。 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R个位置的正方形内的所有目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，yx，yx，y 轴平行。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。 输出格式输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围$0≤R≤10^9$$0&lt;N≤10000$ $0≤Xi,Yi≤5000$$0≤Wi≤1000$ 输入样例：1232 10 0 11 1 1 输出样例：11 注意他这个目标是在线和线的交界上，不是格子的中心 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5010;int n, m;int s[N][N];int main()&#123; int cnt, R; cin &gt;&gt; cnt &gt;&gt; R; R = min(5001, R); // 因为最大的宽度为5000，而 R 的范围可能取到1e9,但是覆盖整个区域，5001就够了，所以这里得处理一下，否则后面大于5000，往右下角端点枚举时，循环不会执行，不会进行枚举ji&#x27;suan n = m = R; while (cnt -- ) &#123; int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x ++, y ++ ; n = max(n, x), m = max(m, y); s[x][y] += w; &#125; // 预处理前缀和 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; int res = 0; // 枚举所有边长是R的矩形，枚举(i, j)为右下角 for (int i = R; i &lt;= n; i ++ ) for (int j = R; j &lt;= m; j ++ ) res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; // 把n和m 都换成最大的临界值 5001可以AC，但是5010，就会报SegmentFault，5001虽然可以过，但是对于时间的耗费还是很高，建议还是定义n和m确定一下边界值，减少遍历次数//作者：yxc//链接：https://www.acwing.com/activity/content/code/content/163730/ K倍区间给定一个长度为 N 的数列，$A1,A2,…AN$，如果其中一段连续的子序列 $Ai,Ai+1,…Aj$之和是 K 的倍数，我们就称这个区间 $[i,j]$ 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？ 输入格式第一行包含两个整数 N 和K。 以下 N 行每行包含一个整数$Ai$。 输出格式输出一个整数，代表 K 倍区间的数目。 数据范围$1≤N,K≤100000, $$1≤Ai≤100000$ 输入样例125 21 2 3 4 5 输出样例16 每种余数有多少种，相同的一种余数就会对应一种答案 代码思路优化过程： 枚举 O(n3)可以很简单的写出暴力代码，直接三重循环 12345678for(int r = 1; r &lt;= n; r ++) for(int l = 1; l &lt;= r; l ++) &#123; int sum = 0; for(int i = l; i &lt;= r; i ++) sum += a[i]; if(sum % k == 0) ans ++; &#125; 枚举左右区间端点l,r，求出区间和sum判断是否为k的倍数，然后记录在答案ans上。可以看出第三重循环的作用就是算出区间[l,r]的和，所以用前缀和来优化这重循环。 前缀和 O(n2）预处理一下数组a[]，将前缀和存入s[]中，每次查询就只需要O(1)O(1)O(1)的时间了 12345for(int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + a[i]; // 求前缀和for(int r = 1; r &lt;= n; r ++) for(int l = 1; l &lt;= r; l ++) if((s[r] - s[l - 1]) % k == 0) ans ++; 但是这个时间还是会炸，所以还需要优化一层。 数学 O(n) 第二层循环的作用是枚举左端点，写出来就是(s[r] - s[0, r - 1]) % k = 0,当这个条件成立答案就加一。 化简: s[r]%k≡s[0,r−1]%k 现在这个式子的意思就是：在模k的情况下，之前所有点和当前点有都少个相等。所以再开一个额外的数组cnt[]记录每个前缀和取余k的余数的数量，遍历一遍就行了。 注意还得把cnt[0]赋值1，因为没有计算0%k==0这一项。 (s[ i ] - s[ j ]) % k 等价于s[ i ] % k的余数和s[ j ] % k的余数相同时的组合数C(s,2)&#x3D;s(s-1)&#x2F;2&#x3D;1+2+3+…+s-1,其中s为相同余数的数量。而针对余数为0的数，由于其本身就是k的倍数，所以其组合数为C(s,2)+s&#x3D;1+2+3+…+s，因此需要设置cnt[0] &#x3D; 1整合计算。 模拟过程 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;LL s[N], cnt[N];int main() &#123; int n, k; LL res = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; // 预处理前缀和 scanf(&quot;%lld&quot;, &amp;s[i]); s[i] += s[i - 1]; &#125; cnt[0] = 1; // 如果有直接 % k == 0，的，需要直接加上，不需要像其他的值一样，需要出现两次 %k 相等的值在加上 for (int i = 1; i &lt;= n; i++) &#123; res += cnt[s[i] % k]; cnt[s[i] % k]++; &#125; cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://breadwinners.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"http://breadwinners.top/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"并查集","slug":"并查集","date":"2023-04-15T16:00:00.000Z","updated":"2023-07-11T01:34:12.047Z","comments":true,"path":"2023/04/16/并查集/","link":"","permalink":"http://breadwinners.top/2023/04/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"合并集合123456789int find(int x)&#123; if (p[x] == x || p[p[x]] == p[x]) return p[x]; int r = find(p[x]); p[x] = r; return r;&#125; 12345int find(int x) &#123; // 这个函数的作用是寻找x的祖宗根节点，而不是父节点 if (x != p[x]) p[x] = find(p[x]); // 这其中实现了路径压缩的工作，但是不知道怎么实现的 return p[x];&#125; 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int p[N];int find(int x) &#123; // 这个函数的作用是寻找x的祖宗根节点，而不是父节点 if (x != p[x]) p[x] = find(p[x]); // 这其中实现了路径压缩的工作，但是不知道怎么实现的 return p[x];&#125;int main() &#123; // 并查集 int n, m; char op; int a, b; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; p[i] = i; &#125; while (m--) &#123; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if (op == &#x27;M&#x27;) &#123; p[find(a)] = find(b); // 必须找打根节点然后合并,把a合并到b，不是p[find(a)] = p[find(b)],虽然这样也能对 &#125; else if (op == &#x27;Q&#x27;) &#123; if (find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 连通块中点的数量1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010 + 10;int p[N], cnt[N];int find(int x) &#123; if (x != p[x]) p[x] = find(p[x]); return p[x];&#125;int main() &#123; // 连通块中点的个数 int n, m, a, b; string op; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; // 为什么从1开始？从0开始也是可以的 p[i] = i; cnt[i] = 1; &#125; while (m--) &#123; cin &gt;&gt; op; if (op[0] == &#x27;C&#x27;) &#123; cin &gt;&gt; a &gt;&gt; b; if (find(a) == find(b)) continue; cnt[find(b)] += cnt[find(a)]; // **必须先改节点数目的大小才能合并集合，先合并集合，节点的数量就变了** p[find(a)] = find(b); // erroneous cnt[b] += cnt[a]; &#125; else if (op[1] == &#x27;1&#x27;) &#123; // 查询a, b是否在一个连通块中 cin &gt;&gt; a &gt;&gt; b; if (find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; else if (op[1] == &#x27;2&#x27;) &#123; cin &gt;&gt; a; // erroneous puts(&quot;&quot; + cnt[x]); cout &lt;&lt; cnt[find(a)] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; return 0;&#125; 食物链 核心代码12345678910int find(int x)&#123; if(p[x] != x) &#123; int tmp = find(p[x]); d[x] += d[p[x]]; // 加上父节点到父父节点的距离 p[x] = tmp; &#125; return p[x];&#125; 注意事项，即明白 d[i] 的含义看了几位同学分享的代码还有题解，对于d[i]的理解其实是有误的，d[i]的正确理解，应是第 i 个节点到其父节点距离，而不是像有些同学所讲的，到根节点的距离！！这点大家一定要搞清楚，之所以有这样的误会，是因为find()函数进行了路径压缩，当查询某个节点 i 时，如果 i 的父节点不为根节点的话，就会进行递归调用，将 i 节点沿途路径上所有节点均指向父节点，此时的 d[i] 存放的是 i 到父节点，也就是根节点的距离。下面为了更好的理解函数调用过程以及d[i]的变化，我将插图分享给大家 网络分析小明正在做一个网络实验。 他设置了 n 台电脑，称为节点，用于收发和存储数据。 初始时，所有节点都是独立的，不存在任何连接。 小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信了。 两个节点如果存在网线连接，称为相邻。 小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接或间接相邻的节点都收到了信息。 所有发送和接收的节点都会将信息存储下来。 一条信息只存储一次。 给出小明连接和测试的过程，请计算出每个节点存储信息的大小。 输入格式 输入的第一行包含两个整数 n,m分别表示节点数量和操作数量。 节点从 1 至 n 编号。 接下来 m 行，每行三个整数，表示一个操作。 如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 a &#x3D; b 时，表示连接了一个自环，对网络没有实质影响。 如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。 输出格式 输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示进行完上述操作后节点 1 至节点 n 上存储信息的大小。 数据范围 1≤n≤100001≤m≤10^5^1≤t≤100 输入样例1： 1234567894 81 1 22 1 102 3 51 4 12 2 21 1 21 2 42 2 1 输出样例1： 113 13 5 3 合并时不创建新的节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 10010;int n, m;int p[N], d[N];int find(int x) &#123; if (p[x] == x || p[p[x]] == p[x]) return p[x]; int r = find(p[x]); d[x] += d[p[x]]; p[x] = r; return r;&#125;int main() &#123; // https://www.acwing.com/problem/content/2071/ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i] = i; while (m--) &#123; int t, a, b; scanf(&quot;%d%d%d&quot;, &amp;t, &amp;a, &amp;b); if (t == 1) &#123; a = find(a), b = find(b); // 一定要先找到祖宗节点再判断是否是属于同一棵树 if (a != b) &#123; d[a] -= d[b]; p[a] = b; &#125; &#125; else &#123; a = find(a); d[a] += b; &#125; &#125; for (int i = 1; i &lt;= n; i++) if (i == find(i)) // 注意是 i ，不是从p[i]找 printf(&quot;%d &quot;, d[i]); else printf(&quot;%d &quot;, d[i] + d[find(i)]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"连通块","slug":"连通块","permalink":"http://breadwinners.top/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"}]},{"title":"贪心问题","slug":"贪心问题","date":"2023-04-14T16:00:00.000Z","updated":"2023-07-11T01:46:36.130Z","comments":true,"path":"2023/04/15/贪心问题/","link":"","permalink":"http://breadwinners.top/2023/04/15/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"活动安排问题问题描述和分析设有n个活动的集合E&#x3D;{1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间Si和一个结束时间fi,且si &lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。 活动安排问题： 要在所给的活动集合中选出最大的相容活动子集合。 活动安排问题的关键是如何按照一定的顺序安排活动，使得选出的活动间相容并能安排尽量多的活动。 例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下： i 1 2 3 4 5 6 7 8 9 10 11 s[i] 1 3 0 5 3 5 6 8 8 2 12 f[i] 4 5 6 7 8 9 10 11 12 13 14 由于输入的活动以其完成时间的非减序排列，所以每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。 若被检查的活动i的开始时间Si小于最近选择的活动j的结束时间fi****，则不选择活动i，否则选择活动i加入集合A中。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int s[12] = &#123;0, 1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12&#125;, f[12] = &#123;0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14&#125;;bool a[11];int n = 11;int Selector() &#123; a[1] = true; int j = 1; int count = 1; for (int i = 2; i &lt;= n; i++) &#123; if (s[i] &gt;= f[j]) &#123; // 如果活动 i 的开始时间晚于活动 j 的结束时间，则选择活动 i，否则，舍弃活动 i a[i] = true; j = i; count++; &#125; else a[i] = false; &#125; return count;&#125;int main() &#123; cout &lt;&lt; &quot;活动序号：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 11; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl &lt;&lt; &quot;活动开始时间：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 11; i++) cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl &lt;&lt; &quot;活动结束时间：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 11; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;; puts(&quot;\\n**********************&quot;); int count = Selector(); cout &lt;&lt; &quot;一共选择个&quot; &lt;&lt; count &lt;&lt; &quot;活动如下：&quot; &lt;&lt; endl; for (int i = 0; i &lt;= n; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; &quot; &quot;; return 0;&#125; 注意：此题目要求活动的结束时间从小到大排序，所以在实际输入的时候最好用STL sort函数对其进行升序排序，数据可以用结构体或者vector&lt;int , int&gt; 存储 多机调度贪心算法参考 ####问题描述 设有n个独立的作业&#123;1, 2, …, n&#125;，由m台相同的机器`&#123;M1, M2, …, Mm&#125;`进行加工处理，作业i所需的处理时间为ti（1≤i≤n），每个作业均可在任何一台机器上加工处理，但不可间断、拆分。多机调度问题要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。 设7个独立作业&#123;1, 2, 3, 4, 5, 6, 7&#125;由3台机器`&#123;M1, M2, M3&#125;`加工处理，各作业所需的处理时间分别为&#123;2, 14, 4, 16, 6, 5, 3&#125;。 求解思路 贪心法求解多机调度问题的贪心策略是最长处理时间作业优先，即把处理时间最长的作业分配给最先空闲的机器，这样可以保证处理时间长的作业优先处理，从而在整体上获得尽可能短的处理时间。按照最长处理时间作业优先的贪心策略，当m≥n时，只要将机器i的[0, ti)时间区间分配给作业i即可；当m＜n时，首先将n个作业依其所需的处理时间从大到小排序，然后依此顺序将作业分配给空闲的处理机。 设n个作业的处理时间存储在数组t[n]中，m台机器的空闲时间存储在数组d[m]中，集合数组S[m]存储每台机器所处理的作业，其中S[i]表示机器i所处理的作业，算法如下： 思路图解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define N 10 // 定义最大作业数量int d[N]; // 定义机器的处理作业的总时长和int S[N][N]; // 记录每台机器处理的作业，第一个下标是机器编号，每一维数组中存的是处理的作业的编号struct work &#123; // 定义一个结构体，记录作业处理时间 int hour; // 作业时间 int number; // 原顺序&#125;;bool cmp(work x, work y) &#123; return x.hour &gt; y.hour;&#125;work t[N];void MultiMachine(int n, int m) &#123; int rear[N]; // 队尾下标，用来指向S数组中下一个作业的位置 for (int i = 0; i &lt; m; i++) &#123; // 安排前m个作业 S[i][0] = t[i].number; rear[i] = 0; d[i] = t[i].hour; &#125; for (int i = m; i &lt; n; i++) &#123; // 一次安排余下几个作业, k用来记录当前处理任务最少时间机器的下标 int k = 0; for (int j = 0; j &lt; m; j++) // 查找最先空闲的机器 if (d[j] &lt; d[k]) k = j; rear[k]++; S[k][rear[k]] = t[i].number; d[k] += t[i].hour; &#125; // 输出结果 for (int i = 0; i &lt; m; i++) &#123; printf(&quot;机器%d处理:&quot;, i + 1); for (int j = 0; S[i][j] &gt; 0; j++) &#123; printf(&quot;作业%d\\t&quot;, S[i][j]); &#125; printf(&quot;处理时间:%d\\n&quot;, d[i]); printf(&quot;\\n&quot;); &#125;&#125;int main() &#123; int n; // 作业个数 int m; // 机器个数 printf(&quot;请输入待处理的作业个数:&quot;); scanf(&quot;%d&quot;, &amp;n); printf(&quot;请输入作业需要处理的时间:&quot;); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;t[i].hour); t[i].number = i + 1; &#125; sort(t, t + n, cmp); // 将结构体数组进行从大到小的排序，序号存在number中 printf(&quot;请输入机器的个数:&quot;); scanf(&quot;%d&quot;, &amp;m); // 将数组d初始化为0 for (int i = 0; i &lt; m; i++) &#123; d[i] = 0; &#125; MultiMachine(n, m); return 0;&#125;/*716 5 2 14 6 4 334 2 1 3 22 */ 得到小的数输入：178543 4样例输出：13 那么刚拿到这道题如何去思考呢？我们可以先试着找规律。如果要从178543中取出1个数，使这个数最小，应该取……8如果要从17543中取出1个数，使这个数最小，应该取……7如果要从1543中取出1个数，使这个数最小，应该取……5……可以发现：1，7，8是一个不降序数列（有相等的升序），也就是逐渐变多，而8，5，4，3是一个不升序数列（有相等的降序），逐渐减少。8正好是升序数列的最后一个，也是降序数列的第一个。 我们只需要找到第一个&#x3D;&#x3D;升序数列的末尾&#x3D;&#x3D;并取出它就可以算成功完成了“局部的最优解”，再通过这个继续取出更多的数 得到大得数输入： 16403 1 &lt; 6，删除1，得6403 0 &lt; 3 ， 删除0，得643 都是降序的，删除6，得43 都是降序的，删除4，的3 每次删除&#x3D;&#x3D;升序的第一个数字&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int shanshu(string &amp;a, int k) &#123; int n = a.size(), j = 0; while (k &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; // 检测它开始降序的时候，就是 升序序列的最后一个数 ，删除 for (int j = i; j &lt; n; j++) &#123; a[j] = a[j + 1]; &#125; n--; break; // 忘记退出循环了 &#125; else if (i == n - 1) &#123; // 遍历到最后仍然没有发现开始降序，也就是整个序列已经是升序的序列，直接删除最后一个序列 n--; break; &#125; &#125; k--; &#125; return n;&#125;int main() &#123; // 删除 k 个数字后需要得到最小的数字，删除升序序列的最后一个数 string st; int n, startIndex = 0; cin &gt;&gt; st &gt;&gt; n; n = shanshu(st, n); st.erase(0, st.find_first_not_of(&#x27;0&#x27;)); // 删除“0” /* for (int i = 0; i &lt; n; i++) &#123; // 对删完后的数字的前导零进行处理 if (st[i] == &#x27;0&#x27;) &#123; startIndex++; &#125; &#125; */ for (int i = startIndex; i &lt; n; i++) &#123; cout &lt;&lt; st[i]; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"greedy","slug":"greedy","permalink":"http://breadwinners.top/tags/greedy/"}]},{"title":"费解的开关","slug":"费解的开关","date":"2023-04-13T16:00:00.000Z","updated":"2023-07-11T01:35:58.608Z","comments":true,"path":"2023/04/14/费解的开关/","link":"","permalink":"http://breadwinners.top/2023/04/14/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/","excerpt":"","text":"费解的开关25 盏灯排成一个 5×5 的方形。 每一个灯都有一个开关，游戏者可以改变它的状态。 每一步，游戏者可以改变某一个灯的状态。 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。 下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 666 步以内使所有的灯都变亮。 输入格式第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。 以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。 每组数据描述了一个游戏的初始状态。 各组数据间用一个空行分隔。 输出格式一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。 数据范围$0&lt;n≤500$ 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例： 12332-1 每一行的暗灯都由下面一行去点亮 为什么要枚举第一行的状态？ 我觉得吧，枚举第一行的所有按法是用来减少步数的，我之前一直觉得从第二行直接看就好，但是从第二行开始其实就已经固定了最后的答案，这样的解不一定是最少的甚至可能超出范围而没有解。 所以，枚举第一行的意义是：不需要在意第一行的灯是灭是暗，只需把第一行的按法枚举一遍，也就是我们说的 “操作”，每个位置都有两种选择，按(用1表示)或者不按(用0表示)，遍历这32种操作引发的情况，每一次再通过res &#x3D; min(res, step);把最小步数存一下，就能找到最优解 后面的op从1–31，因为是位运算，所以是1–31的二进制和1的二进制从右向左进行与的操作，比如10100(20)的op，意思是第2、4位（右到左01234）需要按，不是代表灯有没有亮，32种状态其实是哪些灯要按，一种op对应一种固定的按法，所以是&amp;1=&#x3D;1或者^1=&#x3D;0。同理，调用方法这里应该是turn(0, 4 - i) 小寄巧：字符数0的二进制为 11000 ， 字符数1的二进制为 11001 ，二者的更换操作可以设置为x ^= 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 6;int dx[N] = &#123;-1, 0, 1, 0, 0&#125;, dy[N] = &#123;0, 1, 0, -1, 0&#125;;char g[N][N], backup[N][N];// 这个操作是把(x, y)以及上下左右的灯都变成相反的颜色void turn(int x, int y) &#123; for (int i = 0; i &lt; 5; i++) &#123; int a = x + dx[i], b = y + dy[i]; // 如果在边界外边，直接忽略即可 if (a &lt; 0 || a &gt;= 5 || b &lt; 0 || b &gt;= 5) continue; g[a][b] ^= 1; // 异或，不同的时候就变成相反的数 &#125;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; // 按行输入，把每一行当成一个字符串 for (int i = 0; i &lt; 5; i++) cin &gt;&gt; g[i]; int res = 10; // 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍 // 按每种情况的第一行，去遍历接下来的行 // 枚举32种第一行的按法只是可能会减少步数，如果直接从第二行开始答案一定是固定的了，找不到最优解或者可能没有解 for (int op = 0; op &lt; 32; op++) &#123; // 我在对这种情况操作的时候，得先备用一下 // 把原始数组备份一下，然后操作g，操作完了还原，然后再操作 memcpy(backup, g, sizeof g); int step = 0; // 第一行的按法(在这里 1 表示按了, 0 表示不按)，这里只是为了输出第一行按完之后的状态 for (int i = 0; i &lt; 5; i++) if (op &gt;&gt; i &amp; 1) // 数字2 对应了 00010 表示第2个位置的按一下 // 00010 &gt;&gt; 1 &amp; 1 是1 所以turn(0, 1) 就是第一行第二个位置 &#123; // 数字3 对应了00011 表示第1 和第2个位置的按一下 step++; turn(0, 4 - i); // 这里的op从1~31，因为是位运算，所以是1~31的二进制和1的二进制从右向左进行与的操作， // 比如10100(20)的op，意思是第2、4位（右到左01234）需要按，不是代表灯有没有亮， // 32种状态其实是哪些灯要按，一种op对应一种固定的按法，所以是&amp;1==1或者^1==0。同理，调用方法这里应该是turn(0,4-i) ; &#125; // 然后通过第一行按完之后的状态，按234行 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 5; j++) if (g[i][j] == &#x27;0&#x27;) &#123; step++; turn(i + 1, j); // 如果这个位置是灭的，就按下一行对应的位置 &#125; bool dark = false; for (int j = 0; j &lt; 5; j++) if (g[4][j] == &#x27;0&#x27;) &#123; dark = true; break; &#125; // 对于32种情况的这一种，如果所有的全亮就记录下步数(事实上只记录了最后一行是否dark) if (!dark) res = min(res, step); memcpy(g, backup, sizeof g); &#125; if (res &gt; 6) res = -1; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://breadwinners.top/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"模拟","slug":"模拟","permalink":"http://breadwinners.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"归并排序和逆序对","slug":"归并排序和逆序对","date":"2023-04-13T16:00:00.000Z","updated":"2023-07-11T01:49:14.182Z","comments":true,"path":"2023/04/14/归并排序和逆序对/","link":"","permalink":"http://breadwinners.top/2023/04/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%86%E5%BA%8F%E5%AF%B9/","excerpt":"","text":"归并排序归并排序：归并排序采用分治的思想，将原数组分解成多个相似的子数组，进行递归解决，最后逐渐合并成排序好的数组 归并排序的核心是合并两个数组 算法过程： bilibili视频讲解 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;iostream&gt;#define N 100using namespace std;int tmp[N];void merge_sort(int q[], int l, int r);int main() &#123; int n; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;void merge_sort(int q[], int l, int r) &#123; if (l &gt;= r) &#123; // 只有一个或者没有则不用排序 return; &#125; // 对数组进行分割 int mid = l + r &gt;&gt; 1; // 取中间值为分界 merge_sort(q, l, mid); // 左边区间右边区间进行递归 merge_sort(q, mid + 1, r); // 对分割的数组进行排序 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i] &lt; q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; &#125; while (i &lt;= mid) &#123; tmp[k++] = q[i++]; &#125; while (j &lt;= r) &#123; tmp[k++] = q[j++]; &#125; // 将排好序的数组存回来 for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];&#125; 逆序对的数量在归并排序的过程中，两个子数组 成为 排序好的子数组，当右边的数组元素进入有序序列时，说明其左边的元素都是比它小的，因为每次都是挑选两个有序数组中的最小的元素进入心得有序序列，也只有右边的元素进入有序序列时，才可以确定有逆序对存在 右边元素进入新的有序序列时，可以得出暂且的逆序对为mid - i + 1 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;typedef long long LL; // 定义long long 类型const int N = 1e5 + 10;int a[N], tmp[N];LL merge_sort(int a[], int l, int r) &#123; if (l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(a, l, mid) + merge_sort(a, mid + 1, r); // 递归排序！（将序列一直分，拆封成单个，即为有序） int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; // 归并，整理逆序对的过程 if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else &#123; res += mid - i + 1; // 满足逆序对条件 tmp[k++] = a[j++]; &#125; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j]; return res;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); cout &lt;&lt; merge_sort(a, 0, n - 1) &lt;&lt; endl; return 0;&#125; 参考博客 哔哩哔哩学习","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"sort","slug":"sort","permalink":"http://breadwinners.top/tags/sort/"}]},{"title":"单链表","slug":"数据结构","date":"2023-04-12T16:00:00.000Z","updated":"2023-07-11T01:45:22.116Z","comments":true,"path":"2023/04/13/数据结构/","link":"","permalink":"http://breadwinners.top/2023/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"单链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int N = 100010;int idx, head, n[N], ne[N];int a;void add_head(int x) &#123; // 单链表的操作 n[idx] = x; ne[idx] = head; head = idx++;&#125;void add(int k, int x) &#123; n[idx] = x; ne[idx] = ne[k]; ne[k] = idx++;&#125;void remove(int k) &#123; ne[k] = ne[ne[k]];&#125;int main() &#123; head = -1; idx = 0; cin &gt;&gt; a; while (a--) &#123; string op; int k, x; cin &gt;&gt; op; if (op == &quot;D&quot;) &#123; cin &gt;&gt; k; if (!k) head = ne[head]; else remove(k - 1); &#125; else if (op == &quot;H&quot;) &#123; cin &gt;&gt; x; add_head(x); &#125; else if (op == &quot;I&quot;) &#123; int k, x; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; n[i] &lt;&lt; &quot; &quot;; return 0;&#125; 双链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int m;int e[N], l[N], r[N];int idx;//! 初始化void init() &#123; l[1] = 0, r[0] = 1; //* 初始化 第一个点的右边是 1 第二个点的左边是 0 idx = 2; //! idx 此时已经用掉两个点了&#125;//* 在第 K 个点右边插入一个 Xvoid add(int k, int x) &#123; e[idx] = x; l[idx] = k; r[idx] = r[k]; // todo 这边的 k 不加 1 ， 输入的时候 k+1 就好 l[r[k]] = idx; r[k] = idx; idx++;&#125; //! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)//*删除第 k个 点void remove(int k) &#123; r[l[k]] = r[k]; l[r[k]] = l[k];&#125;int main(void) &#123; ios::sync_with_stdio(false); cin &gt;&gt; m; init(); while (m--) &#123; string op; cin &gt;&gt; op; int k, x; if (op == &quot;R&quot;) &#123; cin &gt;&gt; x; add(l[1], x); //! 0和 1 只是代表 头和尾 所以 最右边插入 只要在 指向 1的 那个点的右边插入就可以了 &#125; else if (op == &quot;L&quot;) //! 同理 最左边插入就是 在指向 0的数的左边插入就可以了 也就是可以直接在 0的 有右边插入 &#123; cin &gt;&gt; x; add(0, x); &#125; else if (op == &quot;D&quot;) &#123; cin &gt;&gt; k; remove(k + 1); &#125; else if (op == &quot;IL&quot;) &#123; cin &gt;&gt; k &gt;&gt; x; add(l[k + 1], x); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k + 1, x); &#125; &#125; for (int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;; return 0;&#125; 单调栈123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010;int stk[N], p = -1;int main() &#123; // 单调栈 https://www.acwing.com/problem/content/832/ int n, x; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x; while (stk[p] &gt;= x &amp;&amp; p != -1) &#123; // 删除栈中比 x 大的元素，保证栈中的元素是单调递增的 p--; &#125; if (p != -1) cout &lt;&lt; stk[p] &lt;&lt; &#x27; &#x27;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; stk[++p] = x; &#125; return 0;&#125; ###运用单调队列解决滑动窗口问题（运用的数据结构实际上是双端队列） 朴素做法： 就是两层循环 外层循环每一个数 内循环窗口内每一个值，这样的时间复杂度是O(nm); 这样我们就可以用 单调队列来优化 可将时间复杂度降为 O(n)。 举例 这是我们准备求的一个数组 红色是元素值 灰色是数组下标 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int q[N], a[N];int n, k;int main() &#123; // 单调队列涉及到的滑动窗口问题 cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // 窗口维护单调递增队列 队头为最小值 int hh = 0, tt = -1; for (int i = 0; i &lt; n; i++) &#123; if (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + 1) hh++; // 队头超出窗口出队 因为每次只入一个元素 所以用if即可 while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; // 队列单调递增 q[++tt] = i; // 记住q里面存的是下标！！ 要输出元素应该是 a[q[hh]] if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;; // 窗口内达到k个 &#125; cout &lt;&lt; endl; // 窗口维护单调递减队列 队头为最大值 hh = 0, tt = -1; for (int i = 0; i &lt; n; i++) &#123; if (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + 1) hh++; // 队头超出窗口出队 因为每次只入一个元素 所以用if即可 while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; // 队列单调递增 q[++tt] = i; // 记住q里面存的是下标！！ 要输出元素应该是 a[q[hh]] if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;; // 窗口内达到k个 &#125; cout &lt;&lt; endl; return 0;&#125; 大于删除对位元素是因为要保证当前的窗格的值是最大的 小于删除是要因为后续可能的窗口由于前面较大的值出队，就成了最大值 日志统计小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。 其中每一行的格式是： 1ts id 表示在 tststs 时刻编号 ididid 的帖子收到一个”赞”。 现在小明想统计有哪些帖子曾经是”热帖”。 如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。 具体来说，如果存在某个时刻 T满足该帖在 [T,T+D)这段时间内(注意是左闭右开区间)收到不少于 KKK 个赞，该帖就曾是”热帖”。 给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 输入格式 第一行包含三个整数 N,D 以下 N 行每行一条日志，包含两个整数 ts 和 id。 输出格式 按从小到大的顺序输出热帖 id。 每个 id 占一行。 数据范围 1≤K≤N≤10^5^0≤ts,id≤10^5^1≤D≤10000 输入样例： 123456787 10 20 10 1010 1010 19 1100 3100 3 输出样例： 1213 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100010;int n, d, k;PII logs[N];int cnt[N];bool st[N]; int main() &#123; int n, d, k; cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; for (int i = 0;i &lt; n;i++) cin &gt;&gt; logs[i].x &gt;&gt; logs[i].y; sort(logs, logs + n); for (int i = 0, j = 0;i &lt; n;i++) &#123; int id = logs[i].y; cnt[id]++; // cnt数组维护的是窗口中帖子的数量 while (logs[i].x - logs[j].x &gt;= d) &#123; cnt[logs[j].y]--; j++; &#125; if (cnt[id] &gt;= k) st[id] = true; &#125; for (int i = 0;i &lt;= 100000;i++) if (st[i]) cout &lt;&lt; i &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组单链表","slug":"数组单链表","permalink":"http://breadwinners.top/tags/%E6%95%B0%E7%BB%84%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://breadwinners.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Trie树","slug":"Trie树","date":"2023-04-09T16:00:00.000Z","updated":"2023-07-11T01:32:02.889Z","comments":true,"path":"2023/04/10/Trie树/","link":"","permalink":"http://breadwinners.top/2023/04/10/Trie%E6%A0%91/","excerpt":"","text":"高效存储字符串集合 从左往右看，构成了字典树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int N = 10;// const int N = 100010;int son[N][26]; // 26是指 每个节点最多有26个子节点int cnt[N]; // 以当前字符结尾的单词个数int idx; // 当前使用的下标,下标是0的点即是根节点也是空节点，idx决定了不同的单词对应不同的p，idx始终递增，每个单词会有不同的idxchar str[N];void insert(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; // 遍历字符串，字符串末尾是&#x27;\\0&#x27;多以可以用str[i]直接判断是不是结尾了 int u = str[i] - &#x27;a&#x27;; // 把26个字母映射到0-25 if (!son[p][u]) son[p][u] = ++idx; // 如果p这个节点不存在u子节点的话 就要把他创建出来 p = son[p][u]; // 向前走 &#125; cnt[p]++; // 以p这个节点结尾的单词+1；&#125;int query(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; // 到底了，查无此单词 p = son[p][u]; // 往下走 &#125; return cnt[p]; // 返回查到的单词个数&#125;// void printdebug(int n) &#123;// if (n == 5) &#123;// for (int i = 0; i &lt; 10; i++) &#123;// for (int j = 0; j &lt; 10; j++)// cout &lt;&lt; son[i][j] &lt;&lt; &#x27; &#x27;;// cout &lt;&lt; &#x27;\\n&#x27;;// &#125;// &#125;// &#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; char op[2]; scanf(&quot;%s%s&quot;, op, str); if (op[0] == &#x27;I&#x27;) insert(str); else printf(&quot;%d\\n&quot;, query(str)); // printdebug(n); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://breadwinners.top/tags/Trie/"}]},{"title":"哈夫曼","slug":"哈夫曼","date":"2023-04-09T16:00:00.000Z","updated":"2023-07-11T01:41:32.440Z","comments":true,"path":"2023/04/10/哈夫曼/","link":"","permalink":"http://breadwinners.top/2023/04/10/%E5%93%88%E5%A4%AB%E6%9B%BC/","excerpt":"","text":"在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。 达达决定把所有的果子合成一堆。 每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。 可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。 达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。 假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。 例如有 3 种果子，数目依次为 1，2，9。 可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。 接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。 所以达达总共耗费体力&#x3D;3+12&#x3D;15。 可以证明 15 为最小的体力耗费值。 输入格式输入包括两行，第一行是一个整数 n，表示果子的种类数。 第二行包含 n 个整数，用空格分隔，第 i 个整数 ai 是第 i 种果子的数目。 输出格式输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。 输入数据保证这个值小于 2^31^。 数据范围1≤n≤10000,1≤ai≤20000 输入样例：123 1 2 9 输出样例：115 代码： 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 20;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; int n, t, sum = 0, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; t; heap.push(t); &#125; while (heap.size() &gt; 1) &#123; a = heap.top(); heap.pop(); b = heap.top(); heap.pop(); sum += a + b; heap.push(a + b); &#125; cout &lt;&lt; sum; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://breadwinners.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"heap","slug":"heap","permalink":"http://breadwinners.top/tags/heap/"}]},{"title":"frp内网穿透","slug":"Linux/centos配置内网穿透","date":"2023-04-09T16:00:00.000Z","updated":"2023-07-11T02:09:06.639Z","comments":true,"path":"2023/04/10/Linux/centos配置内网穿透/","link":"","permalink":"http://breadwinners.top/2023/04/10/Linux/centos%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"centos7使用frp搭建内网穿透写的很好 前提条件：部署FRP软件的虚拟机需可以访问互联网，并关闭操作系统防火墙。 虚拟机成功部署FRP后即可通过SSH访问虚拟机。 下载 FRP软件 ​ 下载地址：https://github.com/fatedier/frp/releases 1wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz 解压 1tar -xvf frp_0.36.2_linux_amd64.tar.gz 进入解压目录 1cd frp_0.36.2_linux_amd64 配置frpc.ini 1234vim frpc.ini[common]bind_port = 8000 服务器运行 1./frps -c ./frps.ini 添加开机自启动 123456789101112131415161718vim /usr/lib/systemd/system/frp.service[Unit]Description=The nginx HTTP and reverse proxy serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=simpleExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.iniKillSignal=SIGQUITTimeoutStopSec=5KillMode=processPrivateTmp=trueStandardOutput=syslogStandardError=inherit[Install]WantedBy=multi-user.target ExecStart的内容请根据自己frp安装目录修改。 12systemctl daemon-reload # 设置开机自启动systemctl enable frp 1systemctl start frp # 启动frp 查看frp是否启动 1ps aux | grep frps 本地服务器配置 下载frp 1wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz 解压进入 12tar -xvf frp_0.36.2_linux_amd64.tar.gzcd frp_0.36.2_linux_amd64 配置frpc.ini 1vim frpc.ini 把下面的内容复制到里面 12345678910[common]server_addr = 666.666.666.66 # 外网可以访问的服务器ipserver_port = 8000 # 本地服务器与阿里云服务器连接的端口（需要在阿里云开通该端口）[web]type = tcplocal_ip = 127.0.0.1local_port = 8080remote_port = 6666 # web服务与阿里云服务器连接的端口 运行 1./frpc -c ./frpc.ini 访问 阿里云服务器:remote_port端口&#x2F;web服务路径例如：88.888.888.88:6666&#x2F;report&#x2F;allure-html&#x2F;index.html 后台运行frp服务： 服务端： nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; 客户端： nohup ./frpc -c frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp; 说明：&gt;/dev/null 2&gt;&amp;1 &amp;，表示丢弃。 内网穿透","categories":[{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://breadwinners.top/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://breadwinners.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"","slug":"Bugs","date":"2023-04-08T16:00:00.000Z","updated":"2023-07-11T01:25:18.225Z","comments":true,"path":"2023/04/09/Bugs/","link":"","permalink":"http://breadwinners.top/2023/04/09/Bugs/","excerpt":"","text":"Ctrl + D CV 复制出的代码总会出点问题，有的相似的内容忘记改，比如 12res1 = max(res1, a[i]);res2 = max(res1, a[j]); 第二个res2应该是要min函数 &#x3D;&#x3D;习惯了使用n--读入数据，以至于到后面循环遍历数据的时候，n的值变成了 -1 不可用这个for i n 来遍历&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b) &#123; int t = 0; vector&lt;int&gt; C; for (int i = 0; i &lt; A.size() || t; i++) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) // 数据运算有必要清理前导零 C.pop_back(); return C;&#125;int main() &#123; string st; int b; vector&lt;int&gt; A; cin &gt;&gt; st &gt;&gt; b; for (int i = st.length() - 1; i &gt;= 0; i++) &#123; // 习惯性写成了i++，实际上这个题目中应该是i-- A.push_back(st[i] - &#x27;0&#x27;); &#125; vector&lt;int&gt; C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i++) &#123; // 习惯性写成了i++，实际上这个题目中应该是i-- cout &lt;&lt; C[i]; &#125; return 0;&#125; 排序，可能就会涉及到复原数组，像连号区间 涉及到数量问题，可能会爆int 递增三元组 while循环的指针，一定要判断指针不出界才继续循环 递增三元组 using namespace std 要放在typedef上面，否则会报错 结构体数组的排序方式 stable_sort 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;stdio.h&gt;int main()&#123; std::string str = &quot;668&quot;; int num = 0; sscanf(str.c_str(), &quot;%d&quot;, &amp;num); std::cout &lt;&lt; num; return 0;&#125;#include &lt;iostream&gt;int main()&#123; int num = 123; std::cout &lt;&lt; std::to_string(num); return 0;&#125; 爆int123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1000010;typedef long long LL;LL res;int n;LL a[N]; // 十年OI一场空，不开long long 见祖宗int main() &#123; // https://www.acwing.com/problem/content/description/2878/ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; LL t; for (int i = 0; i &lt; n - 1; i++) &#123; t = a[i] * a[i + 1]; res += t; a[i + 1] += a[i]; &#125; cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/tags/bugs/"}]},{"title":"STL","slug":"STL","date":"2023-04-07T16:00:00.000Z","updated":"2023-07-11T01:29:30.909Z","comments":true,"path":"2023/04/08/STL/","link":"","permalink":"http://breadwinners.top/2023/04/08/STL/","excerpt":"","text":"map中count方法123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; map&lt;int,string&gt;maps; if(maps.find(1)==maps.end()) &#123; cout&lt;&lt;&quot;没有1这个元素&quot;&lt;&lt;endl; &#125; if(maps.count(1)==0) &#123; cout&lt;&lt;&quot;没有1这个元素&quot;&lt;&lt;endl; &#125; //添加元素1 maps[1]=&quot;one&quot;; if(maps.find(1)!=maps.end()) &#123; cout&lt;&lt;&quot;有1这个元素&quot;&lt;&lt;endl; &#125; if(maps.count(1)) &#123; cout&lt;&lt;&quot;有1这个元素&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://breadwinners.top/tags/STL/"}]},{"title":"哈希表","slug":"HashMap","date":"2023-04-07T16:00:00.000Z","updated":"2023-07-11T01:27:57.785Z","comments":true,"path":"2023/04/08/HashMap/","link":"","permalink":"http://breadwinners.top/2023/04/08/HashMap/","excerpt":"","text":"拉链法模的数应该是质数 一定要记得memset 维护一个集合，支持如下几种操作： I x，插入一个数 x； Q x，询问数 x 是否在集合中出现过； 现在要进行 N 次操作，对于每个询问操作输出对应的结果。 输入格式第一行包含整数 N，表示操作数量。 接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。 输出格式对于每个询问指令 Q x，输出一个询问结果，如果 xxx 在集合中出现过，则输出 Yes，否则输出 No。 每个结果占一行。 数据范围1≤N≤10^5^−10^9^≤x≤10^9^ 输入样例：1234565I 1I 2I 3Q 2Q 5 输出样例：12YesNo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 3; // 取大于1e5的第一个质数，取质数冲突的概率最小 可以百度//* 开一个槽 hint h[N], e[N], ne[N], idx; // 邻接表void insert(int x) &#123; // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx++;&#125;bool find(int x) &#123; // 用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数 int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) &#123; if (e[i] == x) &#123; return true; &#125; &#125; return false;&#125;int n;int main() &#123; cin &gt;&gt; n; memset(h, -1, sizeof h); // 将槽先清空 空指针一般用 -1 来表示 while (n--) &#123; string op; int x; cin &gt;&gt; op &gt;&gt; x; if (op == &quot;I&quot;) &#123; insert(x); &#125; else &#123; if (find(x)) &#123; puts(&quot;Yes&quot;); &#125; else &#123; puts(&quot;No&quot;); &#125; &#125; &#125; return 0;&#125; 开放寻址法开的数组应该是数据范围的三倍 取一个在数据范围外的数，比如null &#x3D; ox3f3f3f3f，null＞10^9^，表示为空（4个3f） 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 2e5 + 3;const int null = 0x3f3f3f3f;int h[N];int find(int x) &#123; // 开放寻址法，find函数返回的是x应该存在的位置或者在的位置 int k = (x % N + N) % N; while (h[k] != x &amp;&amp; h[k] != null) &#123; k++; if (k == N) k = 0; &#125; return k;&#125;int main() &#123; char op; int n, x; cin &gt;&gt; n; memset(h, 0x3f, sizeof h); while (n--) &#123; cin &gt;&gt; op &gt;&gt; x; int k = find(x); if (op == &#x27;I&#x27;) &#123; h[k] = x; &#125; else if (op == &#x27;Q&#x27;) &#123; if (h[k] != null) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 字符串哈希 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int P = 131, N = 1e5+10; // P取这个值比较好typedef unsigned long long ULL;ULL p[N], h[N]; // h[N] 是 s[1 - n] 哈希值void init(int n, char* str) &#123; p[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125;&#125;ULL get(int l, int r) &#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main() &#123; // 字符串哈希https://www.acwing.com/problem/content/843/ int n, m; char str[N]; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str + 1; // 只能定义成char init(n, str); int l1, r1, l2, r2; while (m--) &#123; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://breadwinners.top/tags/HashMap/"}]},{"title":"暴力和模拟","slug":"暴力和模拟","date":"2023-04-06T16:00:00.000Z","updated":"2023-07-11T01:33:16.260Z","comments":true,"path":"2023/04/07/暴力和模拟/","link":"","permalink":"http://breadwinners.top/2023/04/07/%E6%9A%B4%E5%8A%9B%E5%92%8C%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"四方和定理 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 5e6 + 10;int n;int h[N * 2]; // 小技巧，避免pair，r[c^2+d^2]=c;可以推导出dint main() &#123; cin &gt;&gt; n; memset(h, -1, sizeof h); for (int c = 0; c * c &lt;= n; c++) &#123; for (int d = c; c * c + d * d &lt;= n; d++) &#123; // 必须要更严格的判断条件，c * c + d * d &lt;= n,否则会出意外 int s = c * c + d * d; if (h[s] == -1) &#123; h[s] = c; &#125; &#125; &#125; for (int a = 0; a * a &lt;= n; a++) &#123; for (int b = a; a * a + b * b &lt;= n; b++) &#123; // 必须要更严格的判断条件，a * a+ b * b &lt;= n,否则会出意外 int s = n - a * a - b * b; if (h[s] != -1) &#123; int d = sqrt(s - h[s] * h[s]); printf(&quot;%d %d %d %d\\n&quot;, a, b, h[s], d); return 0; &#125; &#125; &#125; return 0;&#125; 连号区间数 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 10010;int a[N], tmp[N];int n, cnt = 0;int main() &#123; // https://www.acwing.com/problem/content/1212/ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; int mav = -1; int miv = 10009; for (int j = i; j &lt; n; j++) &#123; mav = max(mav, a[j]); miv = min(miv, a[j]); if (mav - miv == j - i) &#123; cnt++; &#125; &#125; &#125; cout &lt;&lt; cnt; return 0;&#125; 回文日期 &#x3D;&#x3D;注意&#x3D;&#x3D; 这个题目中有两个枚举的角度，一个是 符合回文数的范围要求，另一个是 符合日期的要求，很容易会想到开始枚举日期，然后想是否满足回文数，但是这种枚举方法很麻烦，可能需要自己写个日历。所以换一个角度，先枚举回文数，再判断是否满足日期的要求，就简单很多，注意getline之前要吸收回车 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int date1, date2, res = 0;int days[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;bool check(int date) &#123; // 判断回文数中的月份是否合法 int year, month, day; year = date / 10000; month = date / 100 % 100; day = date % 100; cout &lt;&lt; year &lt;&lt; &quot; &quot; &lt;&lt; month &lt;&lt; &quot; &quot; &lt;&lt; day &lt;&lt; &quot;##\\n&quot;; if (month &lt;= 0 || month &gt; 12) return false; if (day &lt;= 0 || day &gt; days[month] &amp;&amp; month != 2) return false; if (month == 2) &#123; int leap = (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0); if (day &gt; days[month] + leap) return false; &#125; return true;&#125;int main() &#123; // https://www.acwing.com/problem/content/468/ cin &gt;&gt; date1 &gt;&gt; date2; // 首先枚举回文数，只需枚举前面4位数 for (int i = 1000; i &lt; 10000; i++) &#123; int date = i, x = i; while (x) &#123; // 通过前4位数构造回文数 date *= 10; int t = x % 10; date += t; x /= 10; &#125; cout &lt;&lt; date &lt;&lt; endl; if (check(date) &amp;&amp; date &gt;= date1 &amp;&amp; date &lt;= date2) res++; &#125; cout &lt;&lt; res; return 0;&#125; 递增三元组 双指针&#x3D;&#x3D;注意&#x3D;&#x3D; while 循环的指针，一定要判断指针不出界才继续循环 递增三元组 思路：枚举数组B，A， C数组从开头出发，满足 A &lt; B &lt; C，res++ 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n;int a[N], b[N], c[N];signed main() &#123; // https://www.acwing.com/problem/content/description/1238/ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;c[i]); sort(a, a + n); sort(b, b + n); sort(c, c + n); LL res = 0, l = 0, r = 0; // l 和 r定义在外面，因为数组排序过后，顺序是固定的，没必要从头开始查找 for (int i = 0; i &lt; n; i++) &#123; while (a[l] &lt; b[i] &amp;&amp; l &lt; n) l++; while (c[r] &lt;= b[i] &amp;&amp; r &lt; n) r++; res += (LL)l * (n - r); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 前缀和思路：定义一个数组cnta，cnta[i] 是A中小于i的数的个数，cntc[i] 是C中大于i的数的个数，然后循环遍历数组B，res +&#x3D; A中小于B[i]的数量 × C中大于B[i]的数量 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 100010;int A[N], B[N], C[N];int cnta[N], cntc[N]; // cnta[i] 是A中小于i的数的个数, cntc[i] 是C中大于i的数的个数int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;A[i]); cnta[A[i]]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;B[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;C[i]); cntc[C[i]]++; &#125; // 对数出现的次数，求一次前缀和 // 预处理前缀和 for (int i = 1; i &lt;= N; i++) &#123; // 前缀和的迭代次数不是 n, 而是题中出现的数的最大值 cnta[i] += cnta[i - 1]; &#125; for (int i = N; i &gt;= 1; i--) &#123; // 这里还需要注意前缀和的后缀和 cntc[i] += cntc[i + 1]; &#125; // 开始计算res LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; res += (LL)cnta[B[i] - 1] * cntc[B[i] + 1]; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 错误票据（考察数据读取）某涉密单位下发了某种票据，并要在年终全部收回。 每张票据有唯一的ID号。 全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。 因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。 你的任务是通过编程，找出断号的ID和重号的ID。 假设断号不可能发生在最大和最小号。 输入格式 第一行包含整数 N，表示后面共有 N 行数据。 接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。 输出格式 要求程序输出1行，含两个整数 m,n用空格分隔。 其中，m表示断号ID，n表示重号ID。 数据范围 1≤N≤100 输入样例：12325 6 8 11 9 10 12 9 输出样例： 17 9 可以使用stringstream&#x3D;&#x3D;注意&#x3D;&#x3D; getline之前必须处理掉多余的换行符\\n 12345678910111213141516171819202122232425262728293031323334353637#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;const int N = 10010;int a[N];int main() &#123; // https://www.acwing.com/problem/content/1206/ int n, cnt = 0; cin &gt;&gt; n; string line; getline(cin, line); while (n--) &#123; getline(cin, line); stringstream ssin(line); while (ssin &gt;&gt; a[cnt]) cnt++; &#125; sort(a, a + cnt); // for (int i = 0;i &lt;cnt;i++) // cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; int res1, res2; for (int i = 1; i &lt; cnt; i++) &#123; if (a[i] == a[i - 1]) res1 = a[i]; else if (a[i] - a[i - 1] &gt; 1) res2 = a[i - 1] + 1; &#125; cout &lt;&lt; res2 &lt;&lt; &quot; &quot; &lt;&lt; res1; return 0;&#125; 直接忽略第一个数，读取到EOF123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n;const int N = 1e5 + 10;int a[N];int main() &#123; // https://www.acwing.com/problem/content/1206/ cin &gt;&gt; n; int i = 0; while (cin &gt;&gt; a[i]) &#123; i++; &#125; sort(a, a + i); int duan, chong; for (int j = 0; j &lt; i; j++) &#123; if (a[j] == a[j + 1]) chong = a[j]; if (a[j] == a[j + 1] - 2) duan = a[j] + 1; &#125; cout &lt;&lt; duan &lt;&lt; &#x27; &#x27;; cout &lt;&lt; chong &lt;&lt; &#x27; &#x27;;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://breadwinners.top/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"模拟","slug":"模拟","permalink":"http://breadwinners.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"双指针","slug":"双指针","permalink":"http://breadwinners.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"快排和快选","slug":"快排问题","date":"2023-04-06T16:00:00.000Z","updated":"2023-07-11T01:42:34.183Z","comments":true,"path":"2023/04/07/快排问题/","link":"","permalink":"http://breadwinners.top/2023/04/07/%E5%BF%AB%E6%8E%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"快速排序123456789101112131415161718192021222324252627282930313233343536#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;void quick_sort(int q[], int l, int r);int main() &#123; int n = 7; int a[n] = &#123;2, 4, 3, 7, 1, 5, 6&#125;; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n####################\\n&quot;; quick_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;void quick_sort(int q[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1; while (i &lt; j) &#123; while (q[++i] &lt; x) ; while (q[--j] &gt; x) ; if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j); quick_sort(q, j + 1, r);&#125; 快速选择123456789101112131415161718192021222324252627282930#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int quick_select(int q[], int l, int r, int k);int main() &#123; int n = 5, k = 1; int a[5] = &#123;3, 4, 5, 1, 2&#125;; cout &lt;&lt; quick_select(a, 0, n - 1, k); return 0;&#125;int quick_select(int q[], int l, int r, int k) &#123; if (l &gt;= r) &#123; return q[l]; &#125; int x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1; while (i &lt; j) &#123; while (q[++i] &lt; x) ; while (q[--j] &gt; x) ; if (i &lt; j) swap(q[i], q[j]); &#125; int sl = j - l + 1; // sl可以看成排序完成后，左边 sl 个最小的数，所以第k小的数一定在左半边 if (k &lt;= sl) // k &lt;= sl, 第k小的数一点在左半边区间内 return quick_select(q, l, j, k); return quick_select(q, j + 1, r, k - sl);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"quick","slug":"quick","permalink":"http://breadwinners.top/tags/quick/"},{"name":"sort","slug":"sort","permalink":"http://breadwinners.top/tags/sort/"}]},{"title":"kmp","slug":"kmp","date":"2023-04-06T16:00:00.000Z","updated":"2023-07-11T01:48:27.795Z","comments":true,"path":"2023/04/07/kmp/","link":"","permalink":"http://breadwinners.top/2023/04/07/kmp/","excerpt":"","text":"next数组的本质其实是寻找子串中“相同前后缀”的长度，并且一定是最长的前后缀 如果下一个字符依然相同的话，直 接都成了一个更长的前后缀，长度+1, 下一个字符不同的话","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"kmp","slug":"kmp","permalink":"http://breadwinners.top/tags/kmp/"}]},{"title":"二分法和模板","slug":"二分模板","date":"2023-04-05T16:00:00.000Z","updated":"2023-08-20T12:04:33.365Z","comments":true,"path":"2023/04/06/二分模板/","link":"","permalink":"http://breadwinners.top/2023/04/06/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"二分的本质是寻找已知数据中，一部分满足某种性质，另一部分不满足某种性质，寻找这个边界点二分是寻找边界点，左边界点或者是右边界点，而边界点一定是两种性质的过渡点， 在思考过程中，不知道如何确定l &#x3D; mid,还是r &#x3D; mid，记住mid是向key靠近的，怎么取值能够让mid向可以靠近 1.先写一个check函数，确定区间性质2.确定边界写模板，对于整数二分，先写mid &#x3D; l + r &gt;&gt; 1；后面再确定是否需要+1，如果是l &#x3D; mid，就+1 模板 12345678910111213141516171819202122// 区间[l，r]被划分成[1，mid]和[mid + 1，r]时使用:int bsearch_1(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) // check() 判断mid是否满足性质 r = mid; else l = mid + 1; &#125; return l;&#125;// 区间[l，r]被划分成[l, mid - 1]和[mid，r]时使用:int bsearch_2(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 题目链接 数的范围 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m, key; cin &gt;&gt; n &gt;&gt; m; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; while (m--) &#123; cin &gt;&gt; key; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; // 大于等于 x 的第一个位置 // 1 2 2 3 3 4 // x y // 从这里往右所有的数据都&gt;= x ---&gt; a[mid] &gt;= x // 从这里往左所有的数据都&lt;= x ---&gt; a[mid] &lt;= x if (a[mid] &gt;= key) &#123; r = mid; &#125; else l = mid + 1; &#125; if (a[l] != key) &#123; cout &lt;&lt; &quot;-1 -1\\n&quot;; &#125; else &#123; int ll = 0, rr = n - 1; while (ll &lt; rr) &#123; int mid = ll + rr + 1 &gt;&gt; 1; if (a[mid] &lt;= key) &#123; // 小于等于 x 的第一个位置 ll = mid; &#125; else rr = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; ll &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://breadwinners.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"如何提高cin/cout的速度","slug":"algorithm","date":"2023-04-02T16:00:00.000Z","updated":"2023-07-11T01:23:22.866Z","comments":true,"path":"2023/04/03/algorithm/","link":"","permalink":"http://breadwinners.top/2023/04/03/algorithm/","excerpt":"","text":"在无数的算法比赛中，不难看到下面这样的东西： 1ios::sync_with_stdio(false); 甚至是这样的东西： 123ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); 现在，尽量用&quot;\\n&quot;替换可以替换的endl 。（考虑流输出）","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"cin","slug":"cin","permalink":"http://breadwinners.top/tags/cin/"},{"name":"cout","slug":"cout","permalink":"http://breadwinners.top/tags/cout/"}]},{"title":"Linux中su、sudo","slug":"Linux/sudo和su和logout","date":"2023-04-02T16:00:00.000Z","updated":"2023-07-11T02:07:40.164Z","comments":true,"path":"2023/04/03/Linux/sudo和su和logout/","link":"","permalink":"http://breadwinners.top/2023/04/03/Linux/sudo%E5%92%8Csu%E5%92%8Clogout/","excerpt":"","text":"注意：su -使用root的密码,而sudo su使用用户密码 高权限的用户切换到低权限的用户不需要吗，密码，当用户登录到另一个用户，logout会回退到上一个用户的界面 sudo sudo是一种权限管理机制，依赖于&#x2F;etc&#x2F;sudoers，其定义了授权给哪个用户可以以管理员的身份能够执行什么样的管理命令； 格式：sudo -u USERNAME COMMAND 默认情况下，系统只有root用户可以执行sudo命令。需要root用户通过使用visudo命令编辑sudo的配置文件&#x2F;etc&#x2F;sudoers，才可以授权其他普通用户执行sudo命令。 sudo的运行有这样一个流程： 1).当用户运行sudo时，系统于&#x2F;etc&#x2F;sudoers文件里查找该用户是否有运行sudo的权限； 2).若用户具有可运行sudo的权限。那么让用户输入用户自己的password，注意这里输入的是用户自己的password。 3).假设password正确。变開始进行sudo后面的命令，root运行sudo是不须要输入password的，切换到的身份与运行者身份同样的时候。也不须要输入password。 su su为switch user，即切换用户的简写。 su是最简单的身份切换名，用su我们能够进行不论什么用户的切换，一般都是su – username，然后输入password就ok了，可是root用su切换到其它身份的时候是不须要输入password的。 如果不指定USERNAME（用户名），默认即为root，所以切换到root的身份的命令即为：su -root或su -，su root 或su。 su USERNAME，与su – USERNAME的不同之处如下： su – USERNAME切换用户后，同时切换到新用户的工作环境中。 su USERNAME切换用户后，不改变原用户的工作目录，及其他环境变量目录。 如何设置初始su密码？ 当我们输入su时会发现要输入密码，我们尝试输入自己当前用户的密码，发现failure。 但我们又不知道su密码是什么？其实su初始密码可以通过下面方式进行设置： 1sudo passwd 复制 设置完后再输入su命令并键入刚才设置的密码即可进入~ su – su -，su -l或su –login 命令改变身份时，也同时变更工作目录，以及HOME，SHELL，USER，LOGNAME。此外，也会变更PATH变量。用su -命令则默认转换成成root用户了。 而不带参数的“su命令”不会改变当前工作目录以及HOME,SHELL,USER,LOGNAME。只是拥有了root的权限而已。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"su","slug":"su","permalink":"http://breadwinners.top/tags/su/"},{"name":"sudo","slug":"sudo","permalink":"http://breadwinners.top/tags/sudo/"}]},{"title":"java容器","slug":"java容器","date":"2023-03-22T16:00:00.000Z","updated":"2023-07-11T02:03:46.298Z","comments":true,"path":"2023/03/23/java容器/","link":"","permalink":"http://breadwinners.top/2023/03/23/java%E5%AE%B9%E5%99%A8/","excerpt":"","text":"List接口常用方法：1、add(Object element)： 向列表的尾部添加指定的元素。 2、size()： 返回列表中的元素个数。 3、get(int index)： 返回列表中指定位置的元素，index从0开始。 4、add(int index, Object element)： 在列表的指定位置插入指定元素。 5、set(int i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。 6、clear()： 从列表中移除所有元素。 7、isEmpty()： 判断列表是否包含元素，不包含元素则返回 true，否则返回false。 8、contains(Object o)： 如果列表包含指定的元素，则返回 true。 9、remove(int index)： 移除列表中指定位置的元素，并返回被删元素。 10、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。 11、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。 ArrayList一样可以使用List的所有方法，所以以ArrayList来演示： 方法使用：1、add(Object element) 向列表的尾部添加指定的元素。2、size() 返回列表中的元素个数。3、get(int index) 返回列表中指定位置的元素，index从0开始。 例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //&lt;String&gt;泛型表示集合中存的是字符串形式的元素。 list.add(&quot;徐冰&quot;); //add()用于向List集合容器中添加元素。 list.add(&quot;萤火&quot;); System.out.println(list); System.out.println(list.size()); //size()用于获取集合中有多少个元素。 System.out.println(list.get(1)); //get()获取指定索引（从0开始）位置的元素。 &#125;&#125; 输出：[徐冰, 萤火]2萤火 4、add(int index, Object element) 在列表的指定位置（从0开始）插入指定元素。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); System.out.println(list); list.add(1, &quot;阿若&quot;); //在指定位置添加元素，原来位置的元素后置。 System.out.println(list); &#125;&#125; 输出：[徐冰, 萤火][徐冰, 阿若, 萤火] 5、set(int i, Object element) 使用元素element替换索引i位置的元素，并返回被替换的元素。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); System.out.println(list); list.set(1, &quot;阿若&quot;); //替换指定位置的元素，从0开始，替换了“萤火”。 System.out.println(list); &#125;&#125; 输出：[徐冰, 萤火][徐冰, 阿若] 6、clear() 从列表中移除所有元素。7、isEmpty() 判断列表是否包含元素，不包含元素则返回 true，否则返回false。例如： 12345678910111213import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); System.out.println(list); list.clear(); //清空List集合中的所有元素。 System.out.println(list.isEmpty()); //集合容器没有元素，则true。 System.out.println(list); &#125;&#125; 输出：[徐冰, 萤火]true[] 8、contains(Object o) 如果列表包含指定的元素，则返回 true。例如： 1234567891011import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); boolean flag = list.contains(&quot;徐冰&quot;); //用来判断集合容器中是否含有参数元素。 System.out.println(flag); &#125;&#125; 这个方法需要思考一下，因为contains的参数类型是Object型，看一下源代码： 1234567891011121314151617public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;public int indexOf(Object o) &#123; //因为我们设置的实参是String类型的变量，所以此时o为上转型对象。 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) //因为o为上转型对象，所以equals表面上是Object类的，但实际上我们使用的是String类的equals方法。 return i; &#125; return -1;&#125; 即list为上转型对象，使用String类的equals方法比较的是两个元素的内容是否相同。 9、remove(int index) 移除列表中指定位置的元素，并返回被删元素，删除位置后面的元素（如果有）向前移动。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); list.add(&quot;阿若&quot;); System.out.println(list.remove(1)); //删除指定索引（从0开始）位置的元素，并将元素返回,并后面元素前移。 System.out.println(list); &#125;&#125; 输出：萤火[徐冰, 阿若] 10、remove(Object o) 从List集合中移除第一次出现的指定元素，移除成功返回true，否则返回false。当且仅当List集合中含有满足(o&#x3D;&#x3D;null ? get(i)&#x3D;&#x3D;null : o.equals(get(i)))条件的最低索引i的元素时才会返回true。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); list.add(&quot;阿若&quot;); System.out.println(list.remove(&quot;萤火&quot;)); //删除List集合元素，返回boolean,并后面元素前移。 System.out.println(list); &#125;&#125; 输出：true[徐冰, 阿若] 11、iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器。例如运用iterator方法进行List遍历： 123456789101112131415import java.util.ArrayList;import java.util.Iterator;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); Iterator&lt;String&gt; ite = list.iterator(); //将List集合中元素转到iterator变量中。 while(ite.hasNext()) //hasNext()判断当前“指针”下面是否还有元素的方法，java中没有指针，这只是举个例子。 &#123; System.out.println(ite.next()); //如果“指针”下面有元素，则移动“指针”并获取相应位置的元素。 &#125; &#125;&#125; 输出：徐冰萤火 12、for循环遍历List集合：例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; //用size方法获取长度。 System.out.println(list.get(i)); //用get方法获取值。 &#125; &#125;&#125; 输出：徐冰萤火 13、加强for循环遍历List集合：例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); for (String name : list) &#123; //使用foreach进行遍历。 System.out.println(name); &#125; &#125;&#125; 输出：徐冰萤火 排序12345678910111213141516//按照List中对象的id属性升序list.sort(Comparator.comparing(Stu::getId))//按照List中对象的id属性降序list.sort(Comparator.comparing(Stu::getId).reversed());//多条件升序list.sort(Comparator.comparing(Stu::getId).thenComparing(Stu::getSid));//id升序,sid降序list.sort(Comparator.comparing(Stu::getId).reversed().thenComparing(Stu::getSid));//key值重复的mapMultiValueMap&lt;Integer, String&gt; timeMap = new LinkedMultiValueMap&lt;&gt;();//集合升序排序Collections.sort(student, new Comparator()&#123;public int compare(StudentVo p1, StudentVo p2) &#123;return Integer.parseInt(p1.getStudentCode()) - Integer.parseInt(p2.getStudentCode());&#125;&#125;); Stack 栈简介 stack 类是 Vector 类的一个子类，它实现了标准的后进先出的栈 常用方法 序号 方法 作用 1 boolean empty() 判断栈是否为空 2 Object peek() 查看栈顶部的对象，但不从堆栈中移除它 3 Object pop() 移除栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object obj) 把元素压入栈顶部 5 int search(Object obj) 返回对象在堆栈中的位置，从栈顶往下开始查找。 用法讲解 创建一个空的字符栈 12Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();System.out.println(&quot;stack: &quot; + stack); // stack: [] 将元素 R 压入栈顶部 123Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();stack.push(&#x27;R&#x27;);System.out.println(&quot;stack: &quot; + stack); // stack: [R] 判断栈是否为空 1234Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();System.out.println(stack.empty()); // truestack.push(&#x27;R&#x27;);System.out.println(stack.empty()); // false 移除栈顶元素，但不移除 12345Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); stack.push(&#x27;R&#x27;);System.out.println(&quot;stack: &quot; + stack); // stack: [R]System.out.println(stack.peek()); // RSystem.out.println(&quot;stack: &quot; + stack); // stack: [R] 移除栈顶元素；如果栈为空会引起EmptyStackException 12345678910Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); stack.push(&#x27;R&#x27;);System.out.println(&quot;stack: &quot; + stack); // stack: [R]System.out.println(stack.pop()); // RSystem.out.println(&quot;stack: &quot; + stack); // stack: []try &#123; stack.pop(); &#125; catch (EmptyStackException e) &#123; System.out.println(&quot;empty stack&quot;); //empty stack &#125; 查询元素在栈中的位置；多个相同元素返回离栈顶最近的；没有则返回-1 1234567891011Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();stack.push(&#x27;E&#x27;);stack.push(&#x27;A&#x27;);stack.push(&#x27;W&#x27;);stack.push(&#x27;A&#x27;);stack.push(&#x27;Q&#x27;);stack.push(&#x27;R&#x27;);System.out.println(stack.search(&#x27;R&#x27;)); //1System.out.println(stack.search(&#x27;Q&#x27;)); //2System.out.println(stack.search(&#x27;A&#x27;)); //3System.out.println(stack.search(&#x27;D&#x27;)); // -1 QueueQueue是java中实现队列的接口，它总共只有6个方法，我们一般只用其中3个就可以了。Queue的实现类有LinkedList和PriorityQueue。最常用的实现类是LinkedList。 Queue的6个方法分类： 压入元素(添加)：add()、offer()相同：未超出容量，从队尾压入元素，返回压入的那个元素。区别：在超出容量时，add()方法会对抛出异常，offer()返回false 弹出元素(删除)：remove()、poll()相同：容量大于0的时候，删除并返回队头被删除的那个元素。区别：在容量为0的时候，remove()会抛出异常，poll()返回false 获取队头元素(不删除)：element()、peek()相同：容量大于0的时候，都返回队头元素。但是不删除。区别：容量为0的时候，element()会抛出异常，peek()返回null。 队列除了基本的 Collection 操作外，还提供特有的插入、提取和检查操作(如上)。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 Queue 实现设计的；在大多数实现中，插入操作不会失败。 抛出异常 返回特殊值 插入 add(e) offer(e) 删除 remove() poll() 检查 element() peek() Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。 Queue 实现通常未定义 equals 和 hashCode 方法的基于元素的版本，而是从 Object 类继承了基于身份的版本，因为对于具有相同元素但有不同排序属性的队列而言，基于元素的相等性并非总是定义良好的。 看一个简单的示例： 123456789101112131415public class QueueTest &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList(); queue.offer(&quot;元素A&quot;); queue.offer(&quot;元素B&quot;); queue.offer(&quot;元素C&quot;); queue.offer(&quot;元素D&quot;); queue.offer(&quot;元素E&quot;); while (queue.size() &gt; 0) &#123; String element = queue.poll(); System.out.println(element); &#125; &#125;&#125; 输出结果： 1234567元素A元素B元素C元素D元素EProcess finished with exit code 0 可以看到，queue是一个先进先出的队列。 遍历时可以用iterator指定泛型，就不需要强转 Map主要使用HashMap和Treemap get方法：获取指定键(key)所对应的值(value)， 方法返回值为键所对应的值 put方法：将指定的键与值对应起来，并添加到集合中，若指定的键(key)在集合中，覆 remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)。 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //数据采用的哈希表结构 //给map中添加元素 map.put(&quot;星期一&quot;, &quot;Monday&quot;); map.put(&quot;星期日&quot;, &quot;Sunday&quot;); System.out.println(map); // &#123;星期日=Sunday, 星期一=Monday&#125; //当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null System.out.println(map.put(&quot;星期一&quot;, &quot;Mon&quot;)); // Monday System.out.println(map); // &#123;星期日=Sunday, 星期一=Mon&#125; //根据指定的key获取对应的value String en = map.get(&quot;星期日&quot;); System.out.println(en); // Sunday //根据key删除元素,会返回key对应的value值 String value = map.remove(&quot;星期日&quot;); System.out.println(value); // Sunday System.out.println(map); // &#123;星期一=Mon&#125; &#125;&#125; 遍历Map利用迭代器 123456789101112131415161718192021public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;柳岩&quot;); //获取Map中的所有key Set&lt;String&gt; keySet = map.keySet(); //遍历存放所有key的Set集合 Iterator&lt;String&gt; it =keySet.iterator(); ** while(it.hasNext())&#123; //利用了Iterator迭代器** //得到每一个key String key = it.next(); //通过key获取对应的value String value = map.get(key); System.out.println(key+&quot;=&quot;+value); &#125; &#125;&#125; Map集合遍历键值对方式 键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。 2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象 3.通过键值对(Entry)对象，获取Entry对象中的键与值。 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;柳岩&quot;); //获取Map中的所有key与value的对应关系 Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); //遍历Set集合 Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = entrySet.iterator(); while(it.hasNext())&#123; //得到每一对对应关系 Map.Entry&lt;String,String&gt; entry = it.next(); //通过每一对对应关系获取对应的key String key = entry.getKey(); //通过每一对对应关系获取对应的value String value = entry.getValue(); System.out.println(key+&quot;=&quot;+value); &#125; &#125;&#125; &#x3D;&#x3D;注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。&#x3D;&#x3D; setHashSet特性：元素唯一，无序，可以含有空元素。 下面我们看示例： 1234567891011121314151617181920212223import java.util.HashSet;import java.util.Iterator;import java.util.Set; public class first &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str = new HashSet&lt;String&gt;(); str.add(&quot;first&quot;);//添加元素 str.add(&quot;second&quot;); str.remove(&quot;first&quot;);//删除元素 //遍历，通过迭代器 Iterator&lt;String&gt; it = str.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; //通过foreach for(String s:str) &#123; System.out.println(s); &#125; &#125;&#125; 运行结果为： LinkedHashSet这个相对于HashSet来说有一个很大的不一样是LinkedHashSet是有序的。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 详细见demo: 12345678910Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();for(int i= 0;i&lt;6;i++)&#123; set.add(i+&quot;&quot;);&#125;set.add(&quot;3&quot;); //重复数据，不会写入set.add(null); //可以写入空数据Iterator&lt;String&gt; iter = set.iterator();while(iter.hasNext())&#123; System.out.println(iter.next()); //输出是有序的&#125; 输出打印如下： 1234567012345null TreeSet:特点：元素唯一，有序，不能含有空元素。 下面我们通过示例来说明： 123456789101112131415161718192021222324252627import java.util.Iterator;import java.util.Set;import java.util.TreeSet; public class first &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str = new TreeSet&lt;String&gt;(); str.add(&quot;first&quot;);//添加元素 str.add(&quot;second&quot;); str.add(&quot;third&quot;); str.add(&quot;first&quot;);//重复元素 //遍历，通过迭代器 Iterator&lt;String&gt; it = str.iterator(); System.out.println(&quot;通过迭代器输出&quot;); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; //通过foreach System.out.println(&quot;通过foreach输出&quot;); for(String s:str) &#123; System.out.println(s); &#125; &#125;&#125; 运行结果为：","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"容器","slug":"容器","permalink":"http://breadwinners.top/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"设计模式","slug":"设计yuanze","date":"2023-03-19T16:00:00.000Z","updated":"2023-07-11T01:55:38.250Z","comments":true,"path":"2023/03/20/设计yuanze/","link":"","permalink":"http://breadwinners.top/2023/03/20/%E8%AE%BE%E8%AE%A1yuanze/","excerpt":"","text":"原则1.1 开闭原则对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。 【例】搜狗输入法 的皮肤设计。 分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。 1.2 里氏代换原则里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，&#x3D;&#x3D;除添加新的方法完成新增功能外，尽量不要重写父类的方法&#x3D;&#x3D;。 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 下面看一个里氏替换原则中经典的一个例子 【例】正方形不是长方形。 在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。 代码如下： 长方形类（Rectangle）： 1234567891011121314151617181920public class Rectangle &#123; private double length; private double width; public double getLength() &#123; return length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125;&#125; 正方形（Square）： 由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。 123456789101112public class Square extends Rectangle &#123; public void setWidth(double width) &#123; super.setLength(width); super.setWidth(width); &#125; public void setLength(double length) &#123; super.setLength(length); super.setWidth(length); &#125;&#125; 类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。 1234567891011121314151617181920212223242526272829public class RectangleDemo &#123; public static void resize(Rectangle rectangle) &#123; while (rectangle.getWidth() &lt;= rectangle.getLength()) &#123; rectangle.setWidth(rectangle.getWidth() + 1); &#125; &#125; //打印长方形的长和宽 public static void printLengthAndWidth(Rectangle rectangle) &#123; System.out.println(rectangle.getLength()); System.out.println(rectangle.getWidth()); &#125; public static void main(String[] args) &#123; Rectangle rectangle = new Rectangle(); rectangle.setLength(20); rectangle.setWidth(10); resize(rectangle); printLengthAndWidth(rectangle); System.out.println(&quot;============&quot;); Rectangle rectangle1 = new Square(); rectangle1.setLength(10); resize(rectangle1); printLengthAndWidth(rectangle1); &#125;&#125; 我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。 如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口 1.3 依赖倒转原则高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 下面看一个例子来理解依赖倒转原则 【例】组装电脑 现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。 类图如下： 根据依赖倒转原则进行改进： 代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。 类图如下： 1.4 接口隔离原则客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。 下面看一个例子来理解接口隔离原则 【例】安全门案例 我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下： 上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图： 1.5 迪米特法则迪米特法则又叫最少知识原则。 只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。 其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 下面看一个例子来理解迪米特法则 【例】明星与经纪人的关系实例 明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。 类图如下： 1.6 合成复用原则合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 通常类的复用分为继承复用和合成复用两种。 继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 对象间的耦合度低。可以在类的成员位置声明抽象。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 下面看一个例子来理解合成复用原则 【例】汽车分类管理程序 汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： 从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。 2.创建者模式创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。 这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。 创建型模式分为： 单例模式 工厂方法模式 抽象工程模式 原型模式 建造者模式 2.1 单例设计模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 2.1.1 单例模式的结构单例模式的主要有以下角色： 单例类。只能创建一个实例的类 访问类。使用单例类 2.1.2 单例模式的实现 单例设计模式分类两种： ​ 饿汉式：类加载就会导致该单实例对象被创建 ​ 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 饿汉式-方式1（静态变量方式） 12345678910111213141516/** * 饿汉式 * 静态变量创建类的对象 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 说明： ​ 该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2（静态代码块方式） 12345678910111213141516171819202122/** * 恶汉式 * 在静态代码块中创建该类对象 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; // 在静态代码块中进行赋值 static &#123; instance = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 说明： ​ 该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉式-方式1（线程不安全） 1234567891011121314151617181920/** * 懒汉式 * 线程不安全 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明： ​ 从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 懒汉式-方式2（线程安全） 1234567891011121314151617181920/** * 懒汉式 * 线程安全 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明： ​ 该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁） 再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 123456789101112131415161718192021222324/** * 双重检查方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) &#123; synchronized (Singleton.class) &#123; //抢到锁之后再次判断是否为null if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。 123456789101112131415161718192021222324/** * 双重检查方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) &#123; synchronized (Singleton.class) &#123; //抢到锁之后再次判断是否为空 if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 小结： 添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式） 静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。 1234567891011121314151617/** * 静态内部类方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 说明： ​ 第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。 小结： ​ 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式 枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 123456/** * 枚举方式 */public enum Singleton &#123; INSTANCE;&#125; 说明： ​ 枚举方式属于恶汉式方式。 2.2 工厂模式2.2.1 概述需求：设计一个咖啡店点餐系统。 设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。 具体类的设计如下： 在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。 在本教程中会介绍三种工厂的使用 简单工厂模式（不属于GOF的23种经典设计模式） 工厂方法模式 抽象工厂模式 2.2.2 简单工厂模式简单工厂不是一种设计模式，反而比较像是一种编程习惯。 2.2.2.1 结构简单工厂包含如下角色： 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 2.2.2.2 实现现在使用简单工厂对上面案例进行改进，类图如下： 工厂类代码如下： 123456789101112public class SimpleCoffeeFactory &#123; public Coffee createCoffee(String type) &#123; Coffee coffee = null; if(&quot;americano&quot;.equals(type)) &#123; coffee = new AmericanoCoffee(); &#125; else if(&quot;latte&quot;.equals(type)) &#123; coffee = new LatteCoffee(); &#125; return coffee; &#125;&#125; 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。 后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。 2.2.2.4 优缺点优点： 封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。 缺点： 增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。 2.2.2.3 扩展静态工厂 在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下： 123456789101112public class SimpleCoffeeFactory &#123; public static Coffee createCoffee(String type) &#123; Coffee coffee = null; if(&quot;americano&quot;.equals(type)) &#123; coffee = new AmericanoCoffee(); &#125; else if(&quot;latte&quot;.equals(type)) &#123; coffee = new LatteCoffee(); &#125; return coffe; &#125;&#125; 2.2.3 工厂方法模式针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。 2.2.3.1 概念定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。 2.2.3.2 结构工厂方法模式的主要角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 2.2.3.3 实现使用工厂方法模式对上例进行改进，类图如下： 代码如下： 抽象工厂： 1234public interface CoffeeFactory &#123; Coffee createCoffee();&#125; 具体工厂： 12345678910111213public class LatteCoffeeFactory implements CoffeeFactory &#123; public Coffee createCoffee() &#123; return new LatteCoffee(); &#125;&#125;public class AmericanCoffeeFactory implements CoffeeFactory &#123; public Coffee createCoffee() &#123; return new AmericanCoffee(); &#125;&#125; 咖啡店类： 123456789101112131415public class CoffeeStore &#123; private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) &#123; this.factory = factory; &#125; public Coffee orderCoffee(String type) &#123; Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; &#125;&#125; 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。 工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。 2.2.3.4 优缺点优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 2.2.4 抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。 这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。 2.2.2.1 概念是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 2.2.4.2 结构抽象工厂模式的主要角色如下： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 4.2.4.2 实现现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下： 代码如下： 抽象工厂： 123456public interface DessertFactory &#123; Coffee createCoffee(); Dessert createDessert();&#125; 具体工厂： 12345678910111213141516171819202122//美式甜点工厂public class AmericanDessertFactory implements DessertFactory &#123; public Coffee createCoffee() &#123; return new AmericanCoffee(); &#125; public Dessert createDessert() &#123; return new MatchaMousse(); &#125;&#125;//意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory &#123; public Coffee createCoffee() &#123; return new LatteCoffee(); &#125; public Dessert createDessert() &#123; return new Tiramisu(); &#125;&#125; 如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。 4.2.4.3 优缺点优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点： 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 4.2.4.4 使用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。 2.3 建造者模式2.3.1 概述将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 2.3.2 结构建造者（Builder）模式包含如下角色： 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完 成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 类图如下： 2.3.3 实例创建共享单车 生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。 这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下： 具体的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//自行车类public class Bike &#123; private String frame; private String seat; public String getFrame() &#123; return frame; &#125; public void setFrame(String frame) &#123; this.frame = frame; &#125; public String getSeat() &#123; return seat; &#125; public void setSeat(String seat) &#123; this.seat = seat; &#125;&#125;// 抽象 builder 类public abstract class Builder &#123; protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike();&#125;//摩拜单车Builder类public class MobikeBuilder extends Builder &#123; @Override public void buildFrame() &#123; mBike.setFrame(&quot;铝合金车架&quot;); &#125; @Override public void buildSeat() &#123; mBike.setSeat(&quot;真皮车座&quot;); &#125; @Override public Bike createBike() &#123; return mBike; &#125;&#125;//ofo单车Builder类public class OfoBuilder extends Builder &#123; @Override public void buildFrame() &#123; mBike.setFrame(&quot;碳纤维车架&quot;); &#125; @Override public void buildSeat() &#123; mBike.setSeat(&quot;橡胶车座&quot;); &#125; @Override public Bike createBike() &#123; return mBike; &#125;&#125;//指挥者类public class Director &#123; private Builder mBuilder; public Director(Builder builder) &#123; mBuilder = builder; &#125; public Bike construct() &#123; mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; showBike(new OfoBuilder()); showBike(new MobikeBuilder()); &#125; private static void showBike(Builder builder) &#123; Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); &#125;&#125; 注意： 上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合 123456789101112131415// 抽象 builder 类public abstract class Builder &#123; protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() &#123; this.buildFrame(); this.BuildSeat(); return this.createBike(); &#125;&#125; 说明： 这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。 2.3.4 优缺点优点： 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。 缺点： 造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 2.3.5 使用场景建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 2.3.6 模式扩展建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。 重构前代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Phone &#123; private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) &#123; this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; &#125; public String getCpu() &#123; return cpu; &#125; public void setCpu(String cpu) &#123; this.cpu = cpu; &#125; public String getScreen() &#123; return screen; &#125; public void setScreen(String screen) &#123; this.screen = screen; &#125; public String getMemory() &#123; return memory; &#125; public void setMemory(String memory) &#123; this.memory = memory; &#125; public String getMainboard() &#123; return mainboard; &#125; public void setMainboard(String mainboard) &#123; this.mainboard = mainboard; &#125; @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, screen=&#x27;&quot; + screen + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, mainboard=&#x27;&quot; + mainboard + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //构建Phone对象 Phone phone = new Phone(&quot;intel&quot;,&quot;三星屏幕&quot;,&quot;金士顿&quot;,&quot;华硕&quot;); System.out.println(phone); &#125;&#125; 上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。 重构后代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Phone &#123; private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) &#123; cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; &#125; public static final class Builder &#123; private String cpu; private String screen; private String memory; private String mainboard; public Builder() &#123;&#125; public Builder cpu(String val) &#123; cpu = val; return this; &#125; public Builder screen(String val) &#123; screen = val; return this; &#125; public Builder memory(String val) &#123; memory = val; return this; &#125; public Builder mainboard(String val) &#123; mainboard = val; return this; &#125; public Phone build() &#123; return new Phone(this);&#125; &#125; @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, screen=&#x27;&quot; + screen + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, mainboard=&#x27;&quot; + mainboard + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Phone phone = new Phone.Builder() .cpu(&quot;intel&quot;) .mainboard(&quot;华硕&quot;) .memory(&quot;金士顿&quot;) .screen(&quot;三星&quot;) .build(); System.out.println(phone); &#125;&#125; 重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。 4.6 创建者模式对比4.6.1 工厂方法模式VS建造者模式工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。 我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。 4.6.2 抽象工厂模式VS建造者模式抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 5.2 适配器模式5.2.1 概述如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。 定义： ​ 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 ​ 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 5.2.2 结构适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 5.2.3 类适配器模式实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 【例】读卡器 现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。 类图如下： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//SD卡的接口public interface SDCard &#123; //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg);&#125;//SD卡实现类public class SDCardImpl implements SDCard &#123; public String readSD() &#123; String msg = &quot;sd card read a msg :hello word SD&quot;; return msg; &#125; public void writeSD(String msg) &#123; System.out.println(&quot;sd card write msg : &quot; + msg); &#125;&#125;//电脑类public class Computer &#123; public String readSD(SDCard sdCard) &#123; if(sdCard == null) &#123; throw new NullPointerException(&quot;sd card null&quot;); &#125; return sdCard.readSD(); &#125;&#125;//TF卡接口public interface TFCard &#123; //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg);&#125;//TF卡实现类public class TFCardImpl implements TFCard &#123; public String readTF() &#123; String msg =&quot;tf card read msg : hello word tf card&quot;; return msg; &#125; public void writeTF(String msg) &#123; System.out.println(&quot;tf card write a msg : &quot; + msg); &#125;&#125;//定义适配器类（SD兼容TF）public class SDAdapterTF extends TFCardImpl implements SDCard &#123; public String readSD() &#123; System.out.println(&quot;adapter read tf card &quot;); return readTF(); &#125; public void writeSD(String msg) &#123; System.out.println(&quot;adapter write tf card&quot;); writeTF(msg); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); &#125;&#125; 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。 5.2.4 对象适配器模式实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 【例】读卡器 我们使用对象适配器模式将读卡器的案例进行改写。类图如下： 代码如下： 类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。 12345678910111213141516171819202122232425262728293031323334//创建适配器对象（SD兼容TF）public class SDAdapterTF implements SDCard &#123; private TFCard tfCard; public SDAdapterTF(TFCard tfCard) &#123; this.tfCard = tfCard; &#125; public String readSD() &#123; System.out.println(&quot;adapter read tf card &quot;); return tfCard.readTF(); &#125; public void writeSD(String msg) &#123; System.out.println(&quot;adapter write tf card&quot;); tfCard.writeTF(msg); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); &#125;&#125; 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。 5.2.5 应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 5.4 桥接模式5.4.1 概述现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系： 我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。 试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。 定义： ​ 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 5.4.2 结构桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 5.4.3 案例【例】视频播放器 需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//视频文件public interface VideoFile &#123; void decode(String fileName);&#125;//avi文件public class AVIFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;avi视频文件：&quot;+ fileName); &#125;&#125;//rmvb文件public class REVBBFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;rmvb文件：&quot; + fileName); &#125;&#125;//操作系统版本public abstract class OperatingSystemVersion &#123; protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) &#123; this.videoFile = videoFile; &#125; public abstract void play(String fileName);&#125;//Windows版本public class Windows extends OperatingSystem &#123; public Windows(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//mac版本public class Mac extends OperatingSystemVersion &#123; public Mac(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; OperatingSystem os = new Windows(new AVIFile()); os.play(&quot;战狼3&quot;); &#125;&#125; 好处： 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。 实现细节对客户透明 5.4.4 使用场景 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 5.5 外观模式5.5.1 概述有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。 定义： ​ 又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 ​ 外观（Facade）模式是“迪米特法则”的典型应用 5.5.2 结构外观（Facade）模式包含以下主要角色： 外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 5.5.3 案例【例】智能家电控制 小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//灯类public class Light &#123; public void on() &#123; System.out.println(&quot;打开了灯....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了灯....&quot;); &#125;&#125;//电视类public class TV &#123; public void on() &#123; System.out.println(&quot;打开了电视....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了电视....&quot;); &#125;&#125;//控制类public class AirCondition &#123; public void on() &#123; System.out.println(&quot;打开了空调....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了空调....&quot;); &#125;&#125;//智能音箱public class SmartAppliancesFacade &#123; private Light light; private TV tv; private AirCondition airCondition; public SmartAppliancesFacade() &#123; light = new Light(); tv = new TV(); airCondition = new AirCondition(); &#125; public void say(String message) &#123; if(message.contains(&quot;打开&quot;)) &#123; on(); &#125; else if(message.contains(&quot;关闭&quot;)) &#123; off(); &#125; else &#123; System.out.println(&quot;我还听不懂你说的！！！&quot;); &#125; &#125; //起床后一键开电器 private void on() &#123; System.out.println(&quot;起床了&quot;); light.on(); tv.on(); airCondition.on(); &#125; //睡觉一键关电器 private void off() &#123; System.out.println(&quot;睡觉了&quot;); light.off(); tv.off(); airCondition.off(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(&quot;打开家电&quot;); facade.say(&quot;关闭家电&quot;); &#125;&#125; 好处： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 缺点： 不符合开闭原则，修改很麻烦 5.5.4 使用场景 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 5，结构型模式5.6 组合模式5.6.1 概述 ​ 对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。 定义： ​ 又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 5.6.2 结构组合模式主要包含三种角色： 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 5.6.3 案例实现【例】软件菜单 如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。 要实现该案例，我们先画出类图： 代码实现： 不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。 123456789101112131415161718192021222324252627282930//菜单组件 不管是菜单还是菜单项，都应该继承该类public abstract class MenuComponent &#123; protected String name; protected int level; //添加菜单 public void add(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; //移除菜单 public void remove(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; //获取指定的子菜单 public MenuComponent getChild(int i)&#123; throw new UnsupportedOperationException(); &#125; //获取菜单名称 public String getName()&#123; return name; &#125; public void print()&#123; throw new UnsupportedOperationException(); &#125;&#125; 这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。 12345678910111213141516171819202122232425262728293031323334353637public class Menu extends MenuComponent &#123; private List&lt;MenuComponent&gt; menuComponentList; public Menu(String name,int level)&#123; this.level = level; this.name = name; menuComponentList = new ArrayList&lt;MenuComponent&gt;(); &#125; @Override public void add(MenuComponent menuComponent) &#123; menuComponentList.add(menuComponent); &#125; @Override public void remove(MenuComponent menuComponent) &#123; menuComponentList.remove(menuComponent); &#125; @Override public MenuComponent getChild(int i) &#123; return menuComponentList.get(i); &#125; @Override public void print() &#123; for (int i = 1; i &lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); for (MenuComponent menuComponent : menuComponentList) &#123; menuComponent.print(); &#125; &#125;&#125; Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。 123456789101112131415public class MenuItem extends MenuComponent &#123; public MenuItem(String name,int level) &#123; this.name = name; this.level = level; &#125; @Override public void print() &#123; for (int i = 1; i &lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); &#125;&#125; MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。 5.6.4 组合模式的分类在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。 透明组合模式 透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式 在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。 5.6.5 优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://breadwinners.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"Clion中远程连接Linux开发问题","slug":"Linux/Clion中远程连接Linux开发问题","date":"2023-03-17T16:00:00.000Z","updated":"2023-07-11T02:01:31.431Z","comments":true,"path":"2023/03/18/Linux/Clion中远程连接Linux开发问题/","link":"","permalink":"http://breadwinners.top/2023/03/18/Linux/Clion%E4%B8%AD%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"Clion中远程连接Linux开发问题远程连接远程主机设置-&gt;工具链-&gt;添加远程主机并设置为默认-&gt;配置好如下配置 相关Cmake，gdb，gcc安装升级可参考我这篇博客 部署到远程主机的对应工作目录：工具-&gt;部署-&gt;配置-&gt;选择远程主机-&gt;映射-&gt;添加好对应的工作目录 一个项目新建多个c&#x2F;cpp文件一个项目中新建多个文件，在CMakeLists.txt文件中添加，比如 1add_executable(test test.cpp) 第一项是期望生成的可执行文件的名字 第二项是你新建的文件名 注意：最好是先建立文件在修改CMakeLists.txt文件的内容，不然可能会提示不属于任何项目目标 链接thread运行带线程的程序因为pthread库不是Linux系统默认的库，所以需要在CMakeLists.txt文件中添加 12find_package(Threads REQUIRED)target_link_libraries(项目名称 Threads::Threads) 其中，target_link_libraries的第一个参数 项目名称 为 add_executable(项目名称 ${SOURCE_FILES}) 语句中的项目名 以上为例，test.cpp文件要链接pthread，就需要写成 target_link_libraries(test Threads::Threads) 我的CMakeLists.txt文件内容如下 1234567891011121314cmake_minimum_required(VERSION 3.6)project(thread)find_package(Threads REQUIRED)set(CMAKE_CXX_STANDARD 14)add_executable(thread main.cpp)add_executable(server server.cpp)add_executable(client client.cpp)add_executable(testThread1 testThread1.cpp)add_executable(hh hh.cpp)target_link_libraries(thread Threads::Threads)target_link_libraries(testThread1 Threads::Threads) Clion生成可执行文件的路径问题clion默认生成的可执行文件的位置与C&#x2F;C++源文件的位置不同，在某些涉及到相对路径问题的时候，就容易出错，所以有时候需要设置二者同一路径，只需在CMakeLists.txt中添加 1set(CMAKE_RUNTIME_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)# 设置可执行文件的输出路径 Clion带命令行参数运行 注意：要选择正确的可执行文件，比如我这里为mycp","categories":[{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"}],"tags":[{"name":"远程开发","slug":"远程开发","permalink":"http://breadwinners.top/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"}]},{"title":"centOS 7升级gcc，gdb","slug":"Linux/centOS 7升级gcc，gdb","date":"2023-03-17T16:00:00.000Z","updated":"2023-07-11T01:57:30.072Z","comments":true,"path":"2023/03/18/Linux/centOS 7升级gcc，gdb/","link":"","permalink":"http://breadwinners.top/2023/03/18/Linux/centOS%207%E5%8D%87%E7%BA%A7gcc%EF%BC%8Cgdb/","excerpt":"","text":"centOS 7升级gcc，gdbentOS自带的gcc为4.8版本，而使用yum也无法安装更高版本的gcc 获取gcc源代码 获取gcc源代码并上传至虚拟机 解压gcc 1[root@222 ~]# tar -xvf gcc-10.2.0.tar.gz 执行./configure/ 会报错，提示需要安装对应的依赖 123456789configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.Try the --with-gmp, --with-mpfr and/or --with-mpc options to specifytheir locations. Source code for these libraries can be found attheir respective hosting sites as well as atftp://gcc.gnu.org/pub/gcc/infrastructure/. See alsohttp://gcc.gnu.org/install/prerequisites.html for additional info. Ifyou obtained GMP, MPFR and/or MPC from a vendor distribution package,make sure that you have installed both the libraries and the headerfiles. They may be located in separate packages. 本文以MPC：1.0.3 mpfr：3.1.5 gmp：6.1.2安装gcc10.2.0，对应的源代码地址为： MPC : http://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz GMP : http://ftp.gnu.org/gnu/gmp/gmp-6.1.2.tar.xz MPFR : http://ftp.gnu.org/gnu/mpfr/mpfr-3.1.5.tar.gz 安装GMP1234[root@222 ~]# tar -xvf gmp-6.1.2.tar.gz[root@222 ]# cd gmp-6.1.2/[root@222 gmp-6.1.2]# ../gmp-6.1.2/configure --prefix=/usr/local/gmp-6.1.2[root@222 gmp-6.1.2]# make &amp;&amp; make install 安装MPFR1234[root@222 ~]# tar -xvf mpfr-3.1.5.tar.gz[root@222 ~]# cd mpfr-3.1.5/[root@222 mpfr-3.1.5]# ./configure --prefix=/usr/local/mpfr-3.1.5 --with-gmp=/usr/local/gmp-6.1.2[root@222 mpfr-3.1.5]# make &amp;&amp; make install 安装MPC1234[root@222 ~]# tar -xvf mpc-1.0.3.tar.gz[root@222 ~]# cd mpc-1.0.3/[root@222 mpc-1.0.3]# ./configure --prefix=/usr/local/mpc-1.0.3 --with-gmp=/usr/local/gmp-6.1.2--with-mpfr=/usr/local/mpfr-3.1.5[root@222 mpc-1.0.3]# make &amp;&amp; make install 安装gcc12345[root@222 ~]# cd gcc-10.2.0/[root@222 gcc-10.2.0]# mkdir tmp &amp;&amp; cd tmp[root@222 tmp]# ../configure --prefix=/usr/local/gcc-10.2.0/ --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-gmp=/usr/local/gmp-6.1.2 --with-mpfr=/usr/local/mpfr-3.1.5 --with-mpc=/usr/local/mpc-1.0.3[root@222 tmp]# make &amp;&amp; make install 注：最后gcc编译安装的时间很长，可能需要1-2个小时，建议在时间和网络允许的情况下进行 安装完成还需要执行如下命令： 12345678910mv /usr/bin/gcc /usr/bin/gcc485mv /usr/bin/g++ /usr/bin/g++485mv /usr/bin/c++ /usr/bin/c++485mv /usr/bin/cc /usr/bin/cc485ln -s /usr/local/gcc-10.2.0/bin/gcc /usr/bin/gccln -s /usr/local/gcc-10.2.0/bin/g++ /usr/bin/g++ln -s /usr/local/gcc-10.2.0/bin/c++ /usr/bin/c++ln -s /usr/local/gcc-10.2.0/bin/gcc /usr/bin/ccmv /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.bakln -s /usr/local/gcc-10.2.0/lib64/libstdc++.so.6.0.28 /usr/lib64/libstdc++.so.6 最后gcc -v 就可以发现gcc升级成功 中途报错可以查看这位大佬的文章 https://blog.csdn.net/Tsuki_jhsyi77/article/details/103111687 若本方法不行，也可以尝试这位大佬的方法 https://blog.csdn.net/b_ingram/article/details/121569398 gdb升级官网：https://gcc.gnu.org/下载镜像：https://gcc.gnu.org/mirrors.html速度比较好的下载镜像：ftp://mirrors.ustc.edu.cn/gnu/下载gdb-8.3.1.tar.gz;建议在安装gcc前，先装gdb的升级，gdb的升级不能用太高版本的gcc编绎，或者在编绎时指定低版本的gcc。本次成功编绎gdb的gcc版本是：gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)。相关命令如下：tar -xzvf gdb-8.3.1.tar.gzcd gdb-8.3.1如果需要指定编绎的gcc版本，可以用以CC指定具体的gcc，如下面的&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;gcc就是gcc的安装目录：CC&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;gcc .&#x2F;configure否则可以直接编绎:.&#x2F;configuremakemake install在安装前系统需要安装texinfo：yum install texinfo如果之前系统没有安装gcc，先执行：yum install gccyum install gcc-c++ cmake升级https://blog.csdn.net/qq_19734597/article/details/104200371","categories":[{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://breadwinners.top/tags/centos/"},{"name":"gcc","slug":"gcc","permalink":"http://breadwinners.top/tags/gcc/"},{"name":"gdb","slug":"gdb","permalink":"http://breadwinners.top/tags/gdb/"}]},{"title":"Markdown Style test","slug":"markdown","date":"2018-07-24T15:31:06.000Z","updated":"2023-05-02T16:18:22.929Z","comments":true,"path":"2018/07/24/markdown/","link":"","permalink":"http://breadwinners.top/2018/07/24/markdown/","excerpt":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","text":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://breadwinners.top/tags/test/"}]},{"title":"Tag Plugins","slug":"tag-plugins","date":"2013-12-24T16:14:39.000Z","updated":"2023-04-30T06:59:49.462Z","comments":true,"path":"2013/12/25/tag-plugins/","link":"","permalink":"http://breadwinners.top/2013/12/25/tag-plugins/","excerpt":"","text":"This post is used for testing tag plugins. See docs for more info. Block QuoteNormal blockquote Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna. Quote from a bookDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Quote from TwitterNEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Quote from an article on the webEvery interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing Code BlockNormal code block1alert(&#x27;Hello World!&#x27;); With captionArray.map1array.map(callback[, thisArg]) With caption and URL.compactUnderscore.js12.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] With marked linesLine 1,7-8,10 should be marked with different color. 1234567891011const http = require(&#x27;http&#x27;);const hostname = &#x27;127.0.0.1&#x27;;const port = 1337;http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;); res.end(&#x27;Hello World\\n&#x27;);&#125;).listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); Note: Theme’s style should support .highlight.line.marked (recommend to use the selection or current line color). Gist jsFiddle PullquoteLeftLorem ipsum dolor sit amet, consectetur adipiscing elit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac. RightLorem ipsum dolor sit amet, consectetur adipiscing elit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.","categories":[],"tags":[]},{"title":"sufingkeys常用使用说明","slug":"sufingkeys常用使用说明","date":"2013-12-24T15:30:09.000Z","updated":"2023-04-30T15:56:48.626Z","comments":true,"path":"2013/12/24/sufingkeys常用使用说明/","link":"","permalink":"http://breadwinners.top/2013/12/24/sufingkeys%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"normal模式 插入模式 j 向下混动 k 向上滚动 h 向左滚动 l 向右滚动 gg 定位到顶部 G 定位到底部 空格 快速翻页 &#x2F; 搜索页面内容 Ctrl+L Alt+d 光标定位到地址栏 gi 光标定位到搜索框 gf 在新标签页后台打开链接 f 展示页面中所有可以点击的链接，输入相应的字母回车进行跳转 x 关闭当前标签 X 恢复上一个关闭的标签 E 跳到左侧标签 R 跳到右侧标签 yt 复制当前标签页 yy 复制当前地址 yg 截屏 T 快速切换标签 b 搜索书签打开 n 下一处 N 上一处 on 打开新标签 zi 放大 zo 缩小 oh 打开搜索栏查找访问历史 ob 打开百度搜索栏og 打开谷歌搜索栏ow 打开必应搜索栏 sg 用谷歌搜索选中文本 sb 用百度搜索选中文本 sw 用必应搜索选中文本 ss 用stackoverflow搜索选中文本 sh 用github搜索选中文本 gd 打开下载 gh 打开历史记录 cc 打开选中的网址或系统剪贴板里的网址 了解vim的编辑方式 某些网站禁用surfingkeys Alt + s surfingkeys Blacklist","categories":[{"name":"use","slug":"use","permalink":"http://breadwinners.top/categories/use/"}],"tags":[{"name":"浏览器插件","slug":"浏览器插件","permalink":"http://breadwinners.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]}],"categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://breadwinners.top/categories/pytorch/"},{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"小土堆pytorch","slug":"小土堆pytorch","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch/"},{"name":"小土堆pytorch## transform","slug":"小土堆pytorch-transform","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch-transform/"},{"name":"吴恩达机器学习","slug":"吴恩达机器学习","permalink":"http://breadwinners.top/categories/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"},{"name":"numpy","slug":"numpy","permalink":"http://breadwinners.top/categories/numpy/"},{"name":"pandas","slug":"pandas","permalink":"http://breadwinners.top/categories/pandas/"},{"name":"Python","slug":"Python","permalink":"http://breadwinners.top/categories/Python/"},{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/categories/bugs/"},{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/"},{"name":"算法","slug":"论文/算法","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/%E7%AE%97%E6%B3%95/"},{"name":"分类","slug":"分类","permalink":"http://breadwinners.top/categories/%E5%88%86%E7%B1%BB/"},{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"},{"name":"设计模式","slug":"设计模式","permalink":"http://breadwinners.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"use","slug":"use","permalink":"http://breadwinners.top/categories/use/"}],"tags":[{"name":"Weights.IMAGENET1K_V1","slug":"Weights-IMAGENET1K-V1","permalink":"http://breadwinners.top/tags/Weights-IMAGENET1K-V1/"},{"name":"_conda","slug":"conda","permalink":"http://breadwinners.top/tags/conda/"},{"name":"监督学习","slug":"监督学习","permalink":"http://breadwinners.top/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"非监督学习","slug":"非监督学习","permalink":"http://breadwinners.top/tags/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"决策树","slug":"决策树","permalink":"http://breadwinners.top/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"cnn","slug":"cnn","permalink":"http://breadwinners.top/tags/cnn/"},{"name":"GoogleNet","slug":"GoogleNet","permalink":"http://breadwinners.top/tags/GoogleNet/"},{"name":"Inception Module","slug":"Inception-Module","permalink":"http://breadwinners.top/tags/Inception-Module/"},{"name":"梯度消失","slug":"梯度消失","permalink":"http://breadwinners.top/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"},{"name":"Residual Network","slug":"Residual-Network","permalink":"http://breadwinners.top/tags/Residual-Network/"},{"name":"hidden","slug":"hidden","permalink":"http://breadwinners.top/tags/hidden/"},{"name":"rnn","slug":"rnn","permalink":"http://breadwinners.top/tags/rnn/"},{"name":"Nvidia","slug":"Nvidia","permalink":"http://breadwinners.top/tags/Nvidia/"},{"name":"cuda","slug":"cuda","permalink":"http://breadwinners.top/tags/cuda/"},{"name":"cuda12.2","slug":"cuda12-2","permalink":"http://breadwinners.top/tags/cuda12-2/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"http://breadwinners.top/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"lsbsk","slug":"lsbsk","permalink":"http://breadwinners.top/tags/lsbsk/"},{"name":"梯度下降","slug":"梯度下降","permalink":"http://breadwinners.top/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"},{"name":"随机梯度下降","slug":"随机梯度下降","permalink":"http://breadwinners.top/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"},{"name":"titanic","slug":"titanic","permalink":"http://breadwinners.top/tags/titanic/"},{"name":"多维度特征","slug":"多维度特征","permalink":"http://breadwinners.top/tags/%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%89%B9%E5%BE%81/"},{"name":"多分类","slug":"多分类","permalink":"http://breadwinners.top/tags/%E5%A4%9A%E5%88%86%E7%B1%BB/"},{"name":"softmax","slug":"softmax","permalink":"http://breadwinners.top/tags/softmax/"},{"name":"ontHot","slug":"ontHot","permalink":"http://breadwinners.top/tags/ontHot/"},{"name":"Linear","slug":"Linear","permalink":"http://breadwinners.top/tags/Linear/"},{"name":"反向传播","slug":"反向传播","permalink":"http://breadwinners.top/tags/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"},{"name":"DataLoader","slug":"DataLoader","permalink":"http://breadwinners.top/tags/DataLoader/"},{"name":"datasets","slug":"datasets","permalink":"http://breadwinners.top/tags/datasets/"},{"name":"科大未来","slug":"科大未来","permalink":"http://breadwinners.top/tags/%E7%A7%91%E5%A4%A7%E6%9C%AA%E6%9D%A5/"},{"name":"axis","slug":"axis","permalink":"http://breadwinners.top/tags/axis/"},{"name":"shape()","slug":"shape","permalink":"http://breadwinners.top/tags/shape/"},{"name":"frp","slug":"frp","permalink":"http://breadwinners.top/tags/frp/"},{"name":"maven","slug":"maven","permalink":"http://breadwinners.top/tags/maven/"},{"name":"打包依赖","slug":"打包依赖","permalink":"http://breadwinners.top/tags/%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/"},{"name":"wsl","slug":"wsl","permalink":"http://breadwinners.top/tags/wsl/"},{"name":"wsl2","slug":"wsl2","permalink":"http://breadwinners.top/tags/wsl2/"},{"name":"flume","slug":"flume","permalink":"http://breadwinners.top/tags/flume/"},{"name":"spark","slug":"spark","permalink":"http://breadwinners.top/tags/spark/"},{"name":"sbt","slug":"sbt","permalink":"http://breadwinners.top/tags/sbt/"},{"name":"bin目录","slug":"bin目录","permalink":"http://breadwinners.top/tags/bin%E7%9B%AE%E5%BD%95/"},{"name":".bashrc","slug":"bashrc","permalink":"http://breadwinners.top/tags/bashrc/"},{"name":"redis","slug":"redis","permalink":"http://breadwinners.top/tags/redis/"},{"name":"静态ip","slug":"静态ip","permalink":"http://breadwinners.top/tags/%E9%9D%99%E6%80%81ip/"},{"name":"picgo","slug":"picgo","permalink":"http://breadwinners.top/tags/picgo/"},{"name":"nginx","slug":"nginx","permalink":"http://breadwinners.top/tags/nginx/"},{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/tags/%E8%AE%BA%E6%96%87/"},{"name":"mysql","slug":"mysql","permalink":"http://breadwinners.top/tags/mysql/"},{"name":"bash-4.2$","slug":"bash-4-2","permalink":"http://breadwinners.top/tags/bash-4-2/"},{"name":"标签名","slug":"标签名","permalink":"http://breadwinners.top/tags/%E6%A0%87%E7%AD%BE%E5%90%8D/"},{"name":"数论","slug":"数论","permalink":"http://breadwinners.top/tags/%E6%95%B0%E8%AE%BA/"},{"name":"不能凑出的最大整数","slug":"不能凑出的最大整数","permalink":"http://breadwinners.top/tags/%E4%B8%8D%E8%83%BD%E5%87%91%E5%87%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"},{"name":"DP","slug":"DP","permalink":"http://breadwinners.top/tags/DP/"},{"name":"离散化","slug":"离散化","permalink":"http://breadwinners.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"手写堆","slug":"手写堆","permalink":"http://breadwinners.top/tags/%E6%89%8B%E5%86%99%E5%A0%86/"},{"name":"dfs","slug":"dfs","permalink":"http://breadwinners.top/tags/dfs/"},{"name":"图论","slug":"图论","permalink":"http://breadwinners.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"graph","slug":"graph","permalink":"http://breadwinners.top/tags/graph/"},{"name":"bfs","slug":"bfs","permalink":"http://breadwinners.top/tags/bfs/"},{"name":"前缀和","slug":"前缀和","permalink":"http://breadwinners.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"http://breadwinners.top/tags/%E5%B7%AE%E5%88%86/"},{"name":"连通块","slug":"连通块","permalink":"http://breadwinners.top/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"greedy","slug":"greedy","permalink":"http://breadwinners.top/tags/greedy/"},{"name":"暴力","slug":"暴力","permalink":"http://breadwinners.top/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"模拟","slug":"模拟","permalink":"http://breadwinners.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"sort","slug":"sort","permalink":"http://breadwinners.top/tags/sort/"},{"name":"数组单链表","slug":"数组单链表","permalink":"http://breadwinners.top/tags/%E6%95%B0%E7%BB%84%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://breadwinners.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"Trie","slug":"Trie","permalink":"http://breadwinners.top/tags/Trie/"},{"name":"贪心","slug":"贪心","permalink":"http://breadwinners.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"heap","slug":"heap","permalink":"http://breadwinners.top/tags/heap/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://breadwinners.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/tags/bugs/"},{"name":"STL","slug":"STL","permalink":"http://breadwinners.top/tags/STL/"},{"name":"HashMap","slug":"HashMap","permalink":"http://breadwinners.top/tags/HashMap/"},{"name":"双指针","slug":"双指针","permalink":"http://breadwinners.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"quick","slug":"quick","permalink":"http://breadwinners.top/tags/quick/"},{"name":"kmp","slug":"kmp","permalink":"http://breadwinners.top/tags/kmp/"},{"name":"二分","slug":"二分","permalink":"http://breadwinners.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"cin","slug":"cin","permalink":"http://breadwinners.top/tags/cin/"},{"name":"cout","slug":"cout","permalink":"http://breadwinners.top/tags/cout/"},{"name":"su","slug":"su","permalink":"http://breadwinners.top/tags/su/"},{"name":"sudo","slug":"sudo","permalink":"http://breadwinners.top/tags/sudo/"},{"name":"容器","slug":"容器","permalink":"http://breadwinners.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"远程开发","slug":"远程开发","permalink":"http://breadwinners.top/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"centos","slug":"centos","permalink":"http://breadwinners.top/tags/centos/"},{"name":"gcc","slug":"gcc","permalink":"http://breadwinners.top/tags/gcc/"},{"name":"gdb","slug":"gdb","permalink":"http://breadwinners.top/tags/gdb/"},{"name":"test","slug":"test","permalink":"http://breadwinners.top/tags/test/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"http://breadwinners.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]}