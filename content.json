{"meta":{"title":"怒涛卷霜雪  天堑无涯","subtitle":"","description":"test description","author":"吴涛","url":"http://breadwinners.top","root":"/"},"pages":[{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-04-30T06:59:49.463Z","comments":true,"path":"page/index.html","permalink":"http://breadwinners.top/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2023-04-30T08:10:36.359Z","updated":"2023-04-30T08:10:36.359Z","comments":true,"path":"tags/index.html","permalink":"http://breadwinners.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-30T08:10:03.888Z","updated":"2023-04-30T08:10:03.888Z","comments":true,"path":"about/index.html","permalink":"http://breadwinners.top/about/index.html","excerpt":"","text":"一名小小大学生的小博客"},{"title":"我的朋友们","date":"2023-04-30T08:10:52.817Z","updated":"2023-04-30T08:10:52.817Z","comments":true,"path":"friends/index.html","permalink":"http://breadwinners.top/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2023-04-30T08:10:22.183Z","updated":"2023-04-30T08:10:22.183Z","comments":true,"path":"categories/index.html","permalink":"http://breadwinners.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"maven带依赖打包","slug":"maven带依赖打包","date":"2023-05-31T16:00:00.000Z","updated":"2023-06-12T01:59:20.628Z","comments":true,"path":"2023/06/01/maven带依赖打包/","link":"","permalink":"http://breadwinners.top/2023/06/01/maven%E5%B8%A6%E4%BE%9D%E8%B5%96%E6%89%93%E5%8C%85/","excerpt":"","text":"当你需要在某个环境下使用 java -jar xxx.jar的命令运行jar包程序，而且该jar包又需要引用其他程序依赖的时候，就可以采用以下的方法。 添加依赖 12345678910111213141516171819&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.xxx.xxx.xxx&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 运行生成的带依赖的jar就行了 java -jar ...","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://breadwinners.top/tags/maven/"},{"name":"打包依赖","slug":"打包依赖","permalink":"http://breadwinners.top/tags/%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/"}]},{"title":"windows安装WSL","slug":"WSL2","date":"2023-05-27T16:00:00.000Z","updated":"2023-07-11T02:19:39.651Z","comments":true,"path":"2023/05/28/WSL2/","link":"","permalink":"http://breadwinners.top/2023/05/28/WSL2/","excerpt":"","text":"Windows下安装wsl 开启系统的一下设置 虚拟化设置 系统设置 ​ 控制面板-&gt;程序-&gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)以及Hyper-V ​ 勾选完成后，Windows11 会自己下载些东西，并提示你重启。等电脑彻底重启完以后，进行后续操作 打开Power Shell 以管理员身份输入下方代码： bcdedit /set hypervisorlaunchtype auto 安装Ubuntu ​ 微软商店太慢了，这里推荐另一种好方法 ​ 1. 打开Microsoft Store的网页版https://apps.microsoft.com/store/apps ​ 搜索你想要的应用，比如ubuntu 选择一个 复制链接 打开网站https://store.rg-adguard.net，专门下载Microsoft Store上的应用 输入你刚才复制的要下载的应用链接，搜索 在结果里面找到想要的应用，有些文件的名称里面会有平台，比如x64，x86，arm64等等，根据自己电脑的平台下载，注意选择后缀为.appx或者.AppxBundle的下载，.EAppxBundle只适用于Windows Xbox平台。 等待下载完成后 下载完之后进入你的下载目录，运行命令： 1Add-AppxPackage .\\CanonicalGroupLimited.Ubuntu22.04LTS_2204.2.47.0_neutral_~_79rhkp1fndgsc.AppxBundle PS：Add-AppxPackage是power shell命令，在cmd中必须线输入powershell才能继续运行 启动Ubuntu ​ 直接点击ubuntu图标启动 ​ PS：Windows11 WSL 打开Ubuntu 报错 WslRegisterDistribution failed with error: 0x800701bc 这个是需要下载适用于 x64 计算机的 WSL2 Linux 内核更新包： https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 安装升级后，重新打开 Ubuntu，即可正常访问，效果如下： 修改root用户密码 WSL 默认是没有设置 root 密码的 设置 root 用户密码, 这样要输三次命令, 第一次当前用户密码, 后两次就是设置密码以及确认密码 1sudo passwd root 设置默认用户 查看命令 1ubuntu2204 /? 2. 设置默认登录用户 1ubuntu2204 config --default-user root 重新启动查看结果 ![image-20230602125308631](https://tt-1316429231.cos.ap-nanjing.myqcloud.com/imgs/linux/202306021253674.png)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://breadwinners.top/tags/wsl/"},{"name":"wsl2","slug":"wsl2","permalink":"http://breadwinners.top/tags/wsl2/"}]},{"title":"flume 运行时报NoSuchMethodError com.google.common.base.Preconditions.checkArgument","slug":"flume 运行时报NoSuchMethodError","date":"2023-05-25T16:00:00.000Z","updated":"2023-06-28T14:55:13.349Z","comments":true,"path":"2023/05/26/flume 运行时报NoSuchMethodError/","link":"","permalink":"http://breadwinners.top/2023/05/26/flume%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8A%A5NoSuchMethodError/","excerpt":"","text":"1、遇到问题今天在配置好flume，在运行flume时报了以下错误。 12023-05-26 16:39:56,359 (SinkRunner-PollingRunner-DefaultSinkProcessor) [ERROR - org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:459)] process failedjava.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.conf.Configuration.setBoolean(Configuration.java:1679) at org.apache.flume.sink.hdfs.BucketWriter.open(BucketWriter.java:221) at org.apache.flume.sink.hdfs.BucketWriter.append(BucketWriter.java:572) at org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:412) at org.apache.flume.sink.DefaultSinkProcessor.process(DefaultSinkProcessor.java:67) at org.apache.flume.SinkRunner$PollingRunner.run(SinkRunner.java:145) at java.lang.Thread.run(Thread.java:748)Exception in thread &quot;SinkRunner-PollingRunner-DefaultSinkProcessor&quot; java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.conf.Configuration.setBoolean(Configuration.java:1679) at org.apache.flume.sink.hdfs.BucketWriter.open(BucketWriter.java:221) at org.apache.flume.sink.hdfs.BucketWriter.append(BucketWriter.java:572) at org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:412) at org.apache.flume.sink.DefaultSinkProcessor.process(DefaultSinkProcessor.java:67) at org.apache.flume.SinkRunner$PollingRunner.run(SinkRunner.java:145) at java.lang.Thread.run(Thread.java:748) 2、解决问题 遇到这种问题，无非两种情况，一是 丢失jar包，二是 jar包冲突。 由于对hadoop以及flume版本选择比较随意。猜测是jar包存在冲突。找到报错的类 com.google.common.base.Preconditions ，通过查询 该类存在 guava jar包中。flume的lib中 &#x2F;opt&#x2F;flume&#x2F;apache-flume-1.9.0-bin&#x2F;lib （guava-11.0.2.jar）而 hadoop 的 lib 中 &#x2F;opt&#x2F;hadoop&#x2F;hadoop-3.2.1&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib&#x2F; （guava-27.0-jre.jar），删除版本低的，并拷贝高版本的。 问题解决。 Google Guava","categories":[{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"flume","slug":"flume","permalink":"http://breadwinners.top/tags/flume/"}]},{"title":"Linux中的各种bin目录","slug":"Linux中的各种bin目录","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-31T11:16:43.747Z","comments":true,"path":"2023/05/25/Linux中的各种bin目录/","link":"","permalink":"http://breadwinners.top/2023/05/25/Linux%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Dbin%E7%9B%AE%E5%BD%95/","excerpt":"","text":"usr实际上是Unix System Resource /usr/bin系统预装的一些可执行程序，随系统升级会改变 /usr/local/bin用户安装的可执行程序，不受系统升级影响，用户编译安装软件时，一般放到&#x2F;usr&#x2F;local目录下 如果两个目录下有相同的可执行程序，谁优先执行会受到PATH环境变量的影响，举个栗子：echo $PATH查看当前 PATH 环境变量/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/.local/bin:/root/bin:/usr/local/src/nodejs/bin:/usr/local/git/bin:/usr/bin/git/bin这里/usr/local/git/bin优先于 /usr/bin/git/bin /bin 存放所有用户皆可用的系统程序，系统启动或者系统修复时可用（在没有挂载 &#x2F;usr 目录时就可以使用） /sbin 存放超级用户才能使用的系统程序 /usr/bin 存放所有用户都可用的应用程序 /usr/sbin 存放超级用户才能使用的应用程序 /usr/local/bin 存放所有用户都可用的与本地机器无关的程序 /usr/local/sbin 存放超级用户才能使用的与本地机器无关的程序 Linux中的某些重要的目录： •主目录：/root、/home/username •用户可执行文件：/bin、/usr/bin、/usr/local/bin •系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin •其他挂载点：/media、/mnt •配置：/etc •临时文件：/tmp •内核和Bootloader：/boot •服务器数据：/var、/srv •系统信息：/proc、/sys •共享库：/lib、/usr/lib、/usr/local/lib","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"bin目录","slug":"bin目录","permalink":"http://breadwinners.top/tags/bin%E7%9B%AE%E5%BD%95/"}]},{"title":".bashrc和profile和profile.d与配置环境变量","slug":"profile和.bashrc和profile.d","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-31T10:56:30.566Z","comments":true,"path":"2023/05/25/profile和.bashrc和profile.d/","link":"","permalink":"http://breadwinners.top/2023/05/25/profile%E5%92%8C.bashrc%E5%92%8Cprofile.d/","excerpt":"","text":".bashrc 文件详解位置： 系统级的位于/etc/bashrc，对所有用户生效。 用户级的位于~/.bashrc或者/home/用户名/.bashrc，仅对当前用户生效。 作用： bash 提示符允许你自定义你的终端，并让它在你运行命令时显示提示。自定义的 bash 提示符着实能提高你在终端的工作效率。 给命令起别名： 1alias catt=&quot;cat -n&quot; 使多个命令可以组合使用 1234md () &#123;mkdir -p $1cd $1&#125; 变动 bashrc 是非常直接且低风险的。即使你一不小心全搞砸了，你也可以随时删掉 bashrc 文件然后重新来一遍。 profile位置： 系统级的位于/etc/profile，用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。 用户级的位于~/.bash_profile，用于设置用户级的环境变量和启动程序，在这个文件下配置会对单个用户生效。 当用户登录（login）时，文件会被执行，并从/etc/profile.d目录的配置文件中查找shell设置。 在profile中设置环境变量一般不建议在**/etc/profile**文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。 一般在/etc/profile.d中添加环境变量 /etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用像/etc/profile需要改动此文件 当添加环境变量时，我们可以按以下方式添加： 1234567891011下面以jdk的安装为例vim /etc/profile.d/java.sh在新的java.sh中输入以下内容：#set java environmentJAVA_HOME=/opt/module/jdk1.8.0_212PATH=＄JAVA_HOME/bin:＄PATHexport JAVA_HOME PATH 12345#JAVA_HOME是一个环境变量，用于指定Java的安装目录export JAVA_HOME=/opt/module/jdk1.8.0_212是一个命令，用于设置JAVA_HOME的值为/opt/module/jdk1.8.0_212，也就是Java的安装目录export PATH=$PATH:$JAVA_HOME/bin是一个命令，用于将$JAVA_HOME/bin添加到PATH环境变量中，这样就可以在任何目录下执行Java的可执行程序，如java和javac 添加时，可以在行尾使用;号，也可以不使用。 一个变量名可以对应多个变量值，多个变量值需要使用:进行分隔。 添加环境变量后，需要重新登录才能生效，也可以使用 source 命令刷新立即生效： 1source /etc/profile 查看是否生效可以使用 echo 命令： 12echo $JAVA_HOME/opt/module/jdk1.8.0_212 差异/etc/profile，/etc/bashrc 是系统全局环境变量设定； ~/.profile，~/.bashrc用户家目录下的私有环境变量设定。 当登入系统时候获得一个 shell 进程时，其读取环境设定档如下： 首先读入全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如/etc/profile.d和/etc/inputrc； 根据不同使用者帐号，于其家目录内读取~/.bash_profile； 读取失败则会读取~/.bash_login； 再次失败则读取~/.profile（这三个文档设定基本上无差别，仅读取上有优先关系）； 最后，根据用户帐号读取~/.bashrc。 至于~/.profile与~/.bashrc都具有个性化定制功能，但~/.profile可以设定本用户专有的路径、环境变量等，它只能登入的时候执行一次。 ~/.bashrc也是某用户专有设定文档，可以设定路径、命令别名，每次 shell script 的执行都会使用它一次。 设置程序为任意目录可以执行 可以像上文配置java环境变量一样配置 在/usr/bin或者~/bin目录下写shell脚本，指向需要执行的文件 记得source","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":".bashrc","slug":"bashrc","permalink":"http://breadwinners.top/tags/bashrc/"}]},{"title":"Spark安装部署","slug":"Spark安装部署","date":"2023-05-24T16:00:00.000Z","updated":"2023-06-01T07:08:13.866Z","comments":true,"path":"2023/05/25/Spark安装部署/","link":"","permalink":"http://breadwinners.top/2023/05/25/Spark%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"1.安装Spark将文件上传到&#x2F;opt&#x2F;module&#x2F;，解压并重命名 123wget https://archive.apache.org/dist/spark/spark-3.0.0/spark-3.0.0-bin-hadoop3.2.tgztar -zxvf spark-3.0.0-bin-hadoop3.2.tgzmv spark-3.0.0-bin-hadoop3.2 spark-3.0.0 2.编辑slaves和spark-env.sh文件123cd /opt/module/spark-3.0.0/conf/mv slaves.template slavesmv spark-env.sh.template spark-env.sh 1vi slaves 在文件中添加集群的主机名称 123hadoop102hadoop103hadoop104 1vi spark-env.sh 12导入java地址export JAVA_HOME=/home/jdk1.8.0_77 添加环境变量 1vi /etc/profile 12export SPARK_HOME=/opt/module/spark-3.0.0export PATH=$PATH:$SPARK_HOME/sbin:$SPARK_HOME/bin 每台虚拟机都需要配置 3.分发Spark1xsync /opt/module/spark-3.0.0 4.启动Spark启动spark前需先启动hadoop集群 123cd /opt/module/spark-3.0.0/sbin/start-all.sh jpsall 查看各节点进程：主节点:从节点：浏览器访问web页面：主机名:8080 ok!!","categories":[{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://breadwinners.top/tags/spark/"}]},{"title":"Spark安装sbt","slug":"spark安装sbt","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-31T11:32:43.087Z","comments":true,"path":"2023/05/25/spark安装sbt/","link":"","permalink":"http://breadwinners.top/2023/05/25/spark%E5%AE%89%E8%A3%85sbt/","excerpt":"","text":"Spark中没有自带sbt，需要[手动安装sbt，我的方法是下载sbt-launch.jar，然后将源改为国内源（aliyun），我选择将sbt安装在&#x2F;usr&#x2F;local&#x2F;sbt中。1234sudo mkdir /usr/local/sbtsudo chown -R hadoop /usr/local/sbt #username is hadoop.cd /usr/local/sbtmkdir sbtlaunch #store sbt-launch.jar 1.下载sbt-launch.jar,并存放至&#x2F;usr&#x2F;local&#x2F;sbt&#x2F;sbtlaunch123cd /usr/local/sbt/sbtlaunchwget https://repo.typesafe.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.13.9/sbt-launch.jar -O ./sbt-launch.jar #download sbt-launch.jarunzip -q ./sbt-launch.jar #解压 2.需要修改其中的.&#x2F;sbt&#x2F;sbt.boot.properties文件,将[repositories]处修改为如下内容：即增加一条aliyun-nexus的镜像。12cd /usr/local/sbt/sbtlaunchvim ./sbt/sbt.boot.properties 修改为如下123456[repositories] local aliyun-nexus: http://maven.aliyun.com/nexus/content/groups/public/ jcenter: https://jcenter.bintray.com/ typesafe-ivy-releases: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly maven-central 3.删除原来的sbt-launch.文件，然后重新打包12rm ./sbt-launch.jar #delete the old jarjar -cfM ./sbt-launch.jar . #create new jar 4.在&#x2F;usr&#x2F;local&#x2F;sbt目录下创建sbt脚本文件并赋予可执行权限，来执行sbt-launch.jar12cd /usr/lcoal/sbtvim ./sbt #create sbt script 添加如下内容:12SBT_OPTS=&quot;-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M&quot;java $SBT_OPTS -jar `dirname`/sbt-launch.jar &quot;$@&quot; #dirname为路径名 my dirname ： &#x2F;usr&#x2F;local&#x2F;sbt&#x2F;sbtlaunch5.保存后，为.&#x2F;sbt增加可执行权限:1chmod u+x ./sbt 6.最后检验sbt是否可用1./sbt sbt-version 这一步请耐心等待 参考链接：https://blog.csdn.net/microsoft2014/article/details/54572502","categories":[{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://breadwinners.top/tags/spark/"},{"name":"sbt","slug":"sbt","permalink":"http://breadwinners.top/tags/sbt/"}]},{"title":"CentOs7安装Redis","slug":"linux安装redis","date":"2023-05-22T16:00:00.000Z","updated":"2023-05-23T14:30:39.812Z","comments":true,"path":"2023/05/23/linux安装redis/","link":"","permalink":"http://breadwinners.top/2023/05/23/linux%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"前提条件：Linux装有gcc编译器 ###1. 官网下载redis 1wget http://download.redis.io/releases/redis-5.0.14.tar.gz 2. 安装解压： 123tar -xzvf redis-5.0.14.tar.gzcd redis-5.0.14make PREFIX=/usr/local/redis install //安装 3.使用12redis-server // 启动redis-cli // 连接 输入ping 输出为： 代表安装成功 4.Java远程连接使用需要关闭redis的防远程连接，否则会报错redis运行在protected模式下 找到redis.conf文件 ​ 找到bind 127.0.0.1，注释掉 连接上redis后，输入config get daemonize和config get protected-mode 都修改为no 12config set daemonize noconfig set protected-mode no 在pom文件中添加redis的相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 实验操作部分： 123456789101112131415161718package redis;import java.util.Map;import redis.clients.jedis.Jedis;public class Redis1 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;hadoop102&quot;, 6379); jedis.hset(&quot;student.scofield&quot;, &quot;English&quot;, &quot;45&quot;); jedis.hset(&quot;student.scofield&quot;, &quot;Math&quot;, &quot;89&quot;); jedis.hset(&quot;student.scofield&quot;, &quot;Computer&quot;, &quot;100&quot;); Map&lt;String, String&gt; value = jedis.hgetAll(&quot;student.scofield&quot;); for (Map.Entry&lt;String, String&gt; entry : value.entrySet()) &#123; System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); &#125; &#125;&#125; 12345678910111213package redis;import redis.clients.jedis.Jedis;public class Redis2 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;hadoop102&quot;, 6379); String value = jedis.hget(&quot;student.scofield&quot;, &quot;English&quot;); System.out.println(&quot;scofield&#x27;s English score is: &quot; + value); &#125;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://breadwinners.top/tags/redis/"}]},{"title":"centos设置静态IP","slug":"centos设定静态IP","date":"2023-05-15T16:00:00.000Z","updated":"2023-06-23T08:24:07.367Z","comments":true,"path":"2023/05/16/centos设定静态IP/","link":"","permalink":"http://breadwinners.top/2023/05/16/centos%E8%AE%BE%E5%AE%9A%E9%9D%99%E6%80%81IP/","excerpt":"","text":"配置网卡 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 根据情况输入以下内容 123456789101112131415161718192021TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;46cddd88-b100-416c-ab9c-5c19f1e3a7ef&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=192.168.153.102GATEWAY=192.168.153.2DNS1=114.114.114.114NETMASK=255.255.255.0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"静态ip","slug":"静态ip","permalink":"http://breadwinners.top/tags/%E9%9D%99%E6%80%81ip/"}]},{"title":"typora+picgo上传图片报错","slug":"typora+picgo图床","date":"2023-05-09T16:00:00.000Z","updated":"2023-05-22T11:42:43.017Z","comments":true,"path":"2023/05/10/typora+picgo图床/","link":"","permalink":"http://breadwinners.top/2023/05/10/typora+picgo%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"error1&quot;success&quot;.false, &quot;message&quot;.&quot;upload error. see C.Users\\lAdministratorlAppDatallRoamingllpicgollpicgo.log for more picgo日志： 1234567891011------Error Stack Begin------Error: read file E:\\Boke\\source\\_posts\\C:\\Users\\wutao\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230521041042868.png error at D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:38189 at async Promise.all (index 0) at async Object.handle (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:37138) at async $e.doTransform (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:16679) at async $e.start (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:15916) at async Tt.upload (D:\\application\\tools\\PicGo\\resources\\app.asar\\node_modules\\picgo\\dist\\index.cjs.js:1:71270) at async Object.upload (D:\\application\\tools\\PicGo\\resources\\app.asar\\background.js:2:653584) at async jn (D:\\application\\tools\\PicGo\\resources\\app.asar\\background.js:2:656251) at async D:\\application\\tools\\PicGo\\resources\\app.asar\\background.js:2:657340 解决办法： 直接在hexo的_post文件夹中写markdown会传不上去图片，但是在外面写可以正常上传图片，所以可以在外面写好了在放信hexo中","categories":[{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/categories/bugs/"}],"tags":[{"name":"picgo","slug":"picgo","permalink":"http://breadwinners.top/tags/picgo/"}]},{"title":"nginx绑定子域名","slug":"nginx绑定子域名","date":"2023-05-04T16:00:00.000Z","updated":"2023-05-22T13:01:22.125Z","comments":true,"path":"2023/05/05/nginx绑定子域名/","link":"","permalink":"http://breadwinners.top/2023/05/05/nginx%E7%BB%91%E5%AE%9A%E5%AD%90%E5%9F%9F%E5%90%8D/","excerpt":"","text":"检查 nginx 配置文件路径（重要）注意：这一步非常关键，如果修改了错误的 nginx 配置文件，将导致所有修改均无效，甚至会让您在探索了数个小时后仍无法得知修改无效的原因是什么。 使用命令 1$ nginx -V 来查看 nginx 的一些配置信息，如下（您的和博主的显示内容可能不同，不影响）： 12345nginx version: nginx/1.12.2built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_auth_request_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27; 其中只需要关注到 --conf-path=/etc/nginx/nginx.conf 这个条目，这个条目指明了当前 nginx 的程序使用的默认配置文件。 新建一个站点配置文件根据上面的配置文件路径，首先切换目录到 nginx 的配置路径下： 1$ cd /etc/nginx 然后新建一个站点配置文件，建议放置在 nginx 配置目录下的 vhost 目录内，如果您当前没有此目录，可新建一个： 12345678$ pwd/etc/nginx$ sudo mkdir vhost$ lsconf.d fastcgi_params mime.types scgi_params vhostdefault.d fastcgi_params.default mime.types.default scgi_params.default win-utffastcgi.conf koi-utf nginx.conf uwsgi_paramsfastcgi.conf.default koi-win nginx.conf.default uwsgi_params.default 注意：/etc 是系统目录，一般用户不具有修改权限，需要使用 sudo 以管理员权限在该目录中进行修改，如创建、修改文件，创建文件夹等操作。 进入刚刚创建的 vhost 目录，新建一个配置文件，例如 mysite.conf，该配置文件文件名无限制，最好是你的网站名称之类的，便于辨认，但一定是以 .conf 为后缀。 12345678$ pwd/etc/nginx$ cd vhost/$ pwd/etc/nginx/vhost$ sudo touch mysite.conf$ lsmysite.conf trans.conf 其中，touch 命令创建了一个名为 mysite.conf 的配置文件（空文件），是本文中要介绍的配置文件，另一个是博主正在运行的网站，无需在意。 修改网站配置文件信息本文中将建立一个名为 mysite 的网站，网站根目录为 /home/www/mysite，网站绑定域名 mysite.jinhangdev.cn。 使用任意文字编辑器打开 mysite.conf，输入如下内容并保存（注意需管理员权限）： 1234567server &#123; listen 80; # 网站的端口一般为 80，可以与其他网站一起使用该端口 server_name mysite.jinhangdev.cn; # 要绑定的域名（或子域名） root /home/www/mysite; # 该网站的根目录 location / &#123; # 不用管 &#125;&#125; 以上内容为一个 server 的内容，下面讲 nginx.conf 配置的时候会再区分把一行配置写在 server 或写在 server 外的区别。 12345678910111213$ pwd/etc/nginx/vhost$ lsmysite.conf trans.conf$ sudo vim mysite.conf$ cat mysite.confserver &#123; listen 80; server_name mysite.jinhangdev.cn; root /home/www/mysite; location /&#123; &#125;&#125; 上面我们已经新建好了一个网站，该网站使用服务器的 80 端口，绑定的域名为 mysite.jinhangdev.cn，网站根目录使用 /home/www/mysite。 修改 nginx 配置文件下面对关键文件 nginx.conf 进行配置，建议在修改前先备份，养成好的习惯： 123$ pwd/etc/nginx$ sudo cp nginx.conf nginx.conf.bak 将原有配置存储到 nginx.conf.bak 后，继续下面操作，若后面发现修改出错，可将 nginx.conf.bak 改名回 nginx.conf 使用。 以超级用户权限使用文本编辑器打开 nginx.conf： 1$ sudo vim nginx.conf 并进行编辑。 Nginx 配置文件的结构我们这里只介绍和配置域名绑定相关的部分结构，即 http 小节： 123http &#123; （各种配置）&#125; 设置在此处的配置都是 http 的全局配置，如果要对某个网站单独配置，则需要对每个 server 分别设置： 12345678910http &#123; (此处的配置是全局的配置参数) server &#123; (此处的配置是本 server 的配置参数) &#125; server &#123; (此处的配置是本 server 的配置参数) &#125; (此处的配置是全局的配置参数)&#125; 但是我们并不提倡把所有 server 都展开写在 nginx.conf 中，因此我们使用一句 include 语句，把 vhost 下所有网站的配置都引用进来。注意：include 命令只是简单地进行文本替换。 于是我们在 nginx.conf 的 http 节内部的末尾写上一句： 1234http &#123; （前面的若干配置） include /etc/nginx/vhost/*.conf;&#125; 这样一来，vhost 下的所有 .conf 文件均被文本替换式地引入到 nginx.conf 里面了。 重启 nginx 服务","categories":[{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://breadwinners.top/tags/nginx/"}]},{"title":"李沐说读论文","slug":"李沐读论文","date":"2023-05-02T16:00:00.000Z","updated":"2023-05-02T16:18:51.776Z","comments":true,"path":"2023/05/03/李沐读论文/","link":"","permalink":"http://breadwinners.top/2023/05/03/%E6%9D%8E%E6%B2%90%E8%AF%BB%E8%AE%BA%E6%96%87/","excerpt":"","text":"title abstract introduction method experiments conclusion 第一遍：标题、摘要、结论。可以看一看方法和实验部分重要的图和表。这样可以花费十几分钟时间了解到论文是否适合你的研究方向。第二遍：确定论文值得读之后，可以快速的把整个论文过一遍，不需要知道所有的细节，需要了解重要的图和表，知道每一个部分在干什么，圈出相关文献。觉得文章太难，可以读引用的文献。第三遍：提出什么问题，用什么方法来解决这个问题。实验是怎么做的。合上文章，回忆每一个部分在讲什么。","categories":[{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/"},{"name":"算法","slug":"论文/算法","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"centos7安装Mysql初始密码问题","slug":"centos7安装Mysql初始密码问题","date":"2023-05-02T16:00:00.000Z","updated":"2023-05-20T21:13:30.249Z","comments":true,"path":"2023/05/03/centos7安装Mysql初始密码问题/","link":"","permalink":"http://breadwinners.top/2023/05/03/centos7%E5%AE%89%E8%A3%85Mysql%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"一般来说，centos7暗转MySQL，可以直接使用yum -y install mysql来实现，但是突然碰到了不知道初始root密码的问题，记录一下解决过程 网上都会说grep ‘temporary password’ /var/log/mysqld.log就可以查看临时密码，但是系统却说 No such file of directory 解决方法 查看是否安装了mysql服务（有则自行卸载删除）。 12yum list installed mysql* rpm –qa|grep mysql* 查看服务器上是否有现成的安装包。 1yum list mysql* 去mysql官网的yum资源库找到对应的rpm文件的下载链接 在linux中下载、安装yum资源。 1rpm -ivh 资源下载链接(https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm) 查看当前mysql的当前版本 1yum info mysql-community-server 安装mysql 1yum -y install mysql-community-server 注：如果出现 原因是Mysql的GPG升级了，需要重新获取 1rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 MySQL安装完成如下： 安装完成后，启动MySQL 12systemctl start mysqldsystemctl status mysqld // 检查MySQL状态 查询mysql初始密码 1grep ‘temporary password’ /var/log/mysqld.log 修改密码 1mysqladmin -u root -p password Access denied for user ‘root‘@’localhost’ (using password: YES)报错 1、关闭mysql服务 service mysqld stop 2、找到&#x2F;etc&#x2F;my.cnf ,在最后一行添加skip-grant-tables（用于免密码登录） vim &#x2F;etc&#x2F;my.cnf 3、重启mysql服务 service mysqld start 4、正常登录mysql（不使用密码） mysql -u root 123456789mysql&gt; show databases;mysql&gt; use mysql;mysql&gt; ALTER USER &#x27;用户名&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;mysql&gt; flush privileges; --刷新MySQL的系统权限相关表mysql&gt; exit; 5、找到&#x2F;etc&#x2F;my.cnf ,删除skip-grant-table6、重启mysql服务service mysqld restart7、正常登录测试mysql -u root -p 就可以了 备注：root账号一般只添加了localhost访问(这是推荐的)，如若调试阶段不想通过ssh跳板连接，建议开个新账号。 步骤1：查看root账号的ip访问权限（执行结果：localhost和127.0.0.1，是无法从外部连接的） 1select user,host,plugin from user; 1SELECT host FROM mysql.user WHERE User = &#x27;root&#x27;; 步骤2：新建账号并指定密码和ip（使用 % 通配符表示允许任何ip访问） 1CREATE USER &#x27;my_name&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;my_password&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;my_name&#x27;@&#x27;%&#x27;; 步骤3：刷新配置 1FLUSH PRIVILEGES; 这样my_name就可以不通过ssh跳板直接连接了。","categories":[{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/categories/bugs/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://breadwinners.top/tags/mysql/"}]},{"title":"部署hexo到CentOs7","slug":"部署hexo到centos","date":"2023-05-02T16:00:00.000Z","updated":"2023-05-22T12:00:55.155Z","comments":true,"path":"2023/05/03/部署hexo到centos/","link":"","permalink":"http://breadwinners.top/2023/05/03/%E9%83%A8%E7%BD%B2hexo%E5%88%B0centos/","excerpt":"","text":"git 安装 1yum install git 测试 1git --version 输出类似下面的结果则表示安装成功 1git version 1.8.3.1 创建 git 用户 1adduser git 建立裸仓 12345su gitcd /home/git # 进入 git 用户目录mkdir blog &amp;&amp; chown -R git:git &amp;&amp; cd git# 创建博客文件夹，，设置权限,作为 nginx web 目录mkdir projects &amp;&amp; chown -R git:git &amp;&amp; cd project # 创建项目目录，设置权限并进入git init --bare hexo.git &amp;&amp; chown -R git:git # 创建博客裸仓，设置权限 添加 SSH Key，通过 ssh 链接仓库 12cd /home/git # 回到 git 用户目录mkdir .ssh # 存放 ssh key 在本地机器（写博客的电脑）上创建的 ssh 公钥（已有请忽略） 1ssh-keygen -o -t rsa -b 4096 -C &quot;email@example.com&quot; # 替换邮箱 复制公钥 1pbcopy &lt; ~/.ssh/id_rsa.pub 在远程服务器，使用 vim 编辑文件，vim 用法请参考： 1vi /home/git/.ssh/authorized_keys 按 i 进入编辑模式，粘贴公钥，按 esc，输入 :wq 保存并退出。 hexo 配置发布选项 修改 _config.yml （本级 hexo 配置文件） 1234deploy: type: git repo: git@ip:/home/git/projects/hexo.git # ip 为服务器ip branch: master 自动部署（服务器） 123cd /home/git/projects/hexo.git/hooks # 进入 hook 目录mv post-update.sample post-update # 重命名 post-updatevi post-update # vim 进行编辑 按 i 进入编辑模式，在最后一行上面粘贴下面文字，按 esc，输入 :wq 保存并退出。 1git --work-tree=/home/git/blog --git-dir=/home/git/projects/hexo.git checkout -f 在本地 hexo 目录执行发布命令 1hexo g -d 查看服务器 blog 目录中是否有文件，如果没有请检查步骤是否错误。 源代码存放 在我们服务器上存放的是编译后的文件，源文件我建议存放在 github 私有仓库。 nginx以 centos 为例： 安装 1yum install -y nginx 启动 1service nginx start 测试 1wget http://127.0.0.1 可以正常下载 index.html 文件则说明启动成功。 配置 1vi /etc/nginx/nginx.conf 把 user nginx 修改为user root， server 按照修改两处配置： 1234root /home/git/blog;location / &#123; index index.html;&#125; 重启 nginx 1service nginx restart 在浏览器键入你的服务器 ip 地址或域名，即可正常访问。 https使用 certbot 自动获取证书，参考 https://certbot.eff.org/ 安装 Certbot 1sudo yum install certbot python2-certbot-nginx 获取证书并自动配置 1sudo certbot --nginx 按照提示输入即可 自动续签 1echo &quot;0 0,12 * * * root python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; certbot renew -q&quot; | sudo tee -a /etc/crontab &gt; /dev/null 结束","categories":[],"tags":[]},{"title":"解决切换用户出现bash-4.2$问题","slug":"解决Linux用户出现bash-4.2$问题","date":"2023-05-02T16:00:00.000Z","updated":"2023-06-13T15:32:49.979Z","comments":true,"path":"2023/05/03/解决Linux用户出现bash-4.2$问题/","link":"","permalink":"http://breadwinners.top/2023/05/03/%E8%A7%A3%E5%86%B3Linux%E7%94%A8%E6%88%B7%E5%87%BA%E7%8E%B0bash-4.2$%E9%97%AE%E9%A2%98/","excerpt":"","text":"##【问题描述】 linux中创建了一个xhh用户，然后使用su命令切换用户后，终端提示符显示成“bash-4.2$”而不是[root@localhost xhh]#，导致ll等命令无法执行。 123[root@localhost hadoop] # su hadoopbash-4.2$ llbash: ll: 未找到命令 【原因】没有在home目录下创建对应的目录导致。 【解决方法】使用root用户登录，再home目录中创建用户对应的文件夹，mkdir &#x2F;home&#x2F;user，这里的user是用户的名字，然后执行如下两个命令： 12cp /etc/skel/.bashrc /home/hadoopcp /etc/skel/.bash_profile /home/hadoop 执行成功后，再次使用su命令切换用户，发现一切正常。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"bash-4.2$","slug":"bash-4-2","permalink":"http://breadwinners.top/tags/bash-4-2/"}]},{"title":"标题模板","slug":"test","date":"2023-05-01T02:08:40.150Z","updated":"2023-05-02T16:18:26.746Z","comments":true,"path":"2023/05/01/test/","link":"","permalink":"http://breadwinners.top/2023/05/01/test/","excerpt":"","text":"1hexo g -d This is a video test post. Youtube Vimeo Headers1234567891011121314# H1## H2### H3#### H4##### H5###### H6Alternatively, for H1 and H2, an underline-ish style:Alt-H1======Alt-H2------ H1H2H3H4H5H6Alternatively, for H1 and H2, an underline-ish style: Alt-H1Alt-H2Emphasis","categories":[{"name":"分类","slug":"分类","permalink":"http://breadwinners.top/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签名","slug":"标签名","permalink":"http://breadwinners.top/tags/%E6%A0%87%E7%AD%BE%E5%90%8D/"}]},{"title":"数论","slug":"数论","date":"2023-04-25T16:00:00.000Z","updated":"2023-07-11T01:45:53.092Z","comments":true,"path":"2023/04/26/数论/","link":"","permalink":"http://breadwinners.top/2023/04/26/%E6%95%B0%E8%AE%BA/","excerpt":"","text":"p,q是正整数且互质，那么不能凑出的最大整数为(p - 1)(q - 1) - 1","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://breadwinners.top/tags/%E6%95%B0%E8%AE%BA/"},{"name":"不能凑出的最大整数","slug":"不能凑出的最大整数","permalink":"http://breadwinners.top/tags/%E4%B8%8D%E8%83%BD%E5%87%91%E5%87%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"}]},{"title":"DP动态规划问题","slug":"DP","date":"2023-04-24T16:00:00.000Z","updated":"2023-07-11T01:37:44.960Z","comments":true,"path":"2023/04/25/DP/","link":"","permalink":"http://breadwinners.top/2023/04/25/DP/","excerpt":"","text":"全新分析DP问题方式从集合角度来考虑DP问题：闫式思考法 依据最后一步来划分 从定义出发 ，分别求出集合左右两边的最大值 摘花生 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 105;int a[N][N], f[N][N];int T, R, C;int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; R &gt;&gt; C; for (int i = 1; i &lt;= R; i++) &#123; for (int j = 1; j &lt;= C; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; // f[i][j]指的是到(i, j)的最大花生数 for (int i = 1; i &lt;= R; i++) &#123; for (int j = 1; j &lt;= C; j++) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]) + a[i][j]; &#125; &#125; cout &lt;&lt; f[R][C] &lt;&lt; endl; &#125; return 0;&#125; 数塔问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 20;int n;int a[N][N], dp[N][N], step[N][N];void findRounte() &#123; for (int i = 1;i &lt;= n;i++) &#123; dp[n][i] = a[n][i]; &#125; for (int i = n - 1; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (dp[i + 1][j] &lt; dp[i + 1][j + 1]) &#123; step[i][j] = 0; dp[i][j] = a[i][j] + dp[i + 1][j]; &#125; else &#123; step[i][j] = 1; dp[i][j] = a[i][j] + dp[i + 1][j + 1]; &#125; &#125; &#125;&#125;void printRounte() &#123; cout &lt;&lt; &quot;最小数值为：&quot; &lt;&lt; dp[1][1] &lt;&lt; endl; int i, j = 1; for (i = 1; i &lt; n; i++) &#123; if (step[i][j] == 1) &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; -R-&gt; &quot;; j++; &#125; else &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; -L-&gt; &quot;; &#125; &#125; cout &lt;&lt; a[i][j];&#125;int main() &#123; // DP 数塔问题 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; findRounte(); printRounte(); return 0;&#125; ​ 从上往下DP1 背包问题物品条件： 1dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); 解释：在装入w[i]重量的物品后剩下的[j - w[i]]的空间能装的物品价值（可以查表得到）加上w[i]物品的价值v[i] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#include &lt;algorithm&gt;const int N = 100;int main() &#123; // dp背包 int n, bagV; // n = 4, bagV = 8; int w[N] = &#123;0&#125;; int v[N] = &#123;0&#125;; int dp[N][N] = &#123;&#123;0&#125;&#125;; cin &gt;&gt; n &gt;&gt; bagV; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= bagV; j++) &#123; if (j &lt; w[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; // 核心代码可以写成： /* dp[i][j] = dp[i - 1][j]; if (j &gt;= w[i]) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); */ // 动态规划表的输出 for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= bagV; j++) &#123; cout &lt;&lt; dp[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; puts(&quot;***************************&quot;); cout &lt;&lt; dp[n][bagV]; return 0;&#125; 完全背包问题&#x3D;&#x3D;每种物品可以选无限多件&#x3D;&#x3D; 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 1010;int f[N][N];int v[N],w[N];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1 ; i &lt;= n ;i ++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]; &#125; for(int i = 1 ; i&lt;=n ;i++) for(int j = 0 ; j&lt;=m ;j++) &#123; for(int k = 0 ; k*v[i]&lt;=j ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl;&#125; 多重背包问题有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 iii 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi,si≤100 输入样例 123454 51 2 32 4 13 4 34 5 2 输出样例： 110 &#x3D;&#x3D;可以取多件下&#x3D;&#x3D; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n,m;int v[N],w[N],s[N];int f[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i &lt;= n;i ++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; for(int i = 1;i &lt;= n;i ++)&#123; for(int j = 0;j &lt;= m;j ++)&#123; for(int k = 0;k &lt;= s[i];k ++)&#123; if(j &gt;= v[i] * k) f[i][j] = max(f[i][j],f[i - 1][j - k * v[i]] + w[i] * k); &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0;&#125; 分组背包问题1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int f[N][N]; // 只从前i组物品中选，当前体积小于等于j的最大值int v[N][N], w[N][N], s[N]; // v为体积，w为价值，s代表第i组物品的个数int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; for (int j = 0; j &lt; s[i]; j++) &#123; cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; // 读入 &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; // 枚举物品的种类 for (int j = 0; j &lt;= m; j++) &#123; // 枚举背包的容量 f[i][j] = f[i - 1][j]; // 不选 for (int k = 0; k &lt; s[i]; k++) &#123; if (j &gt;= v[i][k]) f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]); &#125; &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl;&#125; 矩阵连乘参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;/*自底向上的推出矩阵连乘的最优解先从两个矩阵相乘开始，而后三个矩阵相乘，四个......直到推出目标长度的最优解 ，即假设一个矩阵链，初始长度为2，算出所有相邻矩阵相乘的计算次数，而后使其长度为3...4...直到目标长度状态转移方程： m[i][j] = min&#123;m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]&#125; i&lt;=k&lt;j i&lt;j m[i][j] = 0 i == j;*/#define LEN 5 // 矩阵个数// 矩阵连乘函数，找到最优解void MatrixChain(int *p, int m[][LEN + 1], int s[][LEN + 1]) &#123; for (int i = 0; i &lt; LEN + 1; i++) m[i][i] = 0; // 初始化，对角线元素置零，即当矩阵链长度为1时（只有一个矩阵）不用乘，为零 for (int r = 2; r &lt;= LEN; r++) &#123; // r表示矩阵链的长度，从2开始,两个矩阵相乘，而后3...4...5... for (int i = 1; i &lt;= LEN - r + 1; i++) &#123; // i是矩阵链的首个矩阵，小于矩阵个数减矩阵链长度加一 int j = i + r - 1; // j是矩阵链的最后一个元素 m[i][j] = m[i][i] + m[i + 1][j] + p[i - 1] * p[i] * p[j]; // m[i][j]是子结构，从最左边开始推 s[i][j] = i; // 标记断开的位置 for (int k = i + 1; k &lt; j; k++) &#123; // k是i和j直接的断开点，是在i和j之间的子结构 ，通过k的循环找到最优的解 int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // 状态转移方程 if (t &lt; m[i][j]) &#123; m[i][j] = t; // 更新最优解 s[i][j] = k; // 更新断开点 &#125; &#125; &#125; &#125;&#125;// 回溯函数，根据s[i][j]数组标记的位置，回溯找到断开的位置void Traceback(int i, int j, int s[][LEN + 1]) &#123; if (i == j) &#123; // 当i与j相等 说明回溯到该矩阵的位置了 cout &lt;&lt; &quot;A&quot; &lt;&lt; i; &#125; else &#123; cout &lt;&lt; &quot;(&quot;; Traceback(i, s[i][j], s); // 从尾往头回溯 Traceback(s[i][j] + 1, j, s); // 从断点往后回溯 cout &lt;&lt; &quot;)&quot;; &#125;&#125;// 输出函数void output(int t[][LEN + 1]) &#123; for (int i = 1; i &lt;= LEN; i++) &#123; for (int j = 1; j &lt;= LEN; j++) &#123; // cout &lt;&lt; &quot; &quot; &lt;&lt; t[i][j] &lt;&lt; &quot; &quot;; printf(&quot;%6d&quot;, t[i][j]); &#125; cout &lt;&lt; endl; &#125;&#125;int main(void) &#123; int p[LEN + 1] = &#123;8, 6, 22, 3, 4, 10&#125;; // 矩阵的维度分别是2*3,3*4,4*5,5*6,6*7，LEN+1个数表示LEN个矩阵 int m[LEN + 1][LEN + 1] = &#123;0&#125;; // 记录最优子结构的二维数组 int s[LEN + 1][LEN + 1] = &#123;0&#125;; // 记录最优解对应的括号的位置 MatrixChain(p, m, s); cout &lt;&lt; endl; output(m); cout &lt;&lt; endl; output(s); cout &lt;&lt; endl; cout &lt;&lt; &quot;outcome:&quot; &lt;&lt; endl; Traceback(1, LEN, s); cout &lt;&lt; endl; return 0;&#125; 拔河问题题目：n 个人参加拔河比赛，每个人有自己的重量，现在需要把他们分成两组进行比赛，每个人属于其中的一个组。为使比赛公平，求使得两组重量差最小的分配。 这一题是一道二维费用的动态规划问题，我们可以这样转化这个问题：将n个物品放到一个容量为n&#x2F;2的背包，每个物品占一个空间，这个背包所能承受的重量是（所有物品总和）&#x2F;2 ，然后求这个背包最多能放多重的物品，这样就成功转化成一个背包问题了，状态转移方程为 1dp[i][j]=max(dp[i-1][j],dp[i-1][j-array[i]]+array[i]) 1234567891011121314151617181920212223// 看不懂的代码，一维dp数据解决了别人用二维dp数组的问题#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int w[10050], dp[10050];int main() &#123; int n, t; cin &gt;&gt; n; int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; sum += w[i]; &#125; t = sum / 2; for (int i = 1; i &lt;= n; i++) for (int j = t; j &gt;= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i]] + w[i]); cout &lt;&lt; dp[t] &lt;&lt; &quot; &quot; &lt;&lt; sum - dp[t] &lt;&lt; &quot;\\n&quot;; return 0;&#125; 最长上升子序列给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数 N。 第二行包含 N 个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 1≤N≤100−10^9^≤数列中的数≤10^9^ 输入样例： 1273 1 2 1 8 5 6 输出样例 14 1234567891011121314151617181920212223242526272829303132#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N], f[N];int main() &#123; // https://www.acwing.com/problem/content/897/ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; f[i] = 1; // 初始化，只有一个元素的时候，长度为1 for (int j = 0; j &lt; i; j++) &#123; if (a[i] &gt; a[j]) // 只有当后一个元素大于其前一个元素时，才需要求最长上升的子序列，否则不是上升子序列 f[i] = max(f[j] + 1, f[i]); &#125; &#125; int res = 0; for (int i = 1; i &lt;= n; i++) &#123; res = max(res, f[i]); &#125; cout &lt;&lt; res; return 0;&#125; 地宫取宝X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。 地宫的入口在左上角，出口在右下角。 小明被带到地宫的入口，国王要求他只能向右或向下行走。 走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。 当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。 请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。 输入格式 第一行 3 个整数，n,m,k含义见题目描述。 接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。 **** 输出格式 输出一个整数，表示正好取 k 个宝贝的行动方案数。 该数字可能很大，输出它对 1000000007取模的结果。 数据范围 1≤n,m≤501≤k≤120≤Ci≤12 输入样例1： 1232 2 21 22 1 输出样例1： 12 输入样例2： 1232 3 21 2 32 1 5 输出样例2： 114 记忆化搜索 四维DP： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 55, MOD = 1000000007;int n, m, k;int w[N][N];int f[N][N][13][14]; // f[i][j][k][c]表示在(i, j)这个点，拿了k个物品，这些物品中最大值为c的方案数int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; w[i][j]; w[i][j]++; // 由于需要表示比物品价值（可能为0）更小的价值，可以设置初始为-1，但是数组下标不能为-1，于是把物品价值往右偏移一位，现在是[1,13] &#125; // 两个边界初始化 // 在起点 (1, 1) 处 // 如果拿也只能拿 a[i][j] 这个物品，只有一种方案 // 如果不拿，那就是 0 个物品，也是一个方案数 // 由于物品价值已经增加了一个偏移量，现在价值的范围是 [1, 13] // 所以价值为 0 并不代表物品的价值，而是一个边界点 f[1][1][1][w[1][1]] = 1; f[1][1][0][0] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (i == 1 &amp;&amp; j == 1) continue; for (int u = 0; u &lt;= k; u++) // 拿了u件物品 for (int v = 0; v &lt;= 13; v++) &#123; // 拿的物品的最大价值为v int &amp;val = f[i][j][u][v]; // 不拿物品 val = (val + f[i - 1][j][u][v]) % MOD; // 为什么时val += 前面可能的方案数而不是等于 val = (val + f[i][j - 1][u][v]) % MOD; // 因为这个题球的时方案数，所以必须得是方案数的和，否则覆盖的话，会损失方案数 // 可以拿 if (u &gt; 0 &amp;&amp; v == w[i][j]) &#123; for (int c = 0; c &lt; v; c++) &#123; // c &lt; v;因为现在取的宝贝要比之前的价值都大 val = (val + f[i - 1][j][u - 1][c]) % MOD; val = (val + f[i][j - 1][u - 1][c]) % MOD; &#125; &#125; &#125; &#125; // 最后把在终点 (n, m) 处拿 c 个物品的方案数累加 int res = 0; for (int i = 0; i &lt;= 13; i++) res = (res + f[n][m][k][i]) % MOD; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 李白打酒一天，他提着酒壶，从家里出来，酒壶中有酒 2 斗。 他边走边唱： 无事街上走，提壶去打酒。 逢店加一倍，遇花喝一斗。 这一路上，他一共遇到店 N 次，遇到花 M 次。 已知最后一次遇到的是花，他正好把酒喝光了。 请你计算李白这一路遇到店和花的顺序，有多少种不同的可能？ 注意：壶里没酒 (000 斗) 时遇店是合法的，加倍后还是没酒；但是没酒时遇花是不合法的。 输入格式 第一行包含两个整数 N 和 M。 输出格式 输出一个整数表示答案。由于答案可能很大，输出模 1000000007的结果。 数据范围 对于 40% 的评测用例：1≤N,M≤10 对于 100% 的评测用例：1≤N,M≤100 输入样例： 15 10 输出样例： 114 样例解释 如果我们用 000 代表遇到花，111 代表遇到店，141414 种顺序如下： 1234567891011121314010101101000000010110010010000011000110010000100010110010000011001000110000100011000110000100100010110000010110100000100011001001000100100011001000100100100011000100011010000010100100100100010100101000001010100 1234567891011121314151617181920212223242526272829#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 110, MOD = 1e9 + 7;int n, m;int f[N][N][N];int main() &#123; // https://www.acwing.com/problem/content/4411/ cin &gt;&gt; n &gt;&gt; m; f[0][0][2] = 1; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt;= m; k++) &#123; int&amp; v = f[i][j][k]; if (i &amp;&amp; k % 2 == 0) v = (v + f[i - 1][j][k / 2]) % MOD; if (j) v = (v + f[i][j - 1][k + 1]) % MOD; &#125; cout &lt;&lt; f[n][m - 1][1] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://breadwinners.top/tags/DP/"}]},{"title":"求区间和","slug":"区间和","date":"2023-04-19T16:00:00.000Z","updated":"2023-07-11T01:44:28.893Z","comments":true,"path":"2023/04/20/区间和/","link":"","permalink":"http://breadwinners.top/2023/04/20/%E5%8C%BA%E9%97%B4%E5%92%8C/","excerpt":"","text":"区间和的本质是离散化 离散化：值域跨度大，用到的非常的稀疏 整数有序的离散化 题目描述： 假定有一个无限长的数轴，数轴上每个坐标上的数都是0。 现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。 近下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。 输入格式 第一行包含两个整数n和m。 接下来 n 行，每行包含两个整数x和c。 再接下里 m 行，每行包含两个整数l和r。 输出格式 共m行，每行输出一个询问中所求的区间内数字和。 数据范围 −10^9^≤ x ≤10^9^,1≤n,m≤10^5^,−10^9^≤ l ≤ r ≤10^9^,−10000≤c≤10000 输入样例：12345673 31 23 67 51 34 67 8 输出样例：123805 首先读入 数轴上可能用到的数值，这包括增加过程中用到的和后面查询过程中可能用到的，全部存入alls中(还需要进行排序去重处理)，同时增加过程中和查询过程需要使用的键值对也需要用vector&lt;pair&lt;&lt;int,int&gt;&gt;存储，便于后面的取值查询。连接alls和a数组的桥梁是她们相同的下标 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define N 300010using namespace std;typedef vector&lt;int, int&gt; PII;vector&lt;int&gt; alls; // 存储（所有与插入和查询有关的）坐标int a[N], s[N]; // 分别存储坐标插入的值和a的前缀和int find(int x) &#123; // find函数的作用是输入坐标，输出离散化后的坐标 int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (alls[mid] &lt;= x) &#123; l = mid; &#125; else r = mid - 1; &#125; return l + 1; // 二分出了问题 目前只能用另一种二分方法得出正确的结果,原来是二分的数组写错了&#125;int main() &#123; int n, m, x, c, l, r; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int, int&gt;&gt; add, query; // 存储插入和询问操作的数据 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; // 排序，去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 执行前n次插入操作 for (auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; // 前缀和 for (int i = 1; i &lt;= alls.size(); i++) // 为什么是alls.size(),因为alls是存着所有的可能用到的下标,allls数组中有多少个数，a数组中就有多少个数 s[i] = s[i - 1] + a[i]; // 处理后m次询问操作 for (auto item : query) &#123; int l = find(item.first); int r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://breadwinners.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"堆Heap","slug":"堆","date":"2023-04-19T16:00:00.000Z","updated":"2023-07-11T01:34:51.939Z","comments":true,"path":"2023/04/20/堆/","link":"","permalink":"http://breadwinners.top/2023/04/20/%E5%A0%86/","excerpt":"","text":"堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 如何手写一个堆？完全二叉树 5个操作// 1. 插入一个数 heap[ ++ size] = x; up(size);// 2. 求集合中的最小值 heap[1]// 3. 删除最小值 heap[1] = heap[size]; size -- ;down(1);// 4. 删除任意一个元素 heap[k] = heap[size]; size -- ;up(k); down(k);// 5. 修改任意一个元素 heap[k] = x; up(k); down(k);#include &lt;iostream&gt;using namespace std;int const N = 100010;// h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点// size 既表示堆里存储的元素个数，又表示最后一个结点的下标int h[N], siz; // 堆有两个变量h[N]，size; 怎么这里的size和文件里有冲突，只能改成siz了// 下滤void down(int u) &#123; int t = u; // t存储三个结点中存在的最小的结点的下标，初始化为当前结点u if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // 左子节点存在并且小于当前结点，更新t的下标 if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; // 右子节点存在并且小于当前结点，更新t的下标 if (t != u) // 如果t==u意味着不用变动，u就是三个结点中拥有最小值的结点下标，否则交换数值 &#123; swap(h[t], h[u]); down(t); // 交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小 &#125; // 如果还是不明白可以手模拟一边down的过程&#125;// 上滤void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; swap(h[u / 2], h[u]); u /= 2; &#125;&#125;// 插入新元素void push(int x) &#123; h[++siz] = x, up(x);&#125;// 删除指点元素void pop(int k) &#123; h[k] = h[siz], siz--, down(k), up(k);&#125;// 修改指定元素void modify(int k, int x) &#123; h[k] = x, down(k), up(k);&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; // 初始化size,表示堆里有n 个元素 for (int i = n / 2; i; i--) down(i); // 把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉 while (m--) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[siz]; siz--; down(1); &#125; return 0;&#125; 参考链接 ph[k]存的是第k个插入的点是哪个点(存的是点的下标)，hp[k]存是堆里的点是第几个插入的点， 复杂版heap（代码未通过）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;// int const N = 30;int const N = 100010;// h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点// size 既表示堆里存储的元素个数，又表示最后一个结点的下标int h[N], ph[N], hp[N], siz, k = 1; // ph[k]存的是第k个插入的点是哪个点，hp[k]存是堆里的点是第几个插入的点void heap_swap(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u) &#123; int t = u; // t存储三个结点中存在的最小的结点的下标，初始化为当前结点u if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // 左子节点存在并且小于当前结点，更新t的下标 if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; // 右子节点存在并且小于当前结点，更新t的下标 if (t != u) // 如果t==u意味着不用变动，u就是三个结点中拥有最小值的结点下标，否则交换数值 &#123; heap_swap(t, u); down(t); // 交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小 &#125; // 如果还是不明白可以手模拟一边down的过程&#125;// 上滤void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; heap_swap(u / 2, u); u /= 2; &#125;&#125;// 插入新元素void push(int x) &#123; h[++siz] = x; up(siz); ph[k] = siz, hp[siz] = k; k++;&#125;// 删除指点元素void pop(int k) &#123; heap_swap(k, siz); siz--, down(k), up(k);&#125;// 修改指定元素void modify(int k, int x) &#123; h[k] = x, down(k), up(k);&#125;int main() &#123; int n; string op; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; op; if (!op.compare(&quot;I&quot;)) &#123; int x; cin &gt;&gt; x; push(x); &#125; else if (!op.compare(&quot;PM&quot;)) &#123; cout &lt;&lt; h[1] &lt;&lt; &#x27;\\n&#x27;; &#125; else if (!op.compare(&quot;DM&quot;)) &#123; pop(1); down(1); &#125; else if (op[0] == &#x27;D&#x27;) &#123; int t; cin &gt;&gt; t; pop(ph[t]); &#125; else if (op[0] == &#x27;C&#x27;) &#123; int t, x; cin &gt;&gt; t &gt;&gt; x; modify(ph[t], x); &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"手写堆","slug":"手写堆","permalink":"http://breadwinners.top/tags/%E6%89%8B%E5%86%99%E5%A0%86/"}]},{"title":"DFS","slug":"dfs","date":"2023-04-18T16:00:00.000Z","updated":"2023-07-11T01:37:39.057Z","comments":true,"path":"2023/04/19/dfs/","link":"","permalink":"http://breadwinners.top/2023/04/19/dfs/","excerpt":"","text":"求全排列 （46，47） 求组合 （77） 求二叉树和为定值的某一路径 求数组中和为定值的子数组（39，40，216） 子数组问题（78，90） 八皇后问题 数独问题 回溯01背包输入：物品数量n，背包容量，各物品的重量和价值 输出：背包的最大价值、装入最大容量及装入情况 123456789101112134 52 1 3 212 10 20 15最大价值：37，背包装入最大容量：5装入情况：1 1 0 13 30 16 15 159 6 5最大价值：11，背包装入最大容量：30装入情况：0 1 1 Error example： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;int *w, *v, *x, *bestx, bestv, bestw, c, cw, cv;int n;void input() &#123; cin &gt;&gt; n &gt;&gt; c; w = new int[n + 1]; v = new int[n + 1]; x = new int[n + 1]; bestx = new int[n + 1]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i];&#125;bool constraint(int k) &#123; if (cw + w[k] &gt; c) return false; else &#123; cw += w[k]; cv += v[k]; return true; &#125;&#125;void bag(int k) &#123; if (k &gt; n) &#123; if (bestv &lt; cv) &#123; bestv = cv; bestw = cw; for (int i = 1; i &lt;= n; i++) &#123; bestx[i] = x[i]; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt;= 1; i++) &#123; x[k] = i; if (i == 0) &#123; bag(k + 1); &#125; else &#123; if (constraint(k)) &#123; // 在constraint函数中进行条件之类的操作，比如此题种的cw += w[k]; // cv += v[k]; 在非最优解的情况后不会还原状态，从而出错 bag(k + 1); &#125; &#125; &#125; &#125;&#125;int main() &#123; input(); bag(1); cout &lt;&lt; &quot;背包的最大价值为 &quot; &lt;&lt; bestv &lt;&lt; &quot; 装入最大容量为 &quot; &lt;&lt; bestw &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; bestx[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; &#x3D;&#x3D;在constraint函数中进行条件之类的操作，比如此题种的cw +&#x3D; w[k];&#x3D;&#x3D;&#x3D;&#x3D;cv +&#x3D; v[k]; 在非最优解的情况后不会还原状态，从而出错&#x3D;&#x3D; corret： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;int *w, *v, *x, *bestx, bestv = 0, bestw = 0, c, cw = 0, cv = 0;int n;void input() &#123; cin &gt;&gt; n &gt;&gt; c; w = new int[n + 1]; v = new int[n + 1]; x = new int[n + 1]; bestx = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125;&#125;void bag(int k) &#123; if (k &gt; n) &#123; if (bestv &lt; cv) &#123; bestv = cv; bestw = cw; for (int i = 1; i &lt;= n; i++) &#123; bestx[i] = x[i]; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt;= 1; i++) &#123; x[k] = i; if (i == 0) &#123; bag(k + 1); &#125; else if (cw + w[k] &lt;= c) &#123; cw += w[k]; cv += v[k]; bag(k + 1); cw -= w[k]; cv -= v[k]; &#125; &#125; &#125;&#125;int main() &#123; input(); bag(1); cout &lt;&lt; &quot;背包的最大价值为 &quot; &lt;&lt; bestv &lt;&lt; &quot; 装入最大容量为 &quot; &lt;&lt; bestw &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; bestx[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; n个数排列枚举题目： 解空间树： 123456789101112131415161718192021222324252627282930313233343536#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 10;int n;int a[N], path[N];bool st[N];void dfs(int u) &#123; if (u &gt; n) &#123; // u代表层数，n代表分支数。搜索完一个分支， 再搜索另一个分支。 for (int i = 1; i &lt;= n; i++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; // i 是枚举所有的分支 if (!st[i]) &#123; path[u] = a[i]; st[i] = true; dfs(u + 1); st[i] = false; path[u] = 0; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; dfs(1); return 0;&#125; 1-n选任意个数解空间树多叉树的遍历要用数组来记录哪个数已经被选择了，二叉树的话，直接还原现场走另一个分支，继续寻找 递归的时候怎么把每个状态记录下来path[]，记录搜索的层数时第几层u，记录一下当前分支从第几个书开始搜start，还原状态 排列数字各种类型的解空间树： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 200;// const int N = 1e5 + 10;int n;int a[N];bool vis[N];void dfs(int u) &#123; if (u &gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (vis[i]) cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; puts(&quot;&quot;); &#125; else &#123; vis[u] = true; dfs(u + 1); vis[u] = false; dfs(u + 1); &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; dfs(1); return 0;&#125;/*31 2 3 1 21 312 323 */ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 16;int n;int st[N]; // 状态，记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它void dfs(int u)&#123; if (u &gt; n) &#123; for (int i = 1; i &lt;= n; i ++ ) if (st[i] == 1) printf(&quot;%d &quot;, i); printf(&quot;\\n&quot;); return; &#125; st[u] = 2; dfs(u + 1); // 第一个分支：不选 st[u] = 0; // 恢复现场 st[u] = 1; dfs(u + 1); // 第二个分支：选 st[u] = 0;&#125;int main()&#123; // https://www.acwing.com/activity/content/code/content/156210/ cin &gt;&gt; n; dfs(1); return 0;&#125; n个数选m个数和排列行枚举相比，少了一个判重数组，因为dfs多了一个参数，保证了后面枚举的过程中，枚举的数一定比前一个数大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 200;// const int N = 1e5 + 10;int a[N], path[N];int n, m, cnt;bool vis[N]; // 不需要标记是否访问的数组void dfs(int u, int start) &#123; if (u + n - start &lt; m) return; // 剪枝 if (u == m + 1) &#123; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; path[i] &lt;&lt; &#x27; &#x27;; puts(&quot;&quot;); &#125; else &#123; for (int i = start; i &lt;= n; i++) &#123; path[u] = i; dfs(u + 1, i + 1); // 认为规定顺序，保持升序选择 path[u] = 0; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; dfs(1, 1); return 0;&#125;/* 5 31 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5 */ 剪枝：在第u层，选第u个数，已经选了u - 1个数，还剩下能选的数从start开始到n共n - start + 1个 数，如果加起来都小于m，则可以判定为此分支的结果都不成立，则剪枝。条件u + n - start &lt; m","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://breadwinners.top/tags/dfs/"}]},{"title":"图论","slug":"GraphTheory","date":"2023-04-16T16:00:00.000Z","updated":"2023-07-11T01:27:13.520Z","comments":true,"path":"2023/04/17/GraphTheory/","link":"","permalink":"http://breadwinners.top/2023/04/17/GraphTheory/","excerpt":"","text":"最短路劲问题所有基础最短路径在未标记的节点中寻找距离出发点最小的节点，标记，收录进最优路径节点中 1234564 4 0 1 31 2 11 3 43 2 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define maxn 6// #define maxn 110#define INF 0x3f3f3f3f// 根据边权图建边（邻接矩阵）int edges[maxn][maxn]; // 邻接矩阵int dist[maxn]; // 距离源点距离的数组bool visited[maxn]; // 是否已经找到最短路void init(int n) &#123; int i, j; memset(edges, INF, sizeof(edges)); // 初始化邻接矩阵 memset(visited, false, sizeof(visited)); for (i = 0; i &lt; n; ++i) &#123; for (j = 0; j &lt; n; ++j) &#123; if (i == j) &#123; edges[i][j] = 0; &#125; &#125; &#125;&#125;void dijkstra(int src, int n) &#123; int i, p; // 初始化 dist[] for (i = 0; i &lt; n; ++i) &#123; dist[i] = edges[src][i]; &#125; visited[src] = true; while (true) &#123; p = -1; // 记录当前集合中到源点最小路径的点的下标 int mn = INF; // 看起来 mn 是一个临时存储值的作用 for (i = 0; i &lt; n; ++i) &#123; // 在dist[]找一个最小的路径，并将这条路到达的顶点记录 // 通过遍历 S 集合的方法，寻找最小路径的顶点，此处可以通过优先队列的方法优化 if (!visited[i] &amp;&amp; dist[i] &lt; mn) &#123; // dist[i] &lt; mn 成立是可达，dist[i] &lt; mn,会挑选出到源点最小距离的点 mn = dist[i]; p = i; &#125; &#125; visited[p] = true; if (p == -1) &#123; break; &#125; for (i = 0; i &lt; n; ++i) &#123; // 更新未访问过的节点到新访问节点p 的距离 if (!visited[i] &amp;&amp; mn + edges[p][i] &lt; dist[i]) &#123; dist[i] = mn + edges[p][i]; &#125; &#125; &#125;&#125;int main() &#123; cout &lt;&lt; &quot;现在开始建立邻接矩阵：&quot; &lt;&lt; endl; int n, m; int i, j; cout &lt;&lt; &quot;请输入顶点数量和边的数量：&quot; &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; init(n); cout &lt;&lt; &quot;请输入边的起点、终点以及距离：&quot; &lt;&lt; endl; for (i = 0; i &lt; m; ++i) &#123; int u, v, wt; cin &gt;&gt; u &gt;&gt; v &gt;&gt; wt; edges[u][v] = edges[v][u] = wt; &#125; cout &lt;&lt; &quot;请输入起点城市：&quot; &lt;&lt; endl; int start; cin &gt;&gt; start; dijkstra(start, n); cout &lt;&lt; &quot;起点城市到所有城市的最小距离为：&quot; &lt;&lt; endl; for (j = 0; j &lt; n; ++j) &#123; cout &lt;&lt; start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot;最小路径为&quot; &lt;&lt; dist[j] &lt;&lt; endl; &#125; return 0;&#125; 分支限界法 acwing Dijkstra给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。 请你求出 111 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。 输入格式 第一行包含整数 n和 m。 接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y的有向边，边长为 z。 输出格式 输出一个整数，表示 1 号点到 n 号点的最短距离。 如果路径不存在，则输出 −1。 数据范围 1≤n≤500 1≤m≤10^5^ 图中涉及边长均不超过10000。 输入样例： 12343 31 2 22 3 11 3 4 输出样例： 13 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 510;int n, m;int g[N][N];int dist[N];bool visited[N];int dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int t = -1; // t = -1 ,在下面内层循环的判断中一定会成立，因为一定要找到一个能够与当前源点距离最近的点，t == -1只会成立一次，知识为了找到第一个距离起始点最近的点，且在下面dist[j] = min(dist[j], dist[t] + g[t][j]);中用于初始化第一次的距离出发点的距离 for (int j = 1; j &lt;= n; j++) if (!visited[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); visited[t] = true; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m--) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = min(g[a][b], c); // 有向无环图只能赋一边的值********* &#125; printf(&quot;%d\\n&quot;, dijkstra()); return 0;&#125; 邻接表存的话，无所谓重边 Kruskal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 200010, INF = 0x3f3f3f3f;int n, m;int p[N];struct Edge &#123; int a, b, w;&#125; edges[M];bool cmp(Edge a, Edge b) &#123; // 通过边长进行排序 return a.w &lt; b.w;&#125;// 并查集int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int kruskal() &#123; sort(edges, edges + m, cmp); for (int i = 1; i &lt;= n; i++) // 初始化并查集 p[i] = i; int res = 0, cnt = 0; for (int i = 0; i &lt; m; i++) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) &#123; p[a] = b; // 合并a b res += w; cnt++; // 当前加了多少条边 &#125; &#125; if (cnt &lt; n - 1) return INF; // 如果保留的边小于点数-1，则不能连通 else return res;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); edges[i] = &#123;a, b, w&#125;; &#125; int t = kruskal(); if (t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://breadwinners.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"graph","slug":"graph","permalink":"http://breadwinners.top/tags/graph/"}]},{"title":"BFS","slug":"bfs","date":"2023-04-16T16:00:00.000Z","updated":"2023-07-11T01:37:33.107Z","comments":true,"path":"2023/04/17/bfs/","link":"","permalink":"http://breadwinners.top/2023/04/17/bfs/","excerpt":"","text":"不是所有的最短路径问题都可以用bfs来做，只有当边权相同的时候才能用bfs pair是一对值 BFS一般框架 走迷宫思路参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;int bfs(string start) &#123; // 定义目标状态 string end = &quot;12345678x&quot;; // 定义队列和dist数组 queue&lt;string&gt; q; unordered_map&lt;string, int&gt; d; // 初始化队列和dist数组 q.push(start); d[start] = 0; // 转移方式 int dx[4] = &#123;1, -1, 0, 0&#125;, dy[4] = &#123;0, 0, 1, -1&#125;; while (q.size()) &#123; auto t = q.front(); q.pop(); // 记录当前状态的距离，如果是最终状态则返回距离 int distance = d[t]; if (t == end) return distance; // 查询x在字符串中的下标，然后转换为在矩阵中的坐标 int k = t.find(&#x27;x&#x27;); int x = k / 3, y = k % 3; for (int i = 0; i &lt; 4; i++) &#123; // 求转移后x的坐标 int a = x + dx[i], b = y + dy[i]; // 当前坐标没有越界 if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123; // 转移x swap(t[k], t[a * 3 + b]); // 如果t 没有在map中，则当前状态是第一次遍历，记录距离进map 中，入队 if (d.count(t) == 0) &#123; d[t] = distance + 1; q.push(t); &#125; // 还原状态，为下一种转换情况做准备 swap(t[k], t[a * 3 + b]); &#125; &#125; &#125; // 无法转换到目标状态，返回-1 return -1;&#125;int main() &#123; string c, start; // 输入起始状态 for (int i = 0; i &lt; 9; i++) &#123; cin &gt;&gt; c; start += c; &#125; cout &lt;&lt; bfs(start) &lt;&lt; endl; return 0;&#125; 删除C++字符串中的所有空格 八数码在一个 $3 × 3$的网格中，1 ~ 8 这 8 个数字和一个 x 恰好不重不漏地分布在这 $3 × 3$ 的网格中。 例如： 1231 2 3x 4 67 5 8 在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1231 2 34 5 67 8 x 例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1231 2 3 1 2 3 1 2 3 1 2 3x 4 6 4 x 6 4 5 6 4 5 67 5 8 7 5 8 7 x 8 7 8 x 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。 输入格式输入占一行，将 $3 × 3$ 的初始网格描绘出来。 例如，如果初始网格如下所示： 1231 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式输出占一行，包含一个整数，表示最少交换次数。 如果不存在解决方案，则输出 −1−1-1。 输入样例：12 3 4 1 5 x 7 6 8 输出样例119 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;int bfs(string start) &#123; // 定义目标状态 string end = &quot;12345678x&quot;; // 定义队列和dist数组 queue&lt;string&gt; q; unordered_map&lt;string, int&gt; d; // 初始化队列和dist数组 q.push(start); d[start] = 0; // 转移方式 int dx[4] = &#123;1, -1, 0, 0&#125;, dy[4] = &#123;0, 0, 1, -1&#125;; while (q.size()) &#123; auto t = q.front(); q.pop(); // 记录当前状态的距离，如果是最终状态则返回距离 int distance = d[t]; if (t == end) return distance; // 查询x在字符串中的下标，然后转换为在矩阵中的坐标 int k = t.find(&#x27;x&#x27;); int x = k / 3, y = k % 3; for (int i = 0; i &lt; 4; i++) &#123; // 求转移后x的坐标 int a = x + dx[i], b = y + dy[i]; // 当前坐标没有越界 if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123; // 如何寻找限制条件？？？a:这里不需要限制条件 // 转移x swap(t[k], t[a * 3 + b]); // 下面if 记录下宽搜的一种可能情况 // 如果t 没有在map中，则当前状态是第一次遍历，记录距离进map 中，入队 if (d.count(t) == 0) &#123; d[t] = distance + 1; q.push(t); &#125; // 还原状态，为下一种转换情况做准备 swap(t[k], t[a * 3 + b]); // 因为这个是宽搜，所以它必须交换回原来的值继续进行更新后续可能的情况 &#125; &#125; &#125; // 无法转换到目标状态，返回-1 return -1;&#125;int main() &#123; string c, start; // 输入起始状态 for (int i = 0; i &lt; 9; i++) &#123; cin &gt;&gt; c; start += c; &#125; cout &lt;&lt; bfs(start) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://breadwinners.top/tags/bfs/"}]},{"title":"前缀和和差分","slug":"前缀和和差分","date":"2023-04-16T16:00:00.000Z","updated":"2023-07-11T01:43:41.873Z","comments":true,"path":"2023/04/17/前缀和和差分/","link":"","permalink":"http://breadwinners.top/2023/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/","excerpt":"","text":"一维前缀和12345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; // 一维前缀和 int n, m; cin &gt;&gt; n &gt;&gt; m; int a[n + 1] = &#123;0&#125;, s[n] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; s[i] = s[i - 1] + a[i]; &#125; while (m--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 二维前缀和s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] (x2, y2) - (x1, y1) = s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1] &#x3D;&#x3D;注意&#x3D;&#x3D; 定义两个1w * 1w的数组，电脑爆了，100 * 100的过不了，1k * 1k比较理想 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#define N 1010using namespace std;int main() &#123; // 二维前缀和 int n, m, q; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;q); int a[N][N] = &#123;0&#125;, s[N][N] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;a[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; // 计算s[i][j] &#125; &#125; while (q--) &#123; int x1, x2, y1, y2; scanf(&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]);// 计算s[x1][y1] - s[x2][y2] &#125; return 0;&#125; 一维差分 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;iostream&gt;#define N 100010using namespace std;int a[N] = &#123;0&#125;, b[N] = &#123;0&#125;; // 只用了一个b数组void insert(int l, int r, int n) &#123; // 插入函数是精髓 b[l] += n; b[r + 1] -= n;&#125;int main() &#123; // 一维差分 int n, m; cin &gt;&gt; n &gt;&gt; m; int t; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t; insert(i, i, t); &#125; while (m--) &#123; int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; insert(l, r, k); &#125; for (int i = 1; i &lt;= n; i++) &#123; b[i] += b[i - 1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 差分矩阵 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;algorithm&gt;#include &lt;iostream&gt;#define N 1010using namespace std;int a[N][N] = &#123;0&#125;, b[N][N] = &#123;0&#125;;void insert(int x1, int y1, int x2, int y2, int k) &#123; b[x1][y1] += k; b[x2 + 1][y1] -= k; b[x1][y2 + 1] -= k; b[x2 + 1][y2 + 1] += k;&#125;int main() &#123; // 差分矩阵 ios::sync_with_stdio(false); int n, m, q, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; t; insert(i, j, i, j, t); &#125; &#125; while (q--) &#123; int x1, y1, x2, y2, k; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; k; insert(x1, y1, x2, y2, k); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + b[i][j]; cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 激光炸弹地图上有 N个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。 注意：不同目标可能在同一位置。 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R个位置的正方形内的所有目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，yx，yx，y 轴平行。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。 输出格式输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围$0≤R≤10^9$$0&lt;N≤10000$ $0≤Xi,Yi≤5000$$0≤Wi≤1000$ 输入样例：1232 10 0 11 1 1 输出样例：11 注意他这个目标是在线和线的交界上，不是格子的中心 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5010;int n, m;int s[N][N];int main()&#123; int cnt, R; cin &gt;&gt; cnt &gt;&gt; R; R = min(5001, R); // 因为最大的宽度为5000，而 R 的范围可能取到1e9,但是覆盖整个区域，5001就够了，所以这里得处理一下，否则后面大于5000，往右下角端点枚举时，循环不会执行，不会进行枚举ji&#x27;suan n = m = R; while (cnt -- ) &#123; int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x ++, y ++ ; n = max(n, x), m = max(m, y); s[x][y] += w; &#125; // 预处理前缀和 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; int res = 0; // 枚举所有边长是R的矩形，枚举(i, j)为右下角 for (int i = R; i &lt;= n; i ++ ) for (int j = R; j &lt;= m; j ++ ) res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; // 把n和m 都换成最大的临界值 5001可以AC，但是5010，就会报SegmentFault，5001虽然可以过，但是对于时间的耗费还是很高，建议还是定义n和m确定一下边界值，减少遍历次数//作者：yxc//链接：https://www.acwing.com/activity/content/code/content/163730/ K倍区间给定一个长度为 N 的数列，$A1,A2,…AN$，如果其中一段连续的子序列 $Ai,Ai+1,…Aj$之和是 K 的倍数，我们就称这个区间 $[i,j]$ 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？ 输入格式第一行包含两个整数 N 和K。 以下 N 行每行包含一个整数$Ai$。 输出格式输出一个整数，代表 K 倍区间的数目。 数据范围$1≤N,K≤100000, $$1≤Ai≤100000$ 输入样例125 21 2 3 4 5 输出样例16 每种余数有多少种，相同的一种余数就会对应一种答案 代码思路优化过程： 枚举 O(n3)可以很简单的写出暴力代码，直接三重循环 12345678for(int r = 1; r &lt;= n; r ++) for(int l = 1; l &lt;= r; l ++) &#123; int sum = 0; for(int i = l; i &lt;= r; i ++) sum += a[i]; if(sum % k == 0) ans ++; &#125; 枚举左右区间端点l,r，求出区间和sum判断是否为k的倍数，然后记录在答案ans上。可以看出第三重循环的作用就是算出区间[l,r]的和，所以用前缀和来优化这重循环。 前缀和 O(n2）预处理一下数组a[]，将前缀和存入s[]中，每次查询就只需要O(1)O(1)O(1)的时间了 12345for(int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + a[i]; // 求前缀和for(int r = 1; r &lt;= n; r ++) for(int l = 1; l &lt;= r; l ++) if((s[r] - s[l - 1]) % k == 0) ans ++; 但是这个时间还是会炸，所以还需要优化一层。 数学 O(n) 第二层循环的作用是枚举左端点，写出来就是(s[r] - s[0, r - 1]) % k = 0,当这个条件成立答案就加一。 化简: s[r]%k≡s[0,r−1]%k 现在这个式子的意思就是：在模k的情况下，之前所有点和当前点有都少个相等。所以再开一个额外的数组cnt[]记录每个前缀和取余k的余数的数量，遍历一遍就行了。 注意还得把cnt[0]赋值1，因为没有计算0%k==0这一项。 (s[ i ] - s[ j ]) % k 等价于s[ i ] % k的余数和s[ j ] % k的余数相同时的组合数C(s,2)&#x3D;s(s-1)&#x2F;2&#x3D;1+2+3+…+s-1,其中s为相同余数的数量。而针对余数为0的数，由于其本身就是k的倍数，所以其组合数为C(s,2)+s&#x3D;1+2+3+…+s，因此需要设置cnt[0] &#x3D; 1整合计算。 模拟过程 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;LL s[N], cnt[N];int main() &#123; int n, k; LL res = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; // 预处理前缀和 scanf(&quot;%lld&quot;, &amp;s[i]); s[i] += s[i - 1]; &#125; cnt[0] = 1; // 如果有直接 % k == 0，的，需要直接加上，不需要像其他的值一样，需要出现两次 %k 相等的值在加上 for (int i = 1; i &lt;= n; i++) &#123; res += cnt[s[i] % k]; cnt[s[i] % k]++; &#125; cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://breadwinners.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"http://breadwinners.top/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"并查集","slug":"并查集","date":"2023-04-15T16:00:00.000Z","updated":"2023-07-11T01:34:12.047Z","comments":true,"path":"2023/04/16/并查集/","link":"","permalink":"http://breadwinners.top/2023/04/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"合并集合123456789int find(int x)&#123; if (p[x] == x || p[p[x]] == p[x]) return p[x]; int r = find(p[x]); p[x] = r; return r;&#125; 12345int find(int x) &#123; // 这个函数的作用是寻找x的祖宗根节点，而不是父节点 if (x != p[x]) p[x] = find(p[x]); // 这其中实现了路径压缩的工作，但是不知道怎么实现的 return p[x];&#125; 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int p[N];int find(int x) &#123; // 这个函数的作用是寻找x的祖宗根节点，而不是父节点 if (x != p[x]) p[x] = find(p[x]); // 这其中实现了路径压缩的工作，但是不知道怎么实现的 return p[x];&#125;int main() &#123; // 并查集 int n, m; char op; int a, b; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; p[i] = i; &#125; while (m--) &#123; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if (op == &#x27;M&#x27;) &#123; p[find(a)] = find(b); // 必须找打根节点然后合并,把a合并到b，不是p[find(a)] = p[find(b)],虽然这样也能对 &#125; else if (op == &#x27;Q&#x27;) &#123; if (find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 连通块中点的数量1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010 + 10;int p[N], cnt[N];int find(int x) &#123; if (x != p[x]) p[x] = find(p[x]); return p[x];&#125;int main() &#123; // 连通块中点的个数 int n, m, a, b; string op; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; // 为什么从1开始？从0开始也是可以的 p[i] = i; cnt[i] = 1; &#125; while (m--) &#123; cin &gt;&gt; op; if (op[0] == &#x27;C&#x27;) &#123; cin &gt;&gt; a &gt;&gt; b; if (find(a) == find(b)) continue; cnt[find(b)] += cnt[find(a)]; // **必须先改节点数目的大小才能合并集合，先合并集合，节点的数量就变了** p[find(a)] = find(b); // erroneous cnt[b] += cnt[a]; &#125; else if (op[1] == &#x27;1&#x27;) &#123; // 查询a, b是否在一个连通块中 cin &gt;&gt; a &gt;&gt; b; if (find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; else if (op[1] == &#x27;2&#x27;) &#123; cin &gt;&gt; a; // erroneous puts(&quot;&quot; + cnt[x]); cout &lt;&lt; cnt[find(a)] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; return 0;&#125; 食物链 核心代码12345678910int find(int x)&#123; if(p[x] != x) &#123; int tmp = find(p[x]); d[x] += d[p[x]]; // 加上父节点到父父节点的距离 p[x] = tmp; &#125; return p[x];&#125; 注意事项，即明白 d[i] 的含义看了几位同学分享的代码还有题解，对于d[i]的理解其实是有误的，d[i]的正确理解，应是第 i 个节点到其父节点距离，而不是像有些同学所讲的，到根节点的距离！！这点大家一定要搞清楚，之所以有这样的误会，是因为find()函数进行了路径压缩，当查询某个节点 i 时，如果 i 的父节点不为根节点的话，就会进行递归调用，将 i 节点沿途路径上所有节点均指向父节点，此时的 d[i] 存放的是 i 到父节点，也就是根节点的距离。下面为了更好的理解函数调用过程以及d[i]的变化，我将插图分享给大家 网络分析小明正在做一个网络实验。 他设置了 n 台电脑，称为节点，用于收发和存储数据。 初始时，所有节点都是独立的，不存在任何连接。 小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信了。 两个节点如果存在网线连接，称为相邻。 小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接或间接相邻的节点都收到了信息。 所有发送和接收的节点都会将信息存储下来。 一条信息只存储一次。 给出小明连接和测试的过程，请计算出每个节点存储信息的大小。 输入格式 输入的第一行包含两个整数 n,m分别表示节点数量和操作数量。 节点从 1 至 n 编号。 接下来 m 行，每行三个整数，表示一个操作。 如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 a &#x3D; b 时，表示连接了一个自环，对网络没有实质影响。 如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。 输出格式 输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示进行完上述操作后节点 1 至节点 n 上存储信息的大小。 数据范围 1≤n≤100001≤m≤10^5^1≤t≤100 输入样例1： 1234567894 81 1 22 1 102 3 51 4 12 2 21 1 21 2 42 2 1 输出样例1： 113 13 5 3 合并时不创建新的节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 10010;int n, m;int p[N], d[N];int find(int x) &#123; if (p[x] == x || p[p[x]] == p[x]) return p[x]; int r = find(p[x]); d[x] += d[p[x]]; p[x] = r; return r;&#125;int main() &#123; // https://www.acwing.com/problem/content/2071/ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i] = i; while (m--) &#123; int t, a, b; scanf(&quot;%d%d%d&quot;, &amp;t, &amp;a, &amp;b); if (t == 1) &#123; a = find(a), b = find(b); // 一定要先找到祖宗节点再判断是否是属于同一棵树 if (a != b) &#123; d[a] -= d[b]; p[a] = b; &#125; &#125; else &#123; a = find(a); d[a] += b; &#125; &#125; for (int i = 1; i &lt;= n; i++) if (i == find(i)) // 注意是 i ，不是从p[i]找 printf(&quot;%d &quot;, d[i]); else printf(&quot;%d &quot;, d[i] + d[find(i)]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"连通块","slug":"连通块","permalink":"http://breadwinners.top/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"}]},{"title":"贪心问题","slug":"贪心问题","date":"2023-04-14T16:00:00.000Z","updated":"2023-07-11T01:46:36.130Z","comments":true,"path":"2023/04/15/贪心问题/","link":"","permalink":"http://breadwinners.top/2023/04/15/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"活动安排问题问题描述和分析设有n个活动的集合E&#x3D;{1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间Si和一个结束时间fi,且si &lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。 活动安排问题： 要在所给的活动集合中选出最大的相容活动子集合。 活动安排问题的关键是如何按照一定的顺序安排活动，使得选出的活动间相容并能安排尽量多的活动。 例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下： i 1 2 3 4 5 6 7 8 9 10 11 s[i] 1 3 0 5 3 5 6 8 8 2 12 f[i] 4 5 6 7 8 9 10 11 12 13 14 由于输入的活动以其完成时间的非减序排列，所以每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。 若被检查的活动i的开始时间Si小于最近选择的活动j的结束时间fi****，则不选择活动i，否则选择活动i加入集合A中。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int s[12] = &#123;0, 1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12&#125;, f[12] = &#123;0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14&#125;;bool a[11];int n = 11;int Selector() &#123; a[1] = true; int j = 1; int count = 1; for (int i = 2; i &lt;= n; i++) &#123; if (s[i] &gt;= f[j]) &#123; // 如果活动 i 的开始时间晚于活动 j 的结束时间，则选择活动 i，否则，舍弃活动 i a[i] = true; j = i; count++; &#125; else a[i] = false; &#125; return count;&#125;int main() &#123; cout &lt;&lt; &quot;活动序号：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 11; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl &lt;&lt; &quot;活动开始时间：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 11; i++) cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl &lt;&lt; &quot;活动结束时间：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 11; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;; puts(&quot;\\n**********************&quot;); int count = Selector(); cout &lt;&lt; &quot;一共选择个&quot; &lt;&lt; count &lt;&lt; &quot;活动如下：&quot; &lt;&lt; endl; for (int i = 0; i &lt;= n; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; &quot; &quot;; return 0;&#125; 注意：此题目要求活动的结束时间从小到大排序，所以在实际输入的时候最好用STL sort函数对其进行升序排序，数据可以用结构体或者vector&lt;int , int&gt; 存储 多机调度贪心算法参考 ####问题描述 设有n个独立的作业&#123;1, 2, …, n&#125;，由m台相同的机器`&#123;M1, M2, …, Mm&#125;`进行加工处理，作业i所需的处理时间为ti（1≤i≤n），每个作业均可在任何一台机器上加工处理，但不可间断、拆分。多机调度问题要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。 设7个独立作业&#123;1, 2, 3, 4, 5, 6, 7&#125;由3台机器`&#123;M1, M2, M3&#125;`加工处理，各作业所需的处理时间分别为&#123;2, 14, 4, 16, 6, 5, 3&#125;。 求解思路 贪心法求解多机调度问题的贪心策略是最长处理时间作业优先，即把处理时间最长的作业分配给最先空闲的机器，这样可以保证处理时间长的作业优先处理，从而在整体上获得尽可能短的处理时间。按照最长处理时间作业优先的贪心策略，当m≥n时，只要将机器i的[0, ti)时间区间分配给作业i即可；当m＜n时，首先将n个作业依其所需的处理时间从大到小排序，然后依此顺序将作业分配给空闲的处理机。 设n个作业的处理时间存储在数组t[n]中，m台机器的空闲时间存储在数组d[m]中，集合数组S[m]存储每台机器所处理的作业，其中S[i]表示机器i所处理的作业，算法如下： 思路图解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define N 10 // 定义最大作业数量int d[N]; // 定义机器的处理作业的总时长和int S[N][N]; // 记录每台机器处理的作业，第一个下标是机器编号，每一维数组中存的是处理的作业的编号struct work &#123; // 定义一个结构体，记录作业处理时间 int hour; // 作业时间 int number; // 原顺序&#125;;bool cmp(work x, work y) &#123; return x.hour &gt; y.hour;&#125;work t[N];void MultiMachine(int n, int m) &#123; int rear[N]; // 队尾下标，用来指向S数组中下一个作业的位置 for (int i = 0; i &lt; m; i++) &#123; // 安排前m个作业 S[i][0] = t[i].number; rear[i] = 0; d[i] = t[i].hour; &#125; for (int i = m; i &lt; n; i++) &#123; // 一次安排余下几个作业, k用来记录当前处理任务最少时间机器的下标 int k = 0; for (int j = 0; j &lt; m; j++) // 查找最先空闲的机器 if (d[j] &lt; d[k]) k = j; rear[k]++; S[k][rear[k]] = t[i].number; d[k] += t[i].hour; &#125; // 输出结果 for (int i = 0; i &lt; m; i++) &#123; printf(&quot;机器%d处理:&quot;, i + 1); for (int j = 0; S[i][j] &gt; 0; j++) &#123; printf(&quot;作业%d\\t&quot;, S[i][j]); &#125; printf(&quot;处理时间:%d\\n&quot;, d[i]); printf(&quot;\\n&quot;); &#125;&#125;int main() &#123; int n; // 作业个数 int m; // 机器个数 printf(&quot;请输入待处理的作业个数:&quot;); scanf(&quot;%d&quot;, &amp;n); printf(&quot;请输入作业需要处理的时间:&quot;); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;t[i].hour); t[i].number = i + 1; &#125; sort(t, t + n, cmp); // 将结构体数组进行从大到小的排序，序号存在number中 printf(&quot;请输入机器的个数:&quot;); scanf(&quot;%d&quot;, &amp;m); // 将数组d初始化为0 for (int i = 0; i &lt; m; i++) &#123; d[i] = 0; &#125; MultiMachine(n, m); return 0;&#125;/*716 5 2 14 6 4 334 2 1 3 22 */ 得到小的数输入：178543 4样例输出：13 那么刚拿到这道题如何去思考呢？我们可以先试着找规律。如果要从178543中取出1个数，使这个数最小，应该取……8如果要从17543中取出1个数，使这个数最小，应该取……7如果要从1543中取出1个数，使这个数最小，应该取……5……可以发现：1，7，8是一个不降序数列（有相等的升序），也就是逐渐变多，而8，5，4，3是一个不升序数列（有相等的降序），逐渐减少。8正好是升序数列的最后一个，也是降序数列的第一个。 我们只需要找到第一个&#x3D;&#x3D;升序数列的末尾&#x3D;&#x3D;并取出它就可以算成功完成了“局部的最优解”，再通过这个继续取出更多的数 得到大得数输入： 16403 1 &lt; 6，删除1，得6403 0 &lt; 3 ， 删除0，得643 都是降序的，删除6，得43 都是降序的，删除4，的3 每次删除&#x3D;&#x3D;升序的第一个数字&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int shanshu(string &amp;a, int k) &#123; int n = a.size(), j = 0; while (k &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; // 检测它开始降序的时候，就是 升序序列的最后一个数 ，删除 for (int j = i; j &lt; n; j++) &#123; a[j] = a[j + 1]; &#125; n--; break; // 忘记退出循环了 &#125; else if (i == n - 1) &#123; // 遍历到最后仍然没有发现开始降序，也就是整个序列已经是升序的序列，直接删除最后一个序列 n--; break; &#125; &#125; k--; &#125; return n;&#125;int main() &#123; // 删除 k 个数字后需要得到最小的数字，删除升序序列的最后一个数 string st; int n, startIndex = 0; cin &gt;&gt; st &gt;&gt; n; n = shanshu(st, n); st.erase(0, st.find_first_not_of(&#x27;0&#x27;)); // 删除“0” /* for (int i = 0; i &lt; n; i++) &#123; // 对删完后的数字的前导零进行处理 if (st[i] == &#x27;0&#x27;) &#123; startIndex++; &#125; &#125; */ for (int i = startIndex; i &lt; n; i++) &#123; cout &lt;&lt; st[i]; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"greedy","slug":"greedy","permalink":"http://breadwinners.top/tags/greedy/"}]},{"title":"费解的开关","slug":"费解的开关","date":"2023-04-13T16:00:00.000Z","updated":"2023-07-11T01:35:58.608Z","comments":true,"path":"2023/04/14/费解的开关/","link":"","permalink":"http://breadwinners.top/2023/04/14/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/","excerpt":"","text":"费解的开关25 盏灯排成一个 5×5 的方形。 每一个灯都有一个开关，游戏者可以改变它的状态。 每一步，游戏者可以改变某一个灯的状态。 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。 下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 666 步以内使所有的灯都变亮。 输入格式第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。 以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。 每组数据描述了一个游戏的初始状态。 各组数据间用一个空行分隔。 输出格式一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。 数据范围$0&lt;n≤500$ 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例： 12332-1 每一行的暗灯都由下面一行去点亮 为什么要枚举第一行的状态？ 我觉得吧，枚举第一行的所有按法是用来减少步数的，我之前一直觉得从第二行直接看就好，但是从第二行开始其实就已经固定了最后的答案，这样的解不一定是最少的甚至可能超出范围而没有解。 所以，枚举第一行的意义是：不需要在意第一行的灯是灭是暗，只需把第一行的按法枚举一遍，也就是我们说的 “操作”，每个位置都有两种选择，按(用1表示)或者不按(用0表示)，遍历这32种操作引发的情况，每一次再通过res &#x3D; min(res, step);把最小步数存一下，就能找到最优解 后面的op从1–31，因为是位运算，所以是1–31的二进制和1的二进制从右向左进行与的操作，比如10100(20)的op，意思是第2、4位（右到左01234）需要按，不是代表灯有没有亮，32种状态其实是哪些灯要按，一种op对应一种固定的按法，所以是&amp;1=&#x3D;1或者^1=&#x3D;0。同理，调用方法这里应该是turn(0, 4 - i) 小寄巧：字符数0的二进制为 11000 ， 字符数1的二进制为 11001 ，二者的更换操作可以设置为x ^= 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 6;int dx[N] = &#123;-1, 0, 1, 0, 0&#125;, dy[N] = &#123;0, 1, 0, -1, 0&#125;;char g[N][N], backup[N][N];// 这个操作是把(x, y)以及上下左右的灯都变成相反的颜色void turn(int x, int y) &#123; for (int i = 0; i &lt; 5; i++) &#123; int a = x + dx[i], b = y + dy[i]; // 如果在边界外边，直接忽略即可 if (a &lt; 0 || a &gt;= 5 || b &lt; 0 || b &gt;= 5) continue; g[a][b] ^= 1; // 异或，不同的时候就变成相反的数 &#125;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; // 按行输入，把每一行当成一个字符串 for (int i = 0; i &lt; 5; i++) cin &gt;&gt; g[i]; int res = 10; // 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍 // 按每种情况的第一行，去遍历接下来的行 // 枚举32种第一行的按法只是可能会减少步数，如果直接从第二行开始答案一定是固定的了，找不到最优解或者可能没有解 for (int op = 0; op &lt; 32; op++) &#123; // 我在对这种情况操作的时候，得先备用一下 // 把原始数组备份一下，然后操作g，操作完了还原，然后再操作 memcpy(backup, g, sizeof g); int step = 0; // 第一行的按法(在这里 1 表示按了, 0 表示不按)，这里只是为了输出第一行按完之后的状态 for (int i = 0; i &lt; 5; i++) if (op &gt;&gt; i &amp; 1) // 数字2 对应了 00010 表示第2个位置的按一下 // 00010 &gt;&gt; 1 &amp; 1 是1 所以turn(0, 1) 就是第一行第二个位置 &#123; // 数字3 对应了00011 表示第1 和第2个位置的按一下 step++; turn(0, 4 - i); // 这里的op从1~31，因为是位运算，所以是1~31的二进制和1的二进制从右向左进行与的操作， // 比如10100(20)的op，意思是第2、4位（右到左01234）需要按，不是代表灯有没有亮， // 32种状态其实是哪些灯要按，一种op对应一种固定的按法，所以是&amp;1==1或者^1==0。同理，调用方法这里应该是turn(0,4-i) ; &#125; // 然后通过第一行按完之后的状态，按234行 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 5; j++) if (g[i][j] == &#x27;0&#x27;) &#123; step++; turn(i + 1, j); // 如果这个位置是灭的，就按下一行对应的位置 &#125; bool dark = false; for (int j = 0; j &lt; 5; j++) if (g[4][j] == &#x27;0&#x27;) &#123; dark = true; break; &#125; // 对于32种情况的这一种，如果所有的全亮就记录下步数(事实上只记录了最后一行是否dark) if (!dark) res = min(res, step); memcpy(g, backup, sizeof g); &#125; if (res &gt; 6) res = -1; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://breadwinners.top/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"模拟","slug":"模拟","permalink":"http://breadwinners.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"归并排序和逆序对","slug":"归并排序和逆序对","date":"2023-04-13T16:00:00.000Z","updated":"2023-07-11T01:49:14.182Z","comments":true,"path":"2023/04/14/归并排序和逆序对/","link":"","permalink":"http://breadwinners.top/2023/04/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%86%E5%BA%8F%E5%AF%B9/","excerpt":"","text":"归并排序归并排序：归并排序采用分治的思想，将原数组分解成多个相似的子数组，进行递归解决，最后逐渐合并成排序好的数组 归并排序的核心是合并两个数组 算法过程： bilibili视频讲解 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;iostream&gt;#define N 100using namespace std;int tmp[N];void merge_sort(int q[], int l, int r);int main() &#123; int n; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;void merge_sort(int q[], int l, int r) &#123; if (l &gt;= r) &#123; // 只有一个或者没有则不用排序 return; &#125; // 对数组进行分割 int mid = l + r &gt;&gt; 1; // 取中间值为分界 merge_sort(q, l, mid); // 左边区间右边区间进行递归 merge_sort(q, mid + 1, r); // 对分割的数组进行排序 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i] &lt; q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; &#125; while (i &lt;= mid) &#123; tmp[k++] = q[i++]; &#125; while (j &lt;= r) &#123; tmp[k++] = q[j++]; &#125; // 将排好序的数组存回来 for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];&#125; 逆序对的数量在归并排序的过程中，两个子数组 成为 排序好的子数组，当右边的数组元素进入有序序列时，说明其左边的元素都是比它小的，因为每次都是挑选两个有序数组中的最小的元素进入心得有序序列，也只有右边的元素进入有序序列时，才可以确定有逆序对存在 右边元素进入新的有序序列时，可以得出暂且的逆序对为mid - i + 1 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;typedef long long LL; // 定义long long 类型const int N = 1e5 + 10;int a[N], tmp[N];LL merge_sort(int a[], int l, int r) &#123; if (l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(a, l, mid) + merge_sort(a, mid + 1, r); // 递归排序！（将序列一直分，拆封成单个，即为有序） int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; // 归并，整理逆序对的过程 if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else &#123; res += mid - i + 1; // 满足逆序对条件 tmp[k++] = a[j++]; &#125; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j]; return res;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); cout &lt;&lt; merge_sort(a, 0, n - 1) &lt;&lt; endl; return 0;&#125; 参考博客 哔哩哔哩学习","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"sort","slug":"sort","permalink":"http://breadwinners.top/tags/sort/"}]},{"title":"单链表","slug":"数据结构","date":"2023-04-12T16:00:00.000Z","updated":"2023-07-11T01:45:22.116Z","comments":true,"path":"2023/04/13/数据结构/","link":"","permalink":"http://breadwinners.top/2023/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"单链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int N = 100010;int idx, head, n[N], ne[N];int a;void add_head(int x) &#123; // 单链表的操作 n[idx] = x; ne[idx] = head; head = idx++;&#125;void add(int k, int x) &#123; n[idx] = x; ne[idx] = ne[k]; ne[k] = idx++;&#125;void remove(int k) &#123; ne[k] = ne[ne[k]];&#125;int main() &#123; head = -1; idx = 0; cin &gt;&gt; a; while (a--) &#123; string op; int k, x; cin &gt;&gt; op; if (op == &quot;D&quot;) &#123; cin &gt;&gt; k; if (!k) head = ne[head]; else remove(k - 1); &#125; else if (op == &quot;H&quot;) &#123; cin &gt;&gt; x; add_head(x); &#125; else if (op == &quot;I&quot;) &#123; int k, x; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; n[i] &lt;&lt; &quot; &quot;; return 0;&#125; 双链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int m;int e[N], l[N], r[N];int idx;//! 初始化void init() &#123; l[1] = 0, r[0] = 1; //* 初始化 第一个点的右边是 1 第二个点的左边是 0 idx = 2; //! idx 此时已经用掉两个点了&#125;//* 在第 K 个点右边插入一个 Xvoid add(int k, int x) &#123; e[idx] = x; l[idx] = k; r[idx] = r[k]; // todo 这边的 k 不加 1 ， 输入的时候 k+1 就好 l[r[k]] = idx; r[k] = idx; idx++;&#125; //! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)//*删除第 k个 点void remove(int k) &#123; r[l[k]] = r[k]; l[r[k]] = l[k];&#125;int main(void) &#123; ios::sync_with_stdio(false); cin &gt;&gt; m; init(); while (m--) &#123; string op; cin &gt;&gt; op; int k, x; if (op == &quot;R&quot;) &#123; cin &gt;&gt; x; add(l[1], x); //! 0和 1 只是代表 头和尾 所以 最右边插入 只要在 指向 1的 那个点的右边插入就可以了 &#125; else if (op == &quot;L&quot;) //! 同理 最左边插入就是 在指向 0的数的左边插入就可以了 也就是可以直接在 0的 有右边插入 &#123; cin &gt;&gt; x; add(0, x); &#125; else if (op == &quot;D&quot;) &#123; cin &gt;&gt; k; remove(k + 1); &#125; else if (op == &quot;IL&quot;) &#123; cin &gt;&gt; k &gt;&gt; x; add(l[k + 1], x); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k + 1, x); &#125; &#125; for (int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;; return 0;&#125; 单调栈123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010;int stk[N], p = -1;int main() &#123; // 单调栈 https://www.acwing.com/problem/content/832/ int n, x; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x; while (stk[p] &gt;= x &amp;&amp; p != -1) &#123; // 删除栈中比 x 大的元素，保证栈中的元素是单调递增的 p--; &#125; if (p != -1) cout &lt;&lt; stk[p] &lt;&lt; &#x27; &#x27;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; stk[++p] = x; &#125; return 0;&#125; ###运用单调队列解决滑动窗口问题（运用的数据结构实际上是双端队列） 朴素做法： 就是两层循环 外层循环每一个数 内循环窗口内每一个值，这样的时间复杂度是O(nm); 这样我们就可以用 单调队列来优化 可将时间复杂度降为 O(n)。 举例 这是我们准备求的一个数组 红色是元素值 灰色是数组下标 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int q[N], a[N];int n, k;int main() &#123; // 单调队列涉及到的滑动窗口问题 cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // 窗口维护单调递增队列 队头为最小值 int hh = 0, tt = -1; for (int i = 0; i &lt; n; i++) &#123; if (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + 1) hh++; // 队头超出窗口出队 因为每次只入一个元素 所以用if即可 while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; // 队列单调递增 q[++tt] = i; // 记住q里面存的是下标！！ 要输出元素应该是 a[q[hh]] if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;; // 窗口内达到k个 &#125; cout &lt;&lt; endl; // 窗口维护单调递减队列 队头为最大值 hh = 0, tt = -1; for (int i = 0; i &lt; n; i++) &#123; if (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + 1) hh++; // 队头超出窗口出队 因为每次只入一个元素 所以用if即可 while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; // 队列单调递增 q[++tt] = i; // 记住q里面存的是下标！！ 要输出元素应该是 a[q[hh]] if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;; // 窗口内达到k个 &#125; cout &lt;&lt; endl; return 0;&#125; 大于删除对位元素是因为要保证当前的窗格的值是最大的 小于删除是要因为后续可能的窗口由于前面较大的值出队，就成了最大值 日志统计小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。 其中每一行的格式是： 1ts id 表示在 tststs 时刻编号 ididid 的帖子收到一个”赞”。 现在小明想统计有哪些帖子曾经是”热帖”。 如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。 具体来说，如果存在某个时刻 T满足该帖在 [T,T+D)这段时间内(注意是左闭右开区间)收到不少于 KKK 个赞，该帖就曾是”热帖”。 给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 输入格式 第一行包含三个整数 N,D 以下 N 行每行一条日志，包含两个整数 ts 和 id。 输出格式 按从小到大的顺序输出热帖 id。 每个 id 占一行。 数据范围 1≤K≤N≤10^5^0≤ts,id≤10^5^1≤D≤10000 输入样例： 123456787 10 20 10 1010 1010 19 1100 3100 3 输出样例： 1213 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100010;int n, d, k;PII logs[N];int cnt[N];bool st[N]; int main() &#123; int n, d, k; cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; for (int i = 0;i &lt; n;i++) cin &gt;&gt; logs[i].x &gt;&gt; logs[i].y; sort(logs, logs + n); for (int i = 0, j = 0;i &lt; n;i++) &#123; int id = logs[i].y; cnt[id]++; // cnt数组维护的是窗口中帖子的数量 while (logs[i].x - logs[j].x &gt;= d) &#123; cnt[logs[j].y]--; j++; &#125; if (cnt[id] &gt;= k) st[id] = true; &#125; for (int i = 0;i &lt;= 100000;i++) if (st[i]) cout &lt;&lt; i &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组单链表","slug":"数组单链表","permalink":"http://breadwinners.top/tags/%E6%95%B0%E7%BB%84%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://breadwinners.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Trie树","slug":"Trie树","date":"2023-04-09T16:00:00.000Z","updated":"2023-07-11T01:32:02.889Z","comments":true,"path":"2023/04/10/Trie树/","link":"","permalink":"http://breadwinners.top/2023/04/10/Trie%E6%A0%91/","excerpt":"","text":"高效存储字符串集合 从左往右看，构成了字典树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int N = 10;// const int N = 100010;int son[N][26]; // 26是指 每个节点最多有26个子节点int cnt[N]; // 以当前字符结尾的单词个数int idx; // 当前使用的下标,下标是0的点即是根节点也是空节点，idx决定了不同的单词对应不同的p，idx始终递增，每个单词会有不同的idxchar str[N];void insert(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; // 遍历字符串，字符串末尾是&#x27;\\0&#x27;多以可以用str[i]直接判断是不是结尾了 int u = str[i] - &#x27;a&#x27;; // 把26个字母映射到0-25 if (!son[p][u]) son[p][u] = ++idx; // 如果p这个节点不存在u子节点的话 就要把他创建出来 p = son[p][u]; // 向前走 &#125; cnt[p]++; // 以p这个节点结尾的单词+1；&#125;int query(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; // 到底了，查无此单词 p = son[p][u]; // 往下走 &#125; return cnt[p]; // 返回查到的单词个数&#125;// void printdebug(int n) &#123;// if (n == 5) &#123;// for (int i = 0; i &lt; 10; i++) &#123;// for (int j = 0; j &lt; 10; j++)// cout &lt;&lt; son[i][j] &lt;&lt; &#x27; &#x27;;// cout &lt;&lt; &#x27;\\n&#x27;;// &#125;// &#125;// &#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; char op[2]; scanf(&quot;%s%s&quot;, op, str); if (op[0] == &#x27;I&#x27;) insert(str); else printf(&quot;%d\\n&quot;, query(str)); // printdebug(n); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://breadwinners.top/tags/Trie/"}]},{"title":"哈夫曼","slug":"哈夫曼","date":"2023-04-09T16:00:00.000Z","updated":"2023-07-11T01:41:32.440Z","comments":true,"path":"2023/04/10/哈夫曼/","link":"","permalink":"http://breadwinners.top/2023/04/10/%E5%93%88%E5%A4%AB%E6%9B%BC/","excerpt":"","text":"在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。 达达决定把所有的果子合成一堆。 每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。 可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。 达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。 假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。 例如有 3 种果子，数目依次为 1，2，9。 可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。 接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。 所以达达总共耗费体力&#x3D;3+12&#x3D;15。 可以证明 15 为最小的体力耗费值。 输入格式输入包括两行，第一行是一个整数 n，表示果子的种类数。 第二行包含 n 个整数，用空格分隔，第 i 个整数 ai 是第 i 种果子的数目。 输出格式输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。 输入数据保证这个值小于 2^31^。 数据范围1≤n≤10000,1≤ai≤20000 输入样例：123 1 2 9 输出样例：115 代码： 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 20;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; int n, t, sum = 0, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; t; heap.push(t); &#125; while (heap.size() &gt; 1) &#123; a = heap.top(); heap.pop(); b = heap.top(); heap.pop(); sum += a + b; heap.push(a + b); &#125; cout &lt;&lt; sum; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://breadwinners.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"heap","slug":"heap","permalink":"http://breadwinners.top/tags/heap/"}]},{"title":"frp内网穿透","slug":"centos配置内网穿透","date":"2023-04-09T16:00:00.000Z","updated":"2023-07-11T02:09:06.639Z","comments":true,"path":"2023/04/10/centos配置内网穿透/","link":"","permalink":"http://breadwinners.top/2023/04/10/centos%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"centos7使用frp搭建内网穿透写的很好 前提条件：部署FRP软件的虚拟机需可以访问互联网，并关闭操作系统防火墙。 虚拟机成功部署FRP后即可通过SSH访问虚拟机。 下载 FRP软件 ​ 下载地址：https://github.com/fatedier/frp/releases 1wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz 解压 1tar -xvf frp_0.36.2_linux_amd64.tar.gz 进入解压目录 1cd frp_0.36.2_linux_amd64 配置frpc.ini 1234vim frpc.ini[common]bind_port = 8000 服务器运行 1./frps -c ./frps.ini 添加开机自启动 123456789101112131415161718vim /usr/lib/systemd/system/frp.service[Unit]Description=The nginx HTTP and reverse proxy serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=simpleExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.iniKillSignal=SIGQUITTimeoutStopSec=5KillMode=processPrivateTmp=trueStandardOutput=syslogStandardError=inherit[Install]WantedBy=multi-user.target ExecStart的内容请根据自己frp安装目录修改。 12systemctl daemon-reload # 设置开机自启动systemctl enable frp 1systemctl start frp # 启动frp 查看frp是否启动 1ps aux | grep frps 本地服务器配置 下载frp 1wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz 解压进入 12tar -xvf frp_0.36.2_linux_amd64.tar.gzcd frp_0.36.2_linux_amd64 配置frpc.ini 1vim frpc.ini 把下面的内容复制到里面 12345678910[common]server_addr = 666.666.666.66 # 外网可以访问的服务器ipserver_port = 8000 # 本地服务器与阿里云服务器连接的端口（需要在阿里云开通该端口）[web]type = tcplocal_ip = 127.0.0.1local_port = 8080remote_port = 6666 # web服务与阿里云服务器连接的端口 运行 1./frpc -c ./frpc.ini 访问 阿里云服务器:remote_port端口&#x2F;web服务路径例如：88.888.888.88:6666&#x2F;report&#x2F;allure-html&#x2F;index.html 后台运行frp服务： 服务端： nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; 客户端： nohup ./frpc -c frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp; 说明：&gt;/dev/null 2&gt;&amp;1 &amp;，表示丢弃。 内网穿透","categories":[{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://breadwinners.top/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://breadwinners.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"","slug":"Bugs","date":"2023-04-08T16:00:00.000Z","updated":"2023-07-11T01:25:18.225Z","comments":true,"path":"2023/04/09/Bugs/","link":"","permalink":"http://breadwinners.top/2023/04/09/Bugs/","excerpt":"","text":"Ctrl + D CV 复制出的代码总会出点问题，有的相似的内容忘记改，比如 12res1 = max(res1, a[i]);res2 = max(res1, a[j]); 第二个res2应该是要min函数 &#x3D;&#x3D;习惯了使用n--读入数据，以至于到后面循环遍历数据的时候，n的值变成了 -1 不可用这个for i n 来遍历&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b) &#123; int t = 0; vector&lt;int&gt; C; for (int i = 0; i &lt; A.size() || t; i++) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) // 数据运算有必要清理前导零 C.pop_back(); return C;&#125;int main() &#123; string st; int b; vector&lt;int&gt; A; cin &gt;&gt; st &gt;&gt; b; for (int i = st.length() - 1; i &gt;= 0; i++) &#123; // 习惯性写成了i++，实际上这个题目中应该是i-- A.push_back(st[i] - &#x27;0&#x27;); &#125; vector&lt;int&gt; C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i++) &#123; // 习惯性写成了i++，实际上这个题目中应该是i-- cout &lt;&lt; C[i]; &#125; return 0;&#125; 排序，可能就会涉及到复原数组，像连号区间 涉及到数量问题，可能会爆int 递增三元组 while循环的指针，一定要判断指针不出界才继续循环 递增三元组 using namespace std 要放在typedef上面，否则会报错 结构体数组的排序方式 stable_sort 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;stdio.h&gt;int main()&#123; std::string str = &quot;668&quot;; int num = 0; sscanf(str.c_str(), &quot;%d&quot;, &amp;num); std::cout &lt;&lt; num; return 0;&#125;#include &lt;iostream&gt;int main()&#123; int num = 123; std::cout &lt;&lt; std::to_string(num); return 0;&#125; 爆int123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1000010;typedef long long LL;LL res;int n;LL a[N]; // 十年OI一场空，不开long long 见祖宗int main() &#123; // https://www.acwing.com/problem/content/description/2878/ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; LL t; for (int i = 0; i &lt; n - 1; i++) &#123; t = a[i] * a[i + 1]; res += t; a[i + 1] += a[i]; &#125; cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/tags/bugs/"}]},{"title":"STL","slug":"STL","date":"2023-04-07T16:00:00.000Z","updated":"2023-07-11T01:29:30.909Z","comments":true,"path":"2023/04/08/STL/","link":"","permalink":"http://breadwinners.top/2023/04/08/STL/","excerpt":"","text":"map中count方法123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; map&lt;int,string&gt;maps; if(maps.find(1)==maps.end()) &#123; cout&lt;&lt;&quot;没有1这个元素&quot;&lt;&lt;endl; &#125; if(maps.count(1)==0) &#123; cout&lt;&lt;&quot;没有1这个元素&quot;&lt;&lt;endl; &#125; //添加元素1 maps[1]=&quot;one&quot;; if(maps.find(1)!=maps.end()) &#123; cout&lt;&lt;&quot;有1这个元素&quot;&lt;&lt;endl; &#125; if(maps.count(1)) &#123; cout&lt;&lt;&quot;有1这个元素&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://breadwinners.top/tags/STL/"}]},{"title":"哈希表","slug":"HashMap","date":"2023-04-07T16:00:00.000Z","updated":"2023-07-11T01:27:57.785Z","comments":true,"path":"2023/04/08/HashMap/","link":"","permalink":"http://breadwinners.top/2023/04/08/HashMap/","excerpt":"","text":"拉链法模的数应该是质数 一定要记得memset 维护一个集合，支持如下几种操作： I x，插入一个数 x； Q x，询问数 x 是否在集合中出现过； 现在要进行 N 次操作，对于每个询问操作输出对应的结果。 输入格式第一行包含整数 N，表示操作数量。 接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。 输出格式对于每个询问指令 Q x，输出一个询问结果，如果 xxx 在集合中出现过，则输出 Yes，否则输出 No。 每个结果占一行。 数据范围1≤N≤10^5^−10^9^≤x≤10^9^ 输入样例：1234565I 1I 2I 3Q 2Q 5 输出样例：12YesNo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 3; // 取大于1e5的第一个质数，取质数冲突的概率最小 可以百度//* 开一个槽 hint h[N], e[N], ne[N], idx; // 邻接表void insert(int x) &#123; // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx++;&#125;bool find(int x) &#123; // 用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数 int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) &#123; if (e[i] == x) &#123; return true; &#125; &#125; return false;&#125;int n;int main() &#123; cin &gt;&gt; n; memset(h, -1, sizeof h); // 将槽先清空 空指针一般用 -1 来表示 while (n--) &#123; string op; int x; cin &gt;&gt; op &gt;&gt; x; if (op == &quot;I&quot;) &#123; insert(x); &#125; else &#123; if (find(x)) &#123; puts(&quot;Yes&quot;); &#125; else &#123; puts(&quot;No&quot;); &#125; &#125; &#125; return 0;&#125; 开放寻址法开的数组应该是数据范围的三倍 取一个在数据范围外的数，比如null &#x3D; ox3f3f3f3f，null＞10^9^，表示为空（4个3f） 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 2e5 + 3;const int null = 0x3f3f3f3f;int h[N];int find(int x) &#123; // 开放寻址法，find函数返回的是x应该存在的位置或者在的位置 int k = (x % N + N) % N; while (h[k] != x &amp;&amp; h[k] != null) &#123; k++; if (k == N) k = 0; &#125; return k;&#125;int main() &#123; char op; int n, x; cin &gt;&gt; n; memset(h, 0x3f, sizeof h); while (n--) &#123; cin &gt;&gt; op &gt;&gt; x; int k = find(x); if (op == &#x27;I&#x27;) &#123; h[k] = x; &#125; else if (op == &#x27;Q&#x27;) &#123; if (h[k] != null) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 字符串哈希 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int P = 131, N = 1e5+10; // P取这个值比较好typedef unsigned long long ULL;ULL p[N], h[N]; // h[N] 是 s[1 - n] 哈希值void init(int n, char* str) &#123; p[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125;&#125;ULL get(int l, int r) &#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main() &#123; // 字符串哈希https://www.acwing.com/problem/content/843/ int n, m; char str[N]; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str + 1; // 只能定义成char init(n, str); int l1, r1, l2, r2; while (m--) &#123; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://breadwinners.top/tags/HashMap/"}]},{"title":"暴力和模拟","slug":"暴力和模拟","date":"2023-04-06T16:00:00.000Z","updated":"2023-07-11T01:33:16.260Z","comments":true,"path":"2023/04/07/暴力和模拟/","link":"","permalink":"http://breadwinners.top/2023/04/07/%E6%9A%B4%E5%8A%9B%E5%92%8C%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"四方和定理 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 5e6 + 10;int n;int h[N * 2]; // 小技巧，避免pair，r[c^2+d^2]=c;可以推导出dint main() &#123; cin &gt;&gt; n; memset(h, -1, sizeof h); for (int c = 0; c * c &lt;= n; c++) &#123; for (int d = c; c * c + d * d &lt;= n; d++) &#123; // 必须要更严格的判断条件，c * c + d * d &lt;= n,否则会出意外 int s = c * c + d * d; if (h[s] == -1) &#123; h[s] = c; &#125; &#125; &#125; for (int a = 0; a * a &lt;= n; a++) &#123; for (int b = a; a * a + b * b &lt;= n; b++) &#123; // 必须要更严格的判断条件，a * a+ b * b &lt;= n,否则会出意外 int s = n - a * a - b * b; if (h[s] != -1) &#123; int d = sqrt(s - h[s] * h[s]); printf(&quot;%d %d %d %d\\n&quot;, a, b, h[s], d); return 0; &#125; &#125; &#125; return 0;&#125; 连号区间数 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 10010;int a[N], tmp[N];int n, cnt = 0;int main() &#123; // https://www.acwing.com/problem/content/1212/ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; int mav = -1; int miv = 10009; for (int j = i; j &lt; n; j++) &#123; mav = max(mav, a[j]); miv = min(miv, a[j]); if (mav - miv == j - i) &#123; cnt++; &#125; &#125; &#125; cout &lt;&lt; cnt; return 0;&#125; 回文日期 &#x3D;&#x3D;注意&#x3D;&#x3D; 这个题目中有两个枚举的角度，一个是 符合回文数的范围要求，另一个是 符合日期的要求，很容易会想到开始枚举日期，然后想是否满足回文数，但是这种枚举方法很麻烦，可能需要自己写个日历。所以换一个角度，先枚举回文数，再判断是否满足日期的要求，就简单很多，注意getline之前要吸收回车 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int date1, date2, res = 0;int days[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;bool check(int date) &#123; // 判断回文数中的月份是否合法 int year, month, day; year = date / 10000; month = date / 100 % 100; day = date % 100; cout &lt;&lt; year &lt;&lt; &quot; &quot; &lt;&lt; month &lt;&lt; &quot; &quot; &lt;&lt; day &lt;&lt; &quot;##\\n&quot;; if (month &lt;= 0 || month &gt; 12) return false; if (day &lt;= 0 || day &gt; days[month] &amp;&amp; month != 2) return false; if (month == 2) &#123; int leap = (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0); if (day &gt; days[month] + leap) return false; &#125; return true;&#125;int main() &#123; // https://www.acwing.com/problem/content/468/ cin &gt;&gt; date1 &gt;&gt; date2; // 首先枚举回文数，只需枚举前面4位数 for (int i = 1000; i &lt; 10000; i++) &#123; int date = i, x = i; while (x) &#123; // 通过前4位数构造回文数 date *= 10; int t = x % 10; date += t; x /= 10; &#125; cout &lt;&lt; date &lt;&lt; endl; if (check(date) &amp;&amp; date &gt;= date1 &amp;&amp; date &lt;= date2) res++; &#125; cout &lt;&lt; res; return 0;&#125; 递增三元组 双指针&#x3D;&#x3D;注意&#x3D;&#x3D; while 循环的指针，一定要判断指针不出界才继续循环 递增三元组 思路：枚举数组B，A， C数组从开头出发，满足 A &lt; B &lt; C，res++ 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n;int a[N], b[N], c[N];signed main() &#123; // https://www.acwing.com/problem/content/description/1238/ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;c[i]); sort(a, a + n); sort(b, b + n); sort(c, c + n); LL res = 0, l = 0, r = 0; // l 和 r定义在外面，因为数组排序过后，顺序是固定的，没必要从头开始查找 for (int i = 0; i &lt; n; i++) &#123; while (a[l] &lt; b[i] &amp;&amp; l &lt; n) l++; while (c[r] &lt;= b[i] &amp;&amp; r &lt; n) r++; res += (LL)l * (n - r); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 前缀和思路：定义一个数组cnta，cnta[i] 是A中小于i的数的个数，cntc[i] 是C中大于i的数的个数，然后循环遍历数组B，res +&#x3D; A中小于B[i]的数量 × C中大于B[i]的数量 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 100010;int A[N], B[N], C[N];int cnta[N], cntc[N]; // cnta[i] 是A中小于i的数的个数, cntc[i] 是C中大于i的数的个数int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;A[i]); cnta[A[i]]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;B[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;C[i]); cntc[C[i]]++; &#125; // 对数出现的次数，求一次前缀和 // 预处理前缀和 for (int i = 1; i &lt;= N; i++) &#123; // 前缀和的迭代次数不是 n, 而是题中出现的数的最大值 cnta[i] += cnta[i - 1]; &#125; for (int i = N; i &gt;= 1; i--) &#123; // 这里还需要注意前缀和的后缀和 cntc[i] += cntc[i + 1]; &#125; // 开始计算res LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; res += (LL)cnta[B[i] - 1] * cntc[B[i] + 1]; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 错误票据（考察数据读取）某涉密单位下发了某种票据，并要在年终全部收回。 每张票据有唯一的ID号。 全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。 因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。 你的任务是通过编程，找出断号的ID和重号的ID。 假设断号不可能发生在最大和最小号。 输入格式 第一行包含整数 N，表示后面共有 N 行数据。 接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。 输出格式 要求程序输出1行，含两个整数 m,n用空格分隔。 其中，m表示断号ID，n表示重号ID。 数据范围 1≤N≤100 输入样例：12325 6 8 11 9 10 12 9 输出样例： 17 9 可以使用stringstream&#x3D;&#x3D;注意&#x3D;&#x3D; getline之前必须处理掉多余的换行符\\n 12345678910111213141516171819202122232425262728293031323334353637#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;const int N = 10010;int a[N];int main() &#123; // https://www.acwing.com/problem/content/1206/ int n, cnt = 0; cin &gt;&gt; n; string line; getline(cin, line); while (n--) &#123; getline(cin, line); stringstream ssin(line); while (ssin &gt;&gt; a[cnt]) cnt++; &#125; sort(a, a + cnt); // for (int i = 0;i &lt;cnt;i++) // cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; int res1, res2; for (int i = 1; i &lt; cnt; i++) &#123; if (a[i] == a[i - 1]) res1 = a[i]; else if (a[i] - a[i - 1] &gt; 1) res2 = a[i - 1] + 1; &#125; cout &lt;&lt; res2 &lt;&lt; &quot; &quot; &lt;&lt; res1; return 0;&#125; 直接忽略第一个数，读取到EOF123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n;const int N = 1e5 + 10;int a[N];int main() &#123; // https://www.acwing.com/problem/content/1206/ cin &gt;&gt; n; int i = 0; while (cin &gt;&gt; a[i]) &#123; i++; &#125; sort(a, a + i); int duan, chong; for (int j = 0; j &lt; i; j++) &#123; if (a[j] == a[j + 1]) chong = a[j]; if (a[j] == a[j + 1] - 2) duan = a[j] + 1; &#125; cout &lt;&lt; duan &lt;&lt; &#x27; &#x27;; cout &lt;&lt; chong &lt;&lt; &#x27; &#x27;;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://breadwinners.top/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"模拟","slug":"模拟","permalink":"http://breadwinners.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"双指针","slug":"双指针","permalink":"http://breadwinners.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"快排和快选","slug":"快排问题","date":"2023-04-06T16:00:00.000Z","updated":"2023-07-11T01:42:34.183Z","comments":true,"path":"2023/04/07/快排问题/","link":"","permalink":"http://breadwinners.top/2023/04/07/%E5%BF%AB%E6%8E%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"快速排序123456789101112131415161718192021222324252627282930313233343536#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;void quick_sort(int q[], int l, int r);int main() &#123; int n = 7; int a[n] = &#123;2, 4, 3, 7, 1, 5, 6&#125;; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n####################\\n&quot;; quick_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;void quick_sort(int q[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1; while (i &lt; j) &#123; while (q[++i] &lt; x) ; while (q[--j] &gt; x) ; if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j); quick_sort(q, j + 1, r);&#125; 快速选择123456789101112131415161718192021222324252627282930#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int quick_select(int q[], int l, int r, int k);int main() &#123; int n = 5, k = 1; int a[5] = &#123;3, 4, 5, 1, 2&#125;; cout &lt;&lt; quick_select(a, 0, n - 1, k); return 0;&#125;int quick_select(int q[], int l, int r, int k) &#123; if (l &gt;= r) &#123; return q[l]; &#125; int x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1; while (i &lt; j) &#123; while (q[++i] &lt; x) ; while (q[--j] &gt; x) ; if (i &lt; j) swap(q[i], q[j]); &#125; int sl = j - l + 1; // sl可以看成排序完成后，左边 sl 个最小的数，所以第k小的数一定在左半边 if (k &lt;= sl) // k &lt;= sl, 第k小的数一点在左半边区间内 return quick_select(q, l, j, k); return quick_select(q, j + 1, r, k - sl);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"quick","slug":"quick","permalink":"http://breadwinners.top/tags/quick/"},{"name":"sort","slug":"sort","permalink":"http://breadwinners.top/tags/sort/"}]},{"title":"kmp","slug":"kmp","date":"2023-04-06T16:00:00.000Z","updated":"2023-07-11T01:48:27.795Z","comments":true,"path":"2023/04/07/kmp/","link":"","permalink":"http://breadwinners.top/2023/04/07/kmp/","excerpt":"","text":"next数组的本质其实是寻找子串中“相同前后缀”的长度，并且一定是最长的前后缀 如果下一个字符依然相同的话，直 接都成了一个更长的前后缀，长度+1, 下一个字符不同的话","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"kmp","slug":"kmp","permalink":"http://breadwinners.top/tags/kmp/"}]},{"title":"二分法和模板","slug":"二分模板","date":"2023-04-05T16:00:00.000Z","updated":"2023-07-11T01:35:20.896Z","comments":true,"path":"2023/04/06/二分模板/","link":"","permalink":"http://breadwinners.top/2023/04/06/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"二分的本质是寻找已知数据中，一部分满足某种性质，另一部分不满足某种性质，寻找这个边界点二分是寻找边界点，左边界点或者是右边界点，而边界点一定是两种性质的过渡点， 在思考过程中，不知道如何确定l &#x3D; mid,还是r &#x3D; mid，记住mid是向key靠近的，怎么取值能够让mid向可以靠近 1.先写一个check函数，确定区间性质2.确定边界写模板，对于整数二分，先写mid &#x3D; l + r &gt;&gt; 1；后面再确定是否需要+1，如果是l &#x3D; mid，就+1 模板 12345678910111213141516171819202122// 区间[l，r]被划分成[1，mid]和[mid + 1，r]时使用:int bsearch_1(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) // check() 判断mid是否满足性质 r = mid; else l = mid + 1; &#125; return l;&#125;// 区间[l，r]被划分成[l, mid - 1]和[mid，r]时使用:int bsearch_2(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 题目链接 数的范围 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m, key; cin &gt;&gt; n &gt;&gt; m; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; while (m--) &#123; cin &gt;&gt; key; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (a[mid] &gt;= key) &#123; // 大于等于 x 的第一个位置 r = mid; &#125; else l = mid + 1; &#125; if (a[l] != key) &#123; cout &lt;&lt; &quot;-1 -1\\n&quot;; &#125; else &#123; int ll = 0, rr = n - 1; while (ll &lt; rr) &#123; int mid = ll + rr + 1 &gt;&gt; 1; if (a[mid] &lt;= key) &#123; // 小于等于 x 的第一个位置 ll = mid; &#125; else rr = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; ll &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://breadwinners.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"如何提高cin/cout的速度","slug":"algorithm","date":"2023-04-02T16:00:00.000Z","updated":"2023-07-11T01:23:22.866Z","comments":true,"path":"2023/04/03/algorithm/","link":"","permalink":"http://breadwinners.top/2023/04/03/algorithm/","excerpt":"","text":"在无数的算法比赛中，不难看到下面这样的东西： 1ios::sync_with_stdio(false); 甚至是这样的东西： 123ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); 现在，尽量用&quot;\\n&quot;替换可以替换的endl 。（考虑流输出）","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"cin","slug":"cin","permalink":"http://breadwinners.top/tags/cin/"},{"name":"cout","slug":"cout","permalink":"http://breadwinners.top/tags/cout/"}]},{"title":"Linux中su、sudo","slug":"sudo和su和logout","date":"2023-04-02T16:00:00.000Z","updated":"2023-07-11T02:07:40.164Z","comments":true,"path":"2023/04/03/sudo和su和logout/","link":"","permalink":"http://breadwinners.top/2023/04/03/sudo%E5%92%8Csu%E5%92%8Clogout/","excerpt":"","text":"注意：su -使用root的密码,而sudo su使用用户密码 高权限的用户切换到低权限的用户不需要吗，密码，当用户登录到另一个用户，logout会回退到上一个用户的界面 sudo sudo是一种权限管理机制，依赖于&#x2F;etc&#x2F;sudoers，其定义了授权给哪个用户可以以管理员的身份能够执行什么样的管理命令； 格式：sudo -u USERNAME COMMAND 默认情况下，系统只有root用户可以执行sudo命令。需要root用户通过使用visudo命令编辑sudo的配置文件&#x2F;etc&#x2F;sudoers，才可以授权其他普通用户执行sudo命令。 sudo的运行有这样一个流程： 1).当用户运行sudo时，系统于&#x2F;etc&#x2F;sudoers文件里查找该用户是否有运行sudo的权限； 2).若用户具有可运行sudo的权限。那么让用户输入用户自己的password，注意这里输入的是用户自己的password。 3).假设password正确。变開始进行sudo后面的命令，root运行sudo是不须要输入password的，切换到的身份与运行者身份同样的时候。也不须要输入password。 su su为switch user，即切换用户的简写。 su是最简单的身份切换名，用su我们能够进行不论什么用户的切换，一般都是su – username，然后输入password就ok了，可是root用su切换到其它身份的时候是不须要输入password的。 如果不指定USERNAME（用户名），默认即为root，所以切换到root的身份的命令即为：su -root或su -，su root 或su。 su USERNAME，与su – USERNAME的不同之处如下： su – USERNAME切换用户后，同时切换到新用户的工作环境中。 su USERNAME切换用户后，不改变原用户的工作目录，及其他环境变量目录。 如何设置初始su密码？ 当我们输入su时会发现要输入密码，我们尝试输入自己当前用户的密码，发现failure。 但我们又不知道su密码是什么？其实su初始密码可以通过下面方式进行设置： 1sudo passwd 复制 设置完后再输入su命令并键入刚才设置的密码即可进入~ su – su -，su -l或su –login 命令改变身份时，也同时变更工作目录，以及HOME，SHELL，USER，LOGNAME。此外，也会变更PATH变量。用su -命令则默认转换成成root用户了。 而不带参数的“su命令”不会改变当前工作目录以及HOME,SHELL,USER,LOGNAME。只是拥有了root的权限而已。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"}],"tags":[{"name":"su","slug":"su","permalink":"http://breadwinners.top/tags/su/"},{"name":"sudo","slug":"sudo","permalink":"http://breadwinners.top/tags/sudo/"}]},{"title":"java容器","slug":"java容器","date":"2023-03-22T16:00:00.000Z","updated":"2023-07-11T02:03:46.298Z","comments":true,"path":"2023/03/23/java容器/","link":"","permalink":"http://breadwinners.top/2023/03/23/java%E5%AE%B9%E5%99%A8/","excerpt":"","text":"List接口常用方法：1、add(Object element)： 向列表的尾部添加指定的元素。 2、size()： 返回列表中的元素个数。 3、get(int index)： 返回列表中指定位置的元素，index从0开始。 4、add(int index, Object element)： 在列表的指定位置插入指定元素。 5、set(int i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。 6、clear()： 从列表中移除所有元素。 7、isEmpty()： 判断列表是否包含元素，不包含元素则返回 true，否则返回false。 8、contains(Object o)： 如果列表包含指定的元素，则返回 true。 9、remove(int index)： 移除列表中指定位置的元素，并返回被删元素。 10、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。 11、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。 ArrayList一样可以使用List的所有方法，所以以ArrayList来演示： 方法使用：1、add(Object element) 向列表的尾部添加指定的元素。2、size() 返回列表中的元素个数。3、get(int index) 返回列表中指定位置的元素，index从0开始。 例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //&lt;String&gt;泛型表示集合中存的是字符串形式的元素。 list.add(&quot;徐冰&quot;); //add()用于向List集合容器中添加元素。 list.add(&quot;萤火&quot;); System.out.println(list); System.out.println(list.size()); //size()用于获取集合中有多少个元素。 System.out.println(list.get(1)); //get()获取指定索引（从0开始）位置的元素。 &#125;&#125; 输出：[徐冰, 萤火]2萤火 4、add(int index, Object element) 在列表的指定位置（从0开始）插入指定元素。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); System.out.println(list); list.add(1, &quot;阿若&quot;); //在指定位置添加元素，原来位置的元素后置。 System.out.println(list); &#125;&#125; 输出：[徐冰, 萤火][徐冰, 阿若, 萤火] 5、set(int i, Object element) 使用元素element替换索引i位置的元素，并返回被替换的元素。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); System.out.println(list); list.set(1, &quot;阿若&quot;); //替换指定位置的元素，从0开始，替换了“萤火”。 System.out.println(list); &#125;&#125; 输出：[徐冰, 萤火][徐冰, 阿若] 6、clear() 从列表中移除所有元素。7、isEmpty() 判断列表是否包含元素，不包含元素则返回 true，否则返回false。例如： 12345678910111213import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); System.out.println(list); list.clear(); //清空List集合中的所有元素。 System.out.println(list.isEmpty()); //集合容器没有元素，则true。 System.out.println(list); &#125;&#125; 输出：[徐冰, 萤火]true[] 8、contains(Object o) 如果列表包含指定的元素，则返回 true。例如： 1234567891011import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); boolean flag = list.contains(&quot;徐冰&quot;); //用来判断集合容器中是否含有参数元素。 System.out.println(flag); &#125;&#125; 这个方法需要思考一下，因为contains的参数类型是Object型，看一下源代码： 1234567891011121314151617public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;public int indexOf(Object o) &#123; //因为我们设置的实参是String类型的变量，所以此时o为上转型对象。 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) //因为o为上转型对象，所以equals表面上是Object类的，但实际上我们使用的是String类的equals方法。 return i; &#125; return -1;&#125; 即list为上转型对象，使用String类的equals方法比较的是两个元素的内容是否相同。 9、remove(int index) 移除列表中指定位置的元素，并返回被删元素，删除位置后面的元素（如果有）向前移动。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); list.add(&quot;阿若&quot;); System.out.println(list.remove(1)); //删除指定索引（从0开始）位置的元素，并将元素返回,并后面元素前移。 System.out.println(list); &#125;&#125; 输出：萤火[徐冰, 阿若] 10、remove(Object o) 从List集合中移除第一次出现的指定元素，移除成功返回true，否则返回false。当且仅当List集合中含有满足(o&#x3D;&#x3D;null ? get(i)&#x3D;&#x3D;null : o.equals(get(i)))条件的最低索引i的元素时才会返回true。例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); list.add(&quot;阿若&quot;); System.out.println(list.remove(&quot;萤火&quot;)); //删除List集合元素，返回boolean,并后面元素前移。 System.out.println(list); &#125;&#125; 输出：true[徐冰, 阿若] 11、iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器。例如运用iterator方法进行List遍历： 123456789101112131415import java.util.ArrayList;import java.util.Iterator;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); Iterator&lt;String&gt; ite = list.iterator(); //将List集合中元素转到iterator变量中。 while(ite.hasNext()) //hasNext()判断当前“指针”下面是否还有元素的方法，java中没有指针，这只是举个例子。 &#123; System.out.println(ite.next()); //如果“指针”下面有元素，则移动“指针”并获取相应位置的元素。 &#125; &#125;&#125; 输出：徐冰萤火 12、for循环遍历List集合：例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; //用size方法获取长度。 System.out.println(list.get(i)); //用get方法获取值。 &#125; &#125;&#125; 输出：徐冰萤火 13、加强for循环遍历List集合：例如： 123456789101112import java.util.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;徐冰&quot;); list.add(&quot;萤火&quot;); for (String name : list) &#123; //使用foreach进行遍历。 System.out.println(name); &#125; &#125;&#125; 输出：徐冰萤火 排序12345678910111213141516//按照List中对象的id属性升序list.sort(Comparator.comparing(Stu::getId))//按照List中对象的id属性降序list.sort(Comparator.comparing(Stu::getId).reversed());//多条件升序list.sort(Comparator.comparing(Stu::getId).thenComparing(Stu::getSid));//id升序,sid降序list.sort(Comparator.comparing(Stu::getId).reversed().thenComparing(Stu::getSid));//key值重复的mapMultiValueMap&lt;Integer, String&gt; timeMap = new LinkedMultiValueMap&lt;&gt;();//集合升序排序Collections.sort(student, new Comparator()&#123;public int compare(StudentVo p1, StudentVo p2) &#123;return Integer.parseInt(p1.getStudentCode()) - Integer.parseInt(p2.getStudentCode());&#125;&#125;); Stack 栈简介 stack 类是 Vector 类的一个子类，它实现了标准的后进先出的栈 常用方法 序号 方法 作用 1 boolean empty() 判断栈是否为空 2 Object peek() 查看栈顶部的对象，但不从堆栈中移除它 3 Object pop() 移除栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object obj) 把元素压入栈顶部 5 int search(Object obj) 返回对象在堆栈中的位置，从栈顶往下开始查找。 用法讲解 创建一个空的字符栈 12Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();System.out.println(&quot;stack: &quot; + stack); // stack: [] 将元素 R 压入栈顶部 123Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();stack.push(&#x27;R&#x27;);System.out.println(&quot;stack: &quot; + stack); // stack: [R] 判断栈是否为空 1234Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();System.out.println(stack.empty()); // truestack.push(&#x27;R&#x27;);System.out.println(stack.empty()); // false 移除栈顶元素，但不移除 12345Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); stack.push(&#x27;R&#x27;);System.out.println(&quot;stack: &quot; + stack); // stack: [R]System.out.println(stack.peek()); // RSystem.out.println(&quot;stack: &quot; + stack); // stack: [R] 移除栈顶元素；如果栈为空会引起EmptyStackException 12345678910Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); stack.push(&#x27;R&#x27;);System.out.println(&quot;stack: &quot; + stack); // stack: [R]System.out.println(stack.pop()); // RSystem.out.println(&quot;stack: &quot; + stack); // stack: []try &#123; stack.pop(); &#125; catch (EmptyStackException e) &#123; System.out.println(&quot;empty stack&quot;); //empty stack &#125; 查询元素在栈中的位置；多个相同元素返回离栈顶最近的；没有则返回-1 1234567891011Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();stack.push(&#x27;E&#x27;);stack.push(&#x27;A&#x27;);stack.push(&#x27;W&#x27;);stack.push(&#x27;A&#x27;);stack.push(&#x27;Q&#x27;);stack.push(&#x27;R&#x27;);System.out.println(stack.search(&#x27;R&#x27;)); //1System.out.println(stack.search(&#x27;Q&#x27;)); //2System.out.println(stack.search(&#x27;A&#x27;)); //3System.out.println(stack.search(&#x27;D&#x27;)); // -1 QueueQueue是java中实现队列的接口，它总共只有6个方法，我们一般只用其中3个就可以了。Queue的实现类有LinkedList和PriorityQueue。最常用的实现类是LinkedList。 Queue的6个方法分类： 压入元素(添加)：add()、offer()相同：未超出容量，从队尾压入元素，返回压入的那个元素。区别：在超出容量时，add()方法会对抛出异常，offer()返回false 弹出元素(删除)：remove()、poll()相同：容量大于0的时候，删除并返回队头被删除的那个元素。区别：在容量为0的时候，remove()会抛出异常，poll()返回false 获取队头元素(不删除)：element()、peek()相同：容量大于0的时候，都返回队头元素。但是不删除。区别：容量为0的时候，element()会抛出异常，peek()返回null。 队列除了基本的 Collection 操作外，还提供特有的插入、提取和检查操作(如上)。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 Queue 实现设计的；在大多数实现中，插入操作不会失败。 抛出异常 返回特殊值 插入 add(e) offer(e) 删除 remove() poll() 检查 element() peek() Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。 Queue 实现通常未定义 equals 和 hashCode 方法的基于元素的版本，而是从 Object 类继承了基于身份的版本，因为对于具有相同元素但有不同排序属性的队列而言，基于元素的相等性并非总是定义良好的。 看一个简单的示例： 123456789101112131415public class QueueTest &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList(); queue.offer(&quot;元素A&quot;); queue.offer(&quot;元素B&quot;); queue.offer(&quot;元素C&quot;); queue.offer(&quot;元素D&quot;); queue.offer(&quot;元素E&quot;); while (queue.size() &gt; 0) &#123; String element = queue.poll(); System.out.println(element); &#125; &#125;&#125; 输出结果： 1234567元素A元素B元素C元素D元素EProcess finished with exit code 0 可以看到，queue是一个先进先出的队列。 遍历时可以用iterator指定泛型，就不需要强转 Map主要使用HashMap和Treemap get方法：获取指定键(key)所对应的值(value)， 方法返回值为键所对应的值 put方法：将指定的键与值对应起来，并添加到集合中，若指定的键(key)在集合中，覆 remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)。 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //数据采用的哈希表结构 //给map中添加元素 map.put(&quot;星期一&quot;, &quot;Monday&quot;); map.put(&quot;星期日&quot;, &quot;Sunday&quot;); System.out.println(map); // &#123;星期日=Sunday, 星期一=Monday&#125; //当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null System.out.println(map.put(&quot;星期一&quot;, &quot;Mon&quot;)); // Monday System.out.println(map); // &#123;星期日=Sunday, 星期一=Mon&#125; //根据指定的key获取对应的value String en = map.get(&quot;星期日&quot;); System.out.println(en); // Sunday //根据key删除元素,会返回key对应的value值 String value = map.remove(&quot;星期日&quot;); System.out.println(value); // Sunday System.out.println(map); // &#123;星期一=Mon&#125; &#125;&#125; 遍历Map利用迭代器 123456789101112131415161718192021public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;柳岩&quot;); //获取Map中的所有key Set&lt;String&gt; keySet = map.keySet(); //遍历存放所有key的Set集合 Iterator&lt;String&gt; it =keySet.iterator(); ** while(it.hasNext())&#123; //利用了Iterator迭代器** //得到每一个key String key = it.next(); //通过key获取对应的value String value = map.get(key); System.out.println(key+&quot;=&quot;+value); &#125; &#125;&#125; Map集合遍历键值对方式 键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。 2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象 3.通过键值对(Entry)对象，获取Entry对象中的键与值。 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;柳岩&quot;); //获取Map中的所有key与value的对应关系 Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); //遍历Set集合 Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = entrySet.iterator(); while(it.hasNext())&#123; //得到每一对对应关系 Map.Entry&lt;String,String&gt; entry = it.next(); //通过每一对对应关系获取对应的key String key = entry.getKey(); //通过每一对对应关系获取对应的value String value = entry.getValue(); System.out.println(key+&quot;=&quot;+value); &#125; &#125;&#125; &#x3D;&#x3D;注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。&#x3D;&#x3D; setHashSet特性：元素唯一，无序，可以含有空元素。 下面我们看示例： 1234567891011121314151617181920212223import java.util.HashSet;import java.util.Iterator;import java.util.Set; public class first &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str = new HashSet&lt;String&gt;(); str.add(&quot;first&quot;);//添加元素 str.add(&quot;second&quot;); str.remove(&quot;first&quot;);//删除元素 //遍历，通过迭代器 Iterator&lt;String&gt; it = str.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; //通过foreach for(String s:str) &#123; System.out.println(s); &#125; &#125;&#125; 运行结果为： LinkedHashSet这个相对于HashSet来说有一个很大的不一样是LinkedHashSet是有序的。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 详细见demo: 12345678910Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();for(int i= 0;i&lt;6;i++)&#123; set.add(i+&quot;&quot;);&#125;set.add(&quot;3&quot;); //重复数据，不会写入set.add(null); //可以写入空数据Iterator&lt;String&gt; iter = set.iterator();while(iter.hasNext())&#123; System.out.println(iter.next()); //输出是有序的&#125; 输出打印如下： 1234567012345null TreeSet:特点：元素唯一，有序，不能含有空元素。 下面我们通过示例来说明： 123456789101112131415161718192021222324252627import java.util.Iterator;import java.util.Set;import java.util.TreeSet; public class first &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str = new TreeSet&lt;String&gt;(); str.add(&quot;first&quot;);//添加元素 str.add(&quot;second&quot;); str.add(&quot;third&quot;); str.add(&quot;first&quot;);//重复元素 //遍历，通过迭代器 Iterator&lt;String&gt; it = str.iterator(); System.out.println(&quot;通过迭代器输出&quot;); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; //通过foreach System.out.println(&quot;通过foreach输出&quot;); for(String s:str) &#123; System.out.println(s); &#125; &#125;&#125; 运行结果为：","categories":[{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"容器","slug":"容器","permalink":"http://breadwinners.top/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"设计模式","slug":"设计yuanze","date":"2023-03-19T16:00:00.000Z","updated":"2023-07-11T01:55:38.250Z","comments":true,"path":"2023/03/20/设计yuanze/","link":"","permalink":"http://breadwinners.top/2023/03/20/%E8%AE%BE%E8%AE%A1yuanze/","excerpt":"","text":"原则1.1 开闭原则对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。 【例】搜狗输入法 的皮肤设计。 分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。 1.2 里氏代换原则里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，&#x3D;&#x3D;除添加新的方法完成新增功能外，尽量不要重写父类的方法&#x3D;&#x3D;。 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 下面看一个里氏替换原则中经典的一个例子 【例】正方形不是长方形。 在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。 代码如下： 长方形类（Rectangle）： 1234567891011121314151617181920public class Rectangle &#123; private double length; private double width; public double getLength() &#123; return length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125;&#125; 正方形（Square）： 由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。 123456789101112public class Square extends Rectangle &#123; public void setWidth(double width) &#123; super.setLength(width); super.setWidth(width); &#125; public void setLength(double length) &#123; super.setLength(length); super.setWidth(length); &#125;&#125; 类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。 1234567891011121314151617181920212223242526272829public class RectangleDemo &#123; public static void resize(Rectangle rectangle) &#123; while (rectangle.getWidth() &lt;= rectangle.getLength()) &#123; rectangle.setWidth(rectangle.getWidth() + 1); &#125; &#125; //打印长方形的长和宽 public static void printLengthAndWidth(Rectangle rectangle) &#123; System.out.println(rectangle.getLength()); System.out.println(rectangle.getWidth()); &#125; public static void main(String[] args) &#123; Rectangle rectangle = new Rectangle(); rectangle.setLength(20); rectangle.setWidth(10); resize(rectangle); printLengthAndWidth(rectangle); System.out.println(&quot;============&quot;); Rectangle rectangle1 = new Square(); rectangle1.setLength(10); resize(rectangle1); printLengthAndWidth(rectangle1); &#125;&#125; 我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。 如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口 1.3 依赖倒转原则高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 下面看一个例子来理解依赖倒转原则 【例】组装电脑 现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。 类图如下： 根据依赖倒转原则进行改进： 代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。 类图如下： 1.4 接口隔离原则客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。 下面看一个例子来理解接口隔离原则 【例】安全门案例 我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下： 上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图： 1.5 迪米特法则迪米特法则又叫最少知识原则。 只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。 其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 下面看一个例子来理解迪米特法则 【例】明星与经纪人的关系实例 明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。 类图如下： 1.6 合成复用原则合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 通常类的复用分为继承复用和合成复用两种。 继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 对象间的耦合度低。可以在类的成员位置声明抽象。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 下面看一个例子来理解合成复用原则 【例】汽车分类管理程序 汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： 从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。 2.创建者模式创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。 这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。 创建型模式分为： 单例模式 工厂方法模式 抽象工程模式 原型模式 建造者模式 2.1 单例设计模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 2.1.1 单例模式的结构单例模式的主要有以下角色： 单例类。只能创建一个实例的类 访问类。使用单例类 2.1.2 单例模式的实现 单例设计模式分类两种： ​ 饿汉式：类加载就会导致该单实例对象被创建 ​ 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 饿汉式-方式1（静态变量方式） 12345678910111213141516/** * 饿汉式 * 静态变量创建类的对象 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 说明： ​ 该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2（静态代码块方式） 12345678910111213141516171819202122/** * 恶汉式 * 在静态代码块中创建该类对象 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; // 在静态代码块中进行赋值 static &#123; instance = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 说明： ​ 该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉式-方式1（线程不安全） 1234567891011121314151617181920/** * 懒汉式 * 线程不安全 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明： ​ 从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 懒汉式-方式2（线程安全） 1234567891011121314151617181920/** * 懒汉式 * 线程安全 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明： ​ 该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁） 再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 123456789101112131415161718192021222324/** * 双重检查方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) &#123; synchronized (Singleton.class) &#123; //抢到锁之后再次判断是否为null if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。 123456789101112131415161718192021222324/** * 双重检查方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) &#123; synchronized (Singleton.class) &#123; //抢到锁之后再次判断是否为空 if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 小结： 添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式） 静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。 1234567891011121314151617/** * 静态内部类方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 说明： ​ 第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。 小结： ​ 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式 枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 123456/** * 枚举方式 */public enum Singleton &#123; INSTANCE;&#125; 说明： ​ 枚举方式属于恶汉式方式。 2.2 工厂模式2.2.1 概述需求：设计一个咖啡店点餐系统。 设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。 具体类的设计如下： 在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。 在本教程中会介绍三种工厂的使用 简单工厂模式（不属于GOF的23种经典设计模式） 工厂方法模式 抽象工厂模式 2.2.2 简单工厂模式简单工厂不是一种设计模式，反而比较像是一种编程习惯。 2.2.2.1 结构简单工厂包含如下角色： 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 2.2.2.2 实现现在使用简单工厂对上面案例进行改进，类图如下： 工厂类代码如下： 123456789101112public class SimpleCoffeeFactory &#123; public Coffee createCoffee(String type) &#123; Coffee coffee = null; if(&quot;americano&quot;.equals(type)) &#123; coffee = new AmericanoCoffee(); &#125; else if(&quot;latte&quot;.equals(type)) &#123; coffee = new LatteCoffee(); &#125; return coffee; &#125;&#125; 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。 后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。 2.2.2.4 优缺点优点： 封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。 缺点： 增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。 2.2.2.3 扩展静态工厂 在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下： 123456789101112public class SimpleCoffeeFactory &#123; public static Coffee createCoffee(String type) &#123; Coffee coffee = null; if(&quot;americano&quot;.equals(type)) &#123; coffee = new AmericanoCoffee(); &#125; else if(&quot;latte&quot;.equals(type)) &#123; coffee = new LatteCoffee(); &#125; return coffe; &#125;&#125; 2.2.3 工厂方法模式针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。 2.2.3.1 概念定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。 2.2.3.2 结构工厂方法模式的主要角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 2.2.3.3 实现使用工厂方法模式对上例进行改进，类图如下： 代码如下： 抽象工厂： 1234public interface CoffeeFactory &#123; Coffee createCoffee();&#125; 具体工厂： 12345678910111213public class LatteCoffeeFactory implements CoffeeFactory &#123; public Coffee createCoffee() &#123; return new LatteCoffee(); &#125;&#125;public class AmericanCoffeeFactory implements CoffeeFactory &#123; public Coffee createCoffee() &#123; return new AmericanCoffee(); &#125;&#125; 咖啡店类： 123456789101112131415public class CoffeeStore &#123; private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) &#123; this.factory = factory; &#125; public Coffee orderCoffee(String type) &#123; Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; &#125;&#125; 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。 工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。 2.2.3.4 优缺点优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 2.2.4 抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。 这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。 2.2.2.1 概念是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 2.2.4.2 结构抽象工厂模式的主要角色如下： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 4.2.4.2 实现现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下： 代码如下： 抽象工厂： 123456public interface DessertFactory &#123; Coffee createCoffee(); Dessert createDessert();&#125; 具体工厂： 12345678910111213141516171819202122//美式甜点工厂public class AmericanDessertFactory implements DessertFactory &#123; public Coffee createCoffee() &#123; return new AmericanCoffee(); &#125; public Dessert createDessert() &#123; return new MatchaMousse(); &#125;&#125;//意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory &#123; public Coffee createCoffee() &#123; return new LatteCoffee(); &#125; public Dessert createDessert() &#123; return new Tiramisu(); &#125;&#125; 如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。 4.2.4.3 优缺点优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点： 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 4.2.4.4 使用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。 2.3 建造者模式2.3.1 概述将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 2.3.2 结构建造者（Builder）模式包含如下角色： 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完 成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 类图如下： 2.3.3 实例创建共享单车 生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。 这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下： 具体的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//自行车类public class Bike &#123; private String frame; private String seat; public String getFrame() &#123; return frame; &#125; public void setFrame(String frame) &#123; this.frame = frame; &#125; public String getSeat() &#123; return seat; &#125; public void setSeat(String seat) &#123; this.seat = seat; &#125;&#125;// 抽象 builder 类public abstract class Builder &#123; protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike();&#125;//摩拜单车Builder类public class MobikeBuilder extends Builder &#123; @Override public void buildFrame() &#123; mBike.setFrame(&quot;铝合金车架&quot;); &#125; @Override public void buildSeat() &#123; mBike.setSeat(&quot;真皮车座&quot;); &#125; @Override public Bike createBike() &#123; return mBike; &#125;&#125;//ofo单车Builder类public class OfoBuilder extends Builder &#123; @Override public void buildFrame() &#123; mBike.setFrame(&quot;碳纤维车架&quot;); &#125; @Override public void buildSeat() &#123; mBike.setSeat(&quot;橡胶车座&quot;); &#125; @Override public Bike createBike() &#123; return mBike; &#125;&#125;//指挥者类public class Director &#123; private Builder mBuilder; public Director(Builder builder) &#123; mBuilder = builder; &#125; public Bike construct() &#123; mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; showBike(new OfoBuilder()); showBike(new MobikeBuilder()); &#125; private static void showBike(Builder builder) &#123; Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); &#125;&#125; 注意： 上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合 123456789101112131415// 抽象 builder 类public abstract class Builder &#123; protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() &#123; this.buildFrame(); this.BuildSeat(); return this.createBike(); &#125;&#125; 说明： 这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。 2.3.4 优缺点优点： 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。 缺点： 造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 2.3.5 使用场景建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 2.3.6 模式扩展建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。 重构前代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Phone &#123; private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) &#123; this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; &#125; public String getCpu() &#123; return cpu; &#125; public void setCpu(String cpu) &#123; this.cpu = cpu; &#125; public String getScreen() &#123; return screen; &#125; public void setScreen(String screen) &#123; this.screen = screen; &#125; public String getMemory() &#123; return memory; &#125; public void setMemory(String memory) &#123; this.memory = memory; &#125; public String getMainboard() &#123; return mainboard; &#125; public void setMainboard(String mainboard) &#123; this.mainboard = mainboard; &#125; @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, screen=&#x27;&quot; + screen + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, mainboard=&#x27;&quot; + mainboard + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //构建Phone对象 Phone phone = new Phone(&quot;intel&quot;,&quot;三星屏幕&quot;,&quot;金士顿&quot;,&quot;华硕&quot;); System.out.println(phone); &#125;&#125; 上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。 重构后代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Phone &#123; private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) &#123; cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; &#125; public static final class Builder &#123; private String cpu; private String screen; private String memory; private String mainboard; public Builder() &#123;&#125; public Builder cpu(String val) &#123; cpu = val; return this; &#125; public Builder screen(String val) &#123; screen = val; return this; &#125; public Builder memory(String val) &#123; memory = val; return this; &#125; public Builder mainboard(String val) &#123; mainboard = val; return this; &#125; public Phone build() &#123; return new Phone(this);&#125; &#125; @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, screen=&#x27;&quot; + screen + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, mainboard=&#x27;&quot; + mainboard + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Phone phone = new Phone.Builder() .cpu(&quot;intel&quot;) .mainboard(&quot;华硕&quot;) .memory(&quot;金士顿&quot;) .screen(&quot;三星&quot;) .build(); System.out.println(phone); &#125;&#125; 重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。 4.6 创建者模式对比4.6.1 工厂方法模式VS建造者模式工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。 我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。 4.6.2 抽象工厂模式VS建造者模式抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 5.2 适配器模式5.2.1 概述如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。 定义： ​ 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 ​ 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 5.2.2 结构适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 5.2.3 类适配器模式实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 【例】读卡器 现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。 类图如下： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//SD卡的接口public interface SDCard &#123; //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg);&#125;//SD卡实现类public class SDCardImpl implements SDCard &#123; public String readSD() &#123; String msg = &quot;sd card read a msg :hello word SD&quot;; return msg; &#125; public void writeSD(String msg) &#123; System.out.println(&quot;sd card write msg : &quot; + msg); &#125;&#125;//电脑类public class Computer &#123; public String readSD(SDCard sdCard) &#123; if(sdCard == null) &#123; throw new NullPointerException(&quot;sd card null&quot;); &#125; return sdCard.readSD(); &#125;&#125;//TF卡接口public interface TFCard &#123; //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg);&#125;//TF卡实现类public class TFCardImpl implements TFCard &#123; public String readTF() &#123; String msg =&quot;tf card read msg : hello word tf card&quot;; return msg; &#125; public void writeTF(String msg) &#123; System.out.println(&quot;tf card write a msg : &quot; + msg); &#125;&#125;//定义适配器类（SD兼容TF）public class SDAdapterTF extends TFCardImpl implements SDCard &#123; public String readSD() &#123; System.out.println(&quot;adapter read tf card &quot;); return readTF(); &#125; public void writeSD(String msg) &#123; System.out.println(&quot;adapter write tf card&quot;); writeTF(msg); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); &#125;&#125; 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。 5.2.4 对象适配器模式实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 【例】读卡器 我们使用对象适配器模式将读卡器的案例进行改写。类图如下： 代码如下： 类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。 12345678910111213141516171819202122232425262728293031323334//创建适配器对象（SD兼容TF）public class SDAdapterTF implements SDCard &#123; private TFCard tfCard; public SDAdapterTF(TFCard tfCard) &#123; this.tfCard = tfCard; &#125; public String readSD() &#123; System.out.println(&quot;adapter read tf card &quot;); return tfCard.readTF(); &#125; public void writeSD(String msg) &#123; System.out.println(&quot;adapter write tf card&quot;); tfCard.writeTF(msg); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); &#125;&#125; 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。 5.2.5 应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 5.4 桥接模式5.4.1 概述现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系： 我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。 试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。 定义： ​ 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 5.4.2 结构桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 5.4.3 案例【例】视频播放器 需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//视频文件public interface VideoFile &#123; void decode(String fileName);&#125;//avi文件public class AVIFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;avi视频文件：&quot;+ fileName); &#125;&#125;//rmvb文件public class REVBBFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;rmvb文件：&quot; + fileName); &#125;&#125;//操作系统版本public abstract class OperatingSystemVersion &#123; protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) &#123; this.videoFile = videoFile; &#125; public abstract void play(String fileName);&#125;//Windows版本public class Windows extends OperatingSystem &#123; public Windows(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//mac版本public class Mac extends OperatingSystemVersion &#123; public Mac(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; OperatingSystem os = new Windows(new AVIFile()); os.play(&quot;战狼3&quot;); &#125;&#125; 好处： 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。 实现细节对客户透明 5.4.4 使用场景 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 5.5 外观模式5.5.1 概述有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。 定义： ​ 又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 ​ 外观（Facade）模式是“迪米特法则”的典型应用 5.5.2 结构外观（Facade）模式包含以下主要角色： 外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 5.5.3 案例【例】智能家电控制 小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//灯类public class Light &#123; public void on() &#123; System.out.println(&quot;打开了灯....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了灯....&quot;); &#125;&#125;//电视类public class TV &#123; public void on() &#123; System.out.println(&quot;打开了电视....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了电视....&quot;); &#125;&#125;//控制类public class AirCondition &#123; public void on() &#123; System.out.println(&quot;打开了空调....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了空调....&quot;); &#125;&#125;//智能音箱public class SmartAppliancesFacade &#123; private Light light; private TV tv; private AirCondition airCondition; public SmartAppliancesFacade() &#123; light = new Light(); tv = new TV(); airCondition = new AirCondition(); &#125; public void say(String message) &#123; if(message.contains(&quot;打开&quot;)) &#123; on(); &#125; else if(message.contains(&quot;关闭&quot;)) &#123; off(); &#125; else &#123; System.out.println(&quot;我还听不懂你说的！！！&quot;); &#125; &#125; //起床后一键开电器 private void on() &#123; System.out.println(&quot;起床了&quot;); light.on(); tv.on(); airCondition.on(); &#125; //睡觉一键关电器 private void off() &#123; System.out.println(&quot;睡觉了&quot;); light.off(); tv.off(); airCondition.off(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(&quot;打开家电&quot;); facade.say(&quot;关闭家电&quot;); &#125;&#125; 好处： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 缺点： 不符合开闭原则，修改很麻烦 5.5.4 使用场景 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 5，结构型模式5.6 组合模式5.6.1 概述 ​ 对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。 定义： ​ 又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 5.6.2 结构组合模式主要包含三种角色： 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 5.6.3 案例实现【例】软件菜单 如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。 要实现该案例，我们先画出类图： 代码实现： 不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。 123456789101112131415161718192021222324252627282930//菜单组件 不管是菜单还是菜单项，都应该继承该类public abstract class MenuComponent &#123; protected String name; protected int level; //添加菜单 public void add(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; //移除菜单 public void remove(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; //获取指定的子菜单 public MenuComponent getChild(int i)&#123; throw new UnsupportedOperationException(); &#125; //获取菜单名称 public String getName()&#123; return name; &#125; public void print()&#123; throw new UnsupportedOperationException(); &#125;&#125; 这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。 12345678910111213141516171819202122232425262728293031323334353637public class Menu extends MenuComponent &#123; private List&lt;MenuComponent&gt; menuComponentList; public Menu(String name,int level)&#123; this.level = level; this.name = name; menuComponentList = new ArrayList&lt;MenuComponent&gt;(); &#125; @Override public void add(MenuComponent menuComponent) &#123; menuComponentList.add(menuComponent); &#125; @Override public void remove(MenuComponent menuComponent) &#123; menuComponentList.remove(menuComponent); &#125; @Override public MenuComponent getChild(int i) &#123; return menuComponentList.get(i); &#125; @Override public void print() &#123; for (int i = 1; i &lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); for (MenuComponent menuComponent : menuComponentList) &#123; menuComponent.print(); &#125; &#125;&#125; Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。 123456789101112131415public class MenuItem extends MenuComponent &#123; public MenuItem(String name,int level) &#123; this.name = name; this.level = level; &#125; @Override public void print() &#123; for (int i = 1; i &lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); &#125;&#125; MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。 5.6.4 组合模式的分类在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。 透明组合模式 透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式 在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。 5.6.5 优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://breadwinners.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"Clion中远程连接Linux开发问题","slug":"Clion中远程连接Linux开发问题","date":"2023-03-17T16:00:00.000Z","updated":"2023-07-11T02:01:31.431Z","comments":true,"path":"2023/03/18/Clion中远程连接Linux开发问题/","link":"","permalink":"http://breadwinners.top/2023/03/18/Clion%E4%B8%AD%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"Clion中远程连接Linux开发问题远程连接远程主机设置-&gt;工具链-&gt;添加远程主机并设置为默认-&gt;配置好如下配置 相关Cmake，gdb，gcc安装升级可参考我这篇博客 部署到远程主机的对应工作目录：工具-&gt;部署-&gt;配置-&gt;选择远程主机-&gt;映射-&gt;添加好对应的工作目录 一个项目新建多个c&#x2F;cpp文件一个项目中新建多个文件，在CMakeLists.txt文件中添加，比如 1add_executable(test test.cpp) 第一项是期望生成的可执行文件的名字 第二项是你新建的文件名 注意：最好是先建立文件在修改CMakeLists.txt文件的内容，不然可能会提示不属于任何项目目标 链接thread运行带线程的程序因为pthread库不是Linux系统默认的库，所以需要在CMakeLists.txt文件中添加 12find_package(Threads REQUIRED)target_link_libraries(项目名称 Threads::Threads) 其中，target_link_libraries的第一个参数 项目名称 为 add_executable(项目名称 ${SOURCE_FILES}) 语句中的项目名 以上为例，test.cpp文件要链接pthread，就需要写成 target_link_libraries(test Threads::Threads) 我的CMakeLists.txt文件内容如下 1234567891011121314cmake_minimum_required(VERSION 3.6)project(thread)find_package(Threads REQUIRED)set(CMAKE_CXX_STANDARD 14)add_executable(thread main.cpp)add_executable(server server.cpp)add_executable(client client.cpp)add_executable(testThread1 testThread1.cpp)add_executable(hh hh.cpp)target_link_libraries(thread Threads::Threads)target_link_libraries(testThread1 Threads::Threads) Clion生成可执行文件的路径问题clion默认生成的可执行文件的位置与C&#x2F;C++源文件的位置不同，在某些涉及到相对路径问题的时候，就容易出错，所以有时候需要设置二者同一路径，只需在CMakeLists.txt中添加 1set(CMAKE_RUNTIME_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)# 设置可执行文件的输出路径 Clion带命令行参数运行 注意：要选择正确的可执行文件，比如我这里为mycp","categories":[{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"}],"tags":[{"name":"远程开发","slug":"远程开发","permalink":"http://breadwinners.top/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"}]},{"title":"centOS 7升级gcc，gdb","slug":"centOS 7升级gcc，gdb","date":"2023-03-17T16:00:00.000Z","updated":"2023-07-11T01:57:30.072Z","comments":true,"path":"2023/03/18/centOS 7升级gcc，gdb/","link":"","permalink":"http://breadwinners.top/2023/03/18/centOS%207%E5%8D%87%E7%BA%A7gcc%EF%BC%8Cgdb/","excerpt":"","text":"centOS 7升级gcc，gdbentOS自带的gcc为4.8版本，而使用yum也无法安装更高版本的gcc 获取gcc源代码 获取gcc源代码并上传至虚拟机 解压gcc 1[root@222 ~]# tar -xvf gcc-10.2.0.tar.gz 执行./configure/ 会报错，提示需要安装对应的依赖 123456789configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.Try the --with-gmp, --with-mpfr and/or --with-mpc options to specifytheir locations. Source code for these libraries can be found attheir respective hosting sites as well as atftp://gcc.gnu.org/pub/gcc/infrastructure/. See alsohttp://gcc.gnu.org/install/prerequisites.html for additional info. Ifyou obtained GMP, MPFR and/or MPC from a vendor distribution package,make sure that you have installed both the libraries and the headerfiles. They may be located in separate packages. 本文以MPC：1.0.3 mpfr：3.1.5 gmp：6.1.2安装gcc10.2.0，对应的源代码地址为： MPC : http://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz GMP : http://ftp.gnu.org/gnu/gmp/gmp-6.1.2.tar.xz MPFR : http://ftp.gnu.org/gnu/mpfr/mpfr-3.1.5.tar.gz 安装GMP1234[root@222 ~]# tar -xvf gmp-6.1.2.tar.gz[root@222 ]# cd gmp-6.1.2/[root@222 gmp-6.1.2]# ../gmp-6.1.2/configure --prefix=/usr/local/gmp-6.1.2[root@222 gmp-6.1.2]# make &amp;&amp; make install 安装MPFR1234[root@222 ~]# tar -xvf mpfr-3.1.5.tar.gz[root@222 ~]# cd mpfr-3.1.5/[root@222 mpfr-3.1.5]# ./configure --prefix=/usr/local/mpfr-3.1.5 --with-gmp=/usr/local/gmp-6.1.2[root@222 mpfr-3.1.5]# make &amp;&amp; make install 安装MPC1234[root@222 ~]# tar -xvf mpc-1.0.3.tar.gz[root@222 ~]# cd mpc-1.0.3/[root@222 mpc-1.0.3]# ./configure --prefix=/usr/local/mpc-1.0.3 --with-gmp=/usr/local/gmp-6.1.2--with-mpfr=/usr/local/mpfr-3.1.5[root@222 mpc-1.0.3]# make &amp;&amp; make install 安装gcc12345[root@222 ~]# cd gcc-10.2.0/[root@222 gcc-10.2.0]# mkdir tmp &amp;&amp; cd tmp[root@222 tmp]# ../configure --prefix=/usr/local/gcc-10.2.0/ --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-gmp=/usr/local/gmp-6.1.2 --with-mpfr=/usr/local/mpfr-3.1.5 --with-mpc=/usr/local/mpc-1.0.3[root@222 tmp]# make &amp;&amp; make install 注：最后gcc编译安装的时间很长，可能需要1-2个小时，建议在时间和网络允许的情况下进行 安装完成还需要执行如下命令： 12345678910mv /usr/bin/gcc /usr/bin/gcc485mv /usr/bin/g++ /usr/bin/g++485mv /usr/bin/c++ /usr/bin/c++485mv /usr/bin/cc /usr/bin/cc485ln -s /usr/local/gcc-10.2.0/bin/gcc /usr/bin/gccln -s /usr/local/gcc-10.2.0/bin/g++ /usr/bin/g++ln -s /usr/local/gcc-10.2.0/bin/c++ /usr/bin/c++ln -s /usr/local/gcc-10.2.0/bin/gcc /usr/bin/ccmv /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.bakln -s /usr/local/gcc-10.2.0/lib64/libstdc++.so.6.0.28 /usr/lib64/libstdc++.so.6 最后gcc -v 就可以发现gcc升级成功 中途报错可以查看这位大佬的文章 https://blog.csdn.net/Tsuki_jhsyi77/article/details/103111687 若本方法不行，也可以尝试这位大佬的方法 https://blog.csdn.net/b_ingram/article/details/121569398 gdb升级官网：https://gcc.gnu.org/下载镜像：https://gcc.gnu.org/mirrors.html速度比较好的下载镜像：ftp://mirrors.ustc.edu.cn/gnu/下载gdb-8.3.1.tar.gz;建议在安装gcc前，先装gdb的升级，gdb的升级不能用太高版本的gcc编绎，或者在编绎时指定低版本的gcc。本次成功编绎gdb的gcc版本是：gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)。相关命令如下：tar -xzvf gdb-8.3.1.tar.gzcd gdb-8.3.1如果需要指定编绎的gcc版本，可以用以CC指定具体的gcc，如下面的&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;gcc就是gcc的安装目录：CC&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;gcc .&#x2F;configure否则可以直接编绎:.&#x2F;configuremakemake install在安装前系统需要安装texinfo：yum install texinfo如果之前系统没有安装gcc，先执行：yum install gccyum install gcc-c++ cmake升级https://blog.csdn.net/qq_19734597/article/details/104200371","categories":[{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://breadwinners.top/tags/centos/"},{"name":"gcc","slug":"gcc","permalink":"http://breadwinners.top/tags/gcc/"},{"name":"gdb","slug":"gdb","permalink":"http://breadwinners.top/tags/gdb/"}]},{"title":"Markdown Style test","slug":"markdown","date":"2018-07-24T15:31:06.000Z","updated":"2023-05-02T16:18:22.929Z","comments":true,"path":"2018/07/24/markdown/","link":"","permalink":"http://breadwinners.top/2018/07/24/markdown/","excerpt":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","text":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://breadwinners.top/tags/test/"}]},{"title":"Tag Plugins","slug":"tag-plugins","date":"2013-12-24T16:14:39.000Z","updated":"2023-04-30T06:59:49.462Z","comments":true,"path":"2013/12/25/tag-plugins/","link":"","permalink":"http://breadwinners.top/2013/12/25/tag-plugins/","excerpt":"","text":"This post is used for testing tag plugins. See docs for more info. Block QuoteNormal blockquote Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna. Quote from a bookDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Quote from TwitterNEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Quote from an article on the webEvery interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing Code BlockNormal code block1alert(&#x27;Hello World!&#x27;); With captionArray.map1array.map(callback[, thisArg]) With caption and URL.compactUnderscore.js12.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] With marked linesLine 1,7-8,10 should be marked with different color. 1234567891011const http = require(&#x27;http&#x27;);const hostname = &#x27;127.0.0.1&#x27;;const port = 1337;http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;); res.end(&#x27;Hello World\\n&#x27;);&#125;).listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); Note: Theme’s style should support .highlight.line.marked (recommend to use the selection or current line color). Gist jsFiddle PullquoteLeftLorem ipsum dolor sit amet, consectetur adipiscing elit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac. RightLorem ipsum dolor sit amet, consectetur adipiscing elit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.","categories":[],"tags":[]},{"title":"sufingkeys常用使用说明","slug":"sufingkeys常用使用说明","date":"2013-12-24T15:30:09.000Z","updated":"2023-04-30T15:56:48.626Z","comments":true,"path":"2013/12/24/sufingkeys常用使用说明/","link":"","permalink":"http://breadwinners.top/2013/12/24/sufingkeys%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"normal模式 插入模式 j 向下混动 k 向上滚动 h 向左滚动 l 向右滚动 gg 定位到顶部 G 定位到底部 空格 快速翻页 &#x2F; 搜索页面内容 Ctrl+L Alt+d 光标定位到地址栏 gi 光标定位到搜索框 gf 在新标签页后台打开链接 f 展示页面中所有可以点击的链接，输入相应的字母回车进行跳转 x 关闭当前标签 X 恢复上一个关闭的标签 E 跳到左侧标签 R 跳到右侧标签 yt 复制当前标签页 yy 复制当前地址 yg 截屏 T 快速切换标签 b 搜索书签打开 n 下一处 N 上一处 on 打开新标签 zi 放大 zo 缩小 oh 打开搜索栏查找访问历史 ob 打开百度搜索栏og 打开谷歌搜索栏ow 打开必应搜索栏 sg 用谷歌搜索选中文本 sb 用百度搜索选中文本 sw 用必应搜索选中文本 ss 用stackoverflow搜索选中文本 sh 用github搜索选中文本 gd 打开下载 gh 打开历史记录 cc 打开选中的网址或系统剪贴板里的网址 了解vim的编辑方式 某些网站禁用surfingkeys Alt + s surfingkeys Blacklist","categories":[{"name":"use","slug":"use","permalink":"http://breadwinners.top/categories/use/"}],"tags":[{"name":"浏览器插件","slug":"浏览器插件","permalink":"http://breadwinners.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]}],"categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://breadwinners.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"Linux","slug":"Linux","permalink":"http://breadwinners.top/categories/Linux/"},{"name":"大数据","slug":"大数据","permalink":"http://breadwinners.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/categories/bugs/"},{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/"},{"name":"算法","slug":"论文/算法","permalink":"http://breadwinners.top/categories/%E8%AE%BA%E6%96%87/%E7%AE%97%E6%B3%95/"},{"name":"分类","slug":"分类","permalink":"http://breadwinners.top/categories/%E5%88%86%E7%B1%BB/"},{"name":"算法","slug":"算法","permalink":"http://breadwinners.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"捣鼓","slug":"捣鼓","permalink":"http://breadwinners.top/categories/%E6%8D%A3%E9%BC%93/"},{"name":"设计模式","slug":"设计模式","permalink":"http://breadwinners.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"use","slug":"use","permalink":"http://breadwinners.top/categories/use/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://breadwinners.top/tags/maven/"},{"name":"打包依赖","slug":"打包依赖","permalink":"http://breadwinners.top/tags/%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/"},{"name":"wsl","slug":"wsl","permalink":"http://breadwinners.top/tags/wsl/"},{"name":"wsl2","slug":"wsl2","permalink":"http://breadwinners.top/tags/wsl2/"},{"name":"flume","slug":"flume","permalink":"http://breadwinners.top/tags/flume/"},{"name":"bin目录","slug":"bin目录","permalink":"http://breadwinners.top/tags/bin%E7%9B%AE%E5%BD%95/"},{"name":".bashrc","slug":"bashrc","permalink":"http://breadwinners.top/tags/bashrc/"},{"name":"spark","slug":"spark","permalink":"http://breadwinners.top/tags/spark/"},{"name":"sbt","slug":"sbt","permalink":"http://breadwinners.top/tags/sbt/"},{"name":"redis","slug":"redis","permalink":"http://breadwinners.top/tags/redis/"},{"name":"静态ip","slug":"静态ip","permalink":"http://breadwinners.top/tags/%E9%9D%99%E6%80%81ip/"},{"name":"picgo","slug":"picgo","permalink":"http://breadwinners.top/tags/picgo/"},{"name":"nginx","slug":"nginx","permalink":"http://breadwinners.top/tags/nginx/"},{"name":"论文","slug":"论文","permalink":"http://breadwinners.top/tags/%E8%AE%BA%E6%96%87/"},{"name":"mysql","slug":"mysql","permalink":"http://breadwinners.top/tags/mysql/"},{"name":"bash-4.2$","slug":"bash-4-2","permalink":"http://breadwinners.top/tags/bash-4-2/"},{"name":"标签名","slug":"标签名","permalink":"http://breadwinners.top/tags/%E6%A0%87%E7%AD%BE%E5%90%8D/"},{"name":"数论","slug":"数论","permalink":"http://breadwinners.top/tags/%E6%95%B0%E8%AE%BA/"},{"name":"不能凑出的最大整数","slug":"不能凑出的最大整数","permalink":"http://breadwinners.top/tags/%E4%B8%8D%E8%83%BD%E5%87%91%E5%87%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"},{"name":"DP","slug":"DP","permalink":"http://breadwinners.top/tags/DP/"},{"name":"离散化","slug":"离散化","permalink":"http://breadwinners.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"手写堆","slug":"手写堆","permalink":"http://breadwinners.top/tags/%E6%89%8B%E5%86%99%E5%A0%86/"},{"name":"dfs","slug":"dfs","permalink":"http://breadwinners.top/tags/dfs/"},{"name":"图论","slug":"图论","permalink":"http://breadwinners.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"graph","slug":"graph","permalink":"http://breadwinners.top/tags/graph/"},{"name":"bfs","slug":"bfs","permalink":"http://breadwinners.top/tags/bfs/"},{"name":"前缀和","slug":"前缀和","permalink":"http://breadwinners.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"http://breadwinners.top/tags/%E5%B7%AE%E5%88%86/"},{"name":"连通块","slug":"连通块","permalink":"http://breadwinners.top/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"greedy","slug":"greedy","permalink":"http://breadwinners.top/tags/greedy/"},{"name":"暴力","slug":"暴力","permalink":"http://breadwinners.top/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"模拟","slug":"模拟","permalink":"http://breadwinners.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"sort","slug":"sort","permalink":"http://breadwinners.top/tags/sort/"},{"name":"数组单链表","slug":"数组单链表","permalink":"http://breadwinners.top/tags/%E6%95%B0%E7%BB%84%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://breadwinners.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"Trie","slug":"Trie","permalink":"http://breadwinners.top/tags/Trie/"},{"name":"贪心","slug":"贪心","permalink":"http://breadwinners.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"heap","slug":"heap","permalink":"http://breadwinners.top/tags/heap/"},{"name":"frp","slug":"frp","permalink":"http://breadwinners.top/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://breadwinners.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"bugs","slug":"bugs","permalink":"http://breadwinners.top/tags/bugs/"},{"name":"STL","slug":"STL","permalink":"http://breadwinners.top/tags/STL/"},{"name":"HashMap","slug":"HashMap","permalink":"http://breadwinners.top/tags/HashMap/"},{"name":"双指针","slug":"双指针","permalink":"http://breadwinners.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"quick","slug":"quick","permalink":"http://breadwinners.top/tags/quick/"},{"name":"kmp","slug":"kmp","permalink":"http://breadwinners.top/tags/kmp/"},{"name":"二分","slug":"二分","permalink":"http://breadwinners.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"cin","slug":"cin","permalink":"http://breadwinners.top/tags/cin/"},{"name":"cout","slug":"cout","permalink":"http://breadwinners.top/tags/cout/"},{"name":"su","slug":"su","permalink":"http://breadwinners.top/tags/su/"},{"name":"sudo","slug":"sudo","permalink":"http://breadwinners.top/tags/sudo/"},{"name":"容器","slug":"容器","permalink":"http://breadwinners.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"远程开发","slug":"远程开发","permalink":"http://breadwinners.top/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"centos","slug":"centos","permalink":"http://breadwinners.top/tags/centos/"},{"name":"gcc","slug":"gcc","permalink":"http://breadwinners.top/tags/gcc/"},{"name":"gdb","slug":"gdb","permalink":"http://breadwinners.top/tags/gdb/"},{"name":"test","slug":"test","permalink":"http://breadwinners.top/tags/test/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"http://breadwinners.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]}